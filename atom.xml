<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZY-Zhang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://crunchybiscuits.github.io/"/>
  <updated>2020-07-24T12:41:49.603Z</updated>
  <id>https://crunchybiscuits.github.io/</id>
  
  <author>
    <name>ZY-Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BigO练习</title>
    <link href="https://crunchybiscuits.github.io/2020/07/24/BigO%E7%BB%83%E4%B9%A0/"/>
    <id>https://crunchybiscuits.github.io/2020/07/24/BigO%E7%BB%83%E4%B9%A0/</id>
    <published>2020-07-24T12:41:49.000Z</published>
    <updated>2020-07-24T12:41:49.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Big-O-练习"><a href="#Big-O-练习" class="headerlink" title="Big O 练习"></a>Big O 练习</h1><h2 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h2><p>题目来自《程序员面试金典》第六章例9</p><p>这段代码将平衡二叉搜索树的所有节点值相加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum(node.left) + node.value + sum(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法一：</p><p>由之前的基础介绍可知，通常情况下递归的时间复杂度为O(分支数^递归深度)。</p><p>二叉搜索树的高度约等于log2(N), N为节点数，分支为2，因此可得时间复杂度约为O(2^log2(N)）。</p><p>由2^P = Q 可得，P = log2(Q)。令P = 2^log2(N)，可得log2(P) = log2(N)，所以P = N，因此时间复杂度简化为O(N)</p><p>方法二：</p><p>因为需要所有节点值相加，所以需要遍历N个节点，因此式O(N)</p><h2 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h2><p>斐波那契数列的优化，取自《程序员面试金典》例14，例15</p><p>以下代码打印从0到n的斐波那契数列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allFib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        System.out.println(i + <span class="string">": "</span> + fib(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个陷阱，在看到fib有两支递归调用的时候，能够想到时间复杂度约等于O(2^N)，在外层使用N次循环，那么时间复杂度是O(N * 2^N)，其实并不。</p><p>在每一次调用fib的时候，都是2^N的形式</p><p>那么从1到N，fib函数的运行应该时间是2^1 + 2^2 + ··· + 2^N，这个式子约等于2^(N+1)，也就是说时间复杂度仍然为O(2^N)</p><hr><p>以下通过在allFib函数添加一个数组来保存被计算过的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allFib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            System.out.println(i + <span class="string">": "</span> +fib(i, memo));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] memo)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (memo[n] &gt; <span class="number">0</span>) <span class="keyword">return</span> memo[n];</span><br><span class="line"></span><br><span class="line">        memo[n] = fib(n - <span class="number">1</span>, memo) + fib(n - <span class="number">2</span>, memo);</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>算法的运行将会如下</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fib(0) -&gt;return 0</span><br><span class="line">fib(1)-&gt;return 1</span><br><span class="line">fib(2)</span><br><span class="line">fib(1)-&gt;return 1</span><br><span class="line">fib(0)-&gt;return 0</span><br><span class="line">store 1at memo[2]</span><br><span class="line">fib(3)</span><br><span class="line">fib(2)-&gt;lookup memo[2]-&gt;return 1</span><br><span class="line">fib(1)-&gt;return 1</span><br><span class="line">store 2at memo[3]</span><br><span class="line">fib(4)</span><br><span class="line">fib(3)-&gt;lookup memo[3]-&gt;return 2</span><br><span class="line">fib(2)-&gt;lookup memo[2]-&gt;return 1</span><br><span class="line">store 3at memo[4]</span><br><span class="line">fib(5)</span><br><span class="line">fib(4)-&gt;lookup memo[4]-&gt;return 3</span><br><span class="line">fib(3)-&gt;lookup memo[3]-&gt;return 2</span><br><span class="line">store 5at memo[5]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，每次递归其实是直接从数组中取出之前的值，将不会进行更深层次的调用，也就是说这个过程只是进行了N次常数时间的操作，因此时间复杂度是O(N)。</p><h2 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h2><p> 取自《程序员面试金典》第六章附加题(11)</p><p>该段代码打印所有长度为<strong>K</strong>的字符串，字符串要求有序。代码先生成长度为K的字符串，再检测是否有序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numChars = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSortedStrings</span><span class="params">(<span class="keyword">int</span> remaining)</span> </span>&#123;</span><br><span class="line">    printSortedStrings(remaining, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSortedStrings</span><span class="params">(<span class="keyword">int</span> remaining, String prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (remaining == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isInOrder(prefix)) &#123;</span><br><span class="line">            System.out.println(prefix);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numChars; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = ithLetter(i);</span><br><span class="line">            printSortedStrings(remaining - <span class="number">1</span>, prefix + c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isInOrder</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = ithLetter(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">int</span> curr = ithLetter(s.charAt(i));</span><br><span class="line">        <span class="keyword">if</span> (prev &gt; curr) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">ithLetter</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>) (((<span class="keyword">int</span>) <span class="string">'a'</span>) + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的主要时间增加来自以下两段代码：</p><p>第一段是printSortedStrings中的循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numChars; i++) &#123;</span><br><span class="line">    <span class="keyword">char</span> c = ithLetter(i);</span><br><span class="line">    printSortedStrings(remaining - <span class="number">1</span>, prefix + c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是一个单只的递归调用，在长度为<strong>k</strong>的情形下，每一位都有26 (numChars = 26, 在开头有定义)中可能，因此是c^k的全排列，时间复杂度为O(c^k)</p><p>第二段是isInOrder中的循环用于检测字符串是否有序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isInOrder</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = ithLetter(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">int</span> curr = ithLetter(s.charAt(i));</span><br><span class="line">        <span class="keyword">if</span> (prev &gt; curr) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串长度为<strong>k</strong>，因此每一次检测都需要O(k)的时间</p><p>因此总时间为每一次检测字符串有序的时间乘以生成的总字符串个数，时间复杂度为O(k*c^k)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Big-O-练习&quot;&gt;&lt;a href=&quot;#Big-O-练习&quot; class=&quot;headerlink&quot; title=&quot;Big O 练习&quot;&gt;&lt;/a&gt;Big O 练习&lt;/h1&gt;&lt;h2 id=&quot;例一&quot;&gt;&lt;a href=&quot;#例一&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
    
      <category term="BigO" scheme="https://crunchybiscuits.github.io/tags/BigO/"/>
    
  </entry>
  
  <entry>
    <title>BigO基础介绍02</title>
    <link href="https://crunchybiscuits.github.io/2020/07/23/BigO%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D02/"/>
    <id>https://crunchybiscuits.github.io/2020/07/23/BigO%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D02/</id>
    <published>2020-07-23T08:12:45.000Z</published>
    <updated>2020-07-23T08:19:44.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Big-O-基础介绍-二"><a href="#Big-O-基础介绍-二" class="headerlink" title="Big O 基础介绍(二)"></a>Big O 基础介绍(二)</h1><p>此文参考《程序员面试金典》(第六版)第六章。</p><h2 id="多项式算法的加和乘"><a href="#多项式算法的加和乘" class="headerlink" title="多项式算法的加和乘"></a>多项式算法的加和乘</h2><p>算法中常见的分步形式如下:</p><p><strong>O( A + B )</strong> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a : arrA)&#123;</span><br><span class="line">    print(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> b : arrB)&#123;</span><br><span class="line">    print(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>O( A * B )</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a : arrA)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> b : arrB)&#123;</span><br><span class="line">        print(a + <span class="string">","</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个例子，先遍历A数组，再遍历B数组，所以总数量是O( A + B )。</p><p>第二个例子，对A数组的每个元素都遍历B数组，所以总数量是O( A * B )。</p><ul><li>”先做这个，再做那个”的形式，就是加</li><li>“对这个的每个做那个”的形式，就是乘</li></ul><h2 id="分摊时间"><a href="#分摊时间" class="headerlink" title="分摊时间"></a>分摊时间</h2><p>在计算时间复杂度的时候常常会碰到最坏情况偶尔会出现，一旦发生会消耗很多资源，但是发生之后很长一段时间不会发生，因此需要兼顾正常情况和最坏情况，将时间进行”分摊“。</p><p>例如Java中<code>ArrayList</code>能够灵活的改变大小，能够随着你的插入进行扩容。</p><p><code>ArrayList</code>容量达到限制的时候会创建一个双倍容量的数组，将元素复制到新的数组里面。</p><p>那么描述<code>ArrayList</code>的插入时间，当数组没有满的时候，插入就是O(1)。</p><p>当数组满了，如果数组大小为N，那么需要扩容到2N，并把旧的值复制过去，那么插入就需要O(N)。</p><p>那么”分摊时间“该怎么计算？</p><p>假设需要插入N个元素，<code>ArrayList</code>数组的大小为2的幂数，<strong>当插入一个元素便扩容两倍</strong>。当元素是N的时候，以1，2，4，8，16，32……，N的数组大小成倍的扩容。每次操作需要复制1，2，4，8，16，……，N个元素。</p><p>那么消耗便是1 + 2 + 4 + 8 + 16 + ··· + N的和，从右往左计算便是 N + N/2 + N/4 + N/8 + ··· + 1的和，这个和约等于2N。</p><p>因此，N次插入需要的时间便是O(2N)， 即每次插入的分摊时间为O(1)。</p><h2 id="Log-N-运行时间"><a href="#Log-N-运行时间" class="headerlink" title="Log N 运行时间"></a>Log N 运行时间</h2><p>以二分查找为例。如果一个排序数组的长度为N，目标值为x。首先比较x和中值的大小，如果等于就直接返回，如果x小于便搜索数组中值左边的部分，如果x大于中值便搜索右边的部分。</p><p>开始的时候有N个元素，搜索一次后便是N/2，接着是N/4，直到找到目标或者需要搜索的元素变成1。</p><p>假设有N个元素，总的运行时间便是从N到1一共搜索了多少次。</p><p>如果开始有32个元素</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">N = 32</span><br><span class="line">N = 16 除以2</span><br><span class="line">N = 8  除以2</span><br><span class="line">N = 4  除以2</span><br><span class="line">N = 2  除以2</span><br><span class="line">N = 1  除以2</span><br></pre></td></tr></table></figure><p>从32到1，需要5次</p><p>如果从1开始看，从1到32则需要2^5</p><p>因此得到2^k = N，k = log2(N)</p><p>所以得到运行时间O(logN)</p><p>平衡二叉搜索树中也有同样的情况，每次搜索便将规模减半，最坏情况为平衡二叉搜索树的高度，也是O(logN)。</p><h2 id="递归运行时间"><a href="#递归运行时间" class="headerlink" title="递归运行时间"></a>递归运行时间</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f(n - <span class="number">1</span>) + f(n - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过模拟执行来显示运行时间，如果我们调用f(4)，那么会调用f(3)两次，每个f(3)又会调用f(2)两次，每个f(2)又会调用f(1)两次。如下图显示的节点展开。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/bigo4.jpg" alt="递归节点显示"></p><p>图中一共展开了多少节点？</p><table><thead><tr><th>层</th><th>节点数</th></tr></thead><tbody><tr><td>0</td><td>1</td></tr><tr><td>1</td><td>2 * 上一层节点数 = 2 * 1 = 2 = 2^1</td></tr><tr><td>2</td><td>2 * 上一层节点数 = 2 * 2 = 4 = 2^2</td></tr><tr><td>3</td><td>2 * 上一层节点数 = 2 * 4 = 8 = 2^3</td></tr></tbody></table><p>所以展开是2^0 + 2^1 + 2^2 + 2^3  =  2^4 -1 </p><p>扩展到N则是2^0 + 2^1 + 2^2 + 2^3 + ··· + 2^N = 2^(N+1) - 1</p><p>因此时间复杂度为O(2^(N+1) - 1)舍弃掉常数项为O(2^N)</p><p>常见递归中复杂度通常为，O(分支数^递归深度)，偶尔也有特殊情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Big-O-基础介绍-二&quot;&gt;&lt;a href=&quot;#Big-O-基础介绍-二&quot; class=&quot;headerlink&quot; title=&quot;Big O 基础介绍(二)&quot;&gt;&lt;/a&gt;Big O 基础介绍(二)&lt;/h1&gt;&lt;p&gt;此文参考《程序员面试金典》(第六版)第六章。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
    
      <category term="BigO" scheme="https://crunchybiscuits.github.io/tags/BigO/"/>
    
  </entry>
  
  <entry>
    <title>BigO基础介绍01</title>
    <link href="https://crunchybiscuits.github.io/2020/07/23/BigO%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D01/"/>
    <id>https://crunchybiscuits.github.io/2020/07/23/BigO%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D01/</id>
    <published>2020-07-23T00:52:53.000Z</published>
    <updated>2020-07-23T00:59:36.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Big-O-基础介绍-一"><a href="#Big-O-基础介绍-一" class="headerlink" title="Big O 基础介绍(一)"></a>Big O 基础介绍(一)</h1><p>此文参考《程序员面试金典》(第六版)第六章</p><p>大O符号在算法中用于描述算法效率。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度(渐近运行时间)，也称为大O时间</p><p>举例：</p><p>假设有一个可以无限装下盒子的容器X，N个盒子，一个人P，地点A和B，从A到B运送时间相同。</p><p>方法一：P一次只能从A到B运送一个盒子</p><p>方法二：P也可以选择直接将盒子都装进X再从A到B运送容器X</p><p>使用方法一，随着盒子数目的增加，所消耗的时间也将线性增加，可以表示为O(N)</p><p>使用方法二，无论盒子怎么增加X都能装下，因此运送时间是固定的常量，可表示为O(1)</p><p>时间复杂度也能有很多的变量，比如给一个长X，宽Y，高Z的泳池注水，那么可以表示为O(XYZ)</p><h2 id="O、θ-和Ω"><a href="#O、θ-和Ω" class="headerlink" title="O、θ 和Ω"></a>O、<em>θ</em> 和<em>Ω</em></h2><p>学术界描述运行时间有三种，Big O、Big θ (theta) 和 Big <em>Ω</em> (omega)</p><ul><li>Big O：用于描述运行时间的上界，假设一个算法可以描述为O(N)，那么也可以描述为O(N^2)。类似于，假设一个人可以活到130岁，那么年龄X&lt;=130，也可以说年龄X&lt;=1000，因为130是肯定小于1000的，这里的130就是上界。</li><li>Big <em>Ω</em> (omega)：用于描述运行时间的下界</li><li>Big θ (theta)：用于描述运行时间的确界，如果一个算法为 θ(N)，那么它既是O(N)，也是Ω(N)</li></ul><p>在工业界中直接用O(N)表示确界。</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>空间复杂度为算法占用的内存数量或者空间大小</p><p>如果要创建大小为N的数组那么需要的空间为O(N)。如果是n <strong>x</strong> n的数组，需要的空间为O(N^2)。</p><p>在递归里栈的空间也要算在内。下列sum函数运行时间为O(N)，空间也为O(N)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n + sum(n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈的调用过程如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="number">4</span>)</span><br><span class="line"> -&gt;sum(<span class="number">3</span>)</span><br><span class="line">   -&gt;sum(<span class="number">2</span>)</span><br><span class="line">     -&gt;sum(<span class="number">1</span>)</span><br><span class="line">       -&gt;sum(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这里的递归调用都会添加到调用栈里并占用实际内存。</p><p>但是并不是n次调用都会占用O(N)的空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pairSumSequence</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        sum += pairSum(i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pairSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pairSum方法调用n次，但是调用并不像递归那样同时发生，所以仅仅需要O(1)的空间。</p><h2 id="删除常量"><a href="#删除常量" class="headerlink" title="删除常量"></a>删除常量</h2><p>在特定时候O(N)可能比O(1)还快。例如下图</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/bigo1.jpg" alt="O(N)、O(1)比较, 取自《程序员面试金典》"></p><p>时间复杂度描述的仅仅是算法时间的增长趋势，因此常量不计算在运行时间中。</p><p>例如O(2N)实际上是O(N)，不少人会认为代码中两个非嵌套的循环就是O(2N)这样描述更精确，其实并不。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x : array)&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; min) min = x;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; max) max = x;</span><br><span class="line">&#125;</span><br><span class="line">#************************************</span><br><span class="line"><span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x : array)&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; min) min = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x : array)&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; max) max = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两段代码，第一段一个for循环，第二段两个for循环，但是第一个for循环里有两行，这个要怎么考虑呢？如果真的要详细计算时间复杂度，需要考虑汇编层次，乘法比加法多了多少指令，还要考虑编译器怎么优化等细节，太多太多了。这会让O的计算变得复杂。<strong>我们只需要知道一点，O(N)并不总是比O(N^2)快。</strong></p><h2 id="丢弃不重要的项"><a href="#丢弃不重要的项" class="headerlink" title="丢弃不重要的项"></a>丢弃不重要的项</h2><p>由O(2N)会舍弃常量变成O(N)可知，O(2N^2)会舍弃常量变成O(N^2)，那么O(N^2 + N)该怎么处理？</p><p>由O(2N^2)会舍弃常量变成O(N^2)可知，O(2N^2)可以表示为O(N^2 + N^2)，这里直接舍弃掉了一个N^2。因为 N &lt; N^2 所以O(N^2 + N)也会变成O(N^2)。<img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/bigo2.jpg" alt="例子"></p><p>特殊情况依旧存在，有的时候需要用和的形式表示运行时间。例如，O(B^2) + A 就已经是最简化的形式了。</p><p>下图是常见几个时间复杂度的增长速率。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/bigo3.jpg" alt="增长速率"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Big-O-基础介绍-一&quot;&gt;&lt;a href=&quot;#Big-O-基础介绍-一&quot; class=&quot;headerlink&quot; title=&quot;Big O 基础介绍(一)&quot;&gt;&lt;/a&gt;Big O 基础介绍(一)&lt;/h1&gt;&lt;p&gt;此文参考《程序员面试金典》(第六版)第六章&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
    
      <category term="BigO" scheme="https://crunchybiscuits.github.io/tags/BigO/"/>
    
  </entry>
  
  <entry>
    <title>PicGo+Github搭建图床</title>
    <link href="https://crunchybiscuits.github.io/2020/07/19/PicGo-Github%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"/>
    <id>https://crunchybiscuits.github.io/2020/07/19/PicGo-Github%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/</id>
    <published>2020-07-18T14:26:32.000Z</published>
    <updated>2020-07-18T23:55:28.163Z</updated>
    
    <content type="html"><![CDATA[<p>本文写于2020-07-19，请参考时考虑时间以及软件版本</p><p>PicGo+Github搭建图床，方便图片上传和管理，<a href="https://juejin.im/entry/5c4ec5aaf265da614420689f" target="_blank" rel="noopener">文章参考</a></p><h2 id="Github图床设置"><a href="#Github图床设置" class="headerlink" title="Github图床设置"></a>Github图床设置</h2><p>进入自己的Github账户，创建新的Repository并命名, 因为这里笔者已经创建过Image-Host的库，所以显示重名。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/github_2020-07-19_00-48-53.jpg" alt="创建新的Repository"></p><p>接着进入账户设置</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/github1_2020-07-19_00-53-51.jpg" alt="进入账户设置"></p><p>进入Developer settings</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/github2_2020-07-19_00-56-12.jpg" alt="Developer settings"></p><p>点击Generate new token</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/github3_2020-07-19_01-00-54.jpg" alt="Generate new token"></p><p>为token添加描述，并点选repo, 接着点击最下方的Generate token按钮即可</p><p><strong>注意：创建好后会生成一串token，此token只在github上显示一次，请妥善保存</strong></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/github4_2020-07-19_01-04-59.jpg" alt="token设置"></p><h2 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h2><p>PicGo为免费开源图床管理工具，<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">下载地址在这</a><br>Windows, Mac, Linux系统都有支持<br>并且支持多种平台，如阿里云，腾讯云等</p><p>本文使用PicGo 2.2.2 ，下载好后如图所示<br><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/picgo_2020-07-19_00-35-15.jpg" alt="PicGo界面"></p><p>点开PicGo设置，因为仅使用Github作为图床，所以将剩余的平台显示关闭</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/picgo1_2020-07-19_00-40-03.jpg" alt="PicGo设置"></p><p>点击打开图床设置</p><ul><li>设定仓库名：Github账户名/仓库名</li><li>设定分支名：需填写为master</li><li>设定Token：将在github中生成的token填入</li><li>存储路径：可按自己意愿设定，之后会在github库中创建对应名称文件夹，下图会创建img文件夹</li><li>自定义域名：用于图片的引用和访问，<strong>注意格式必须为<code>https://raw.githubusercontent.com/</code>账户名/仓库名/分支名</strong>，图中为<code>https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master</code></li></ul><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/picgo2_2020-07-19_01-10-53.jpg" alt="图床设置"></p><p>设定完成便可方便的上传以及管理图片</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文写于2020-07-19，请参考时考虑时间以及软件版本&lt;/p&gt;
&lt;p&gt;PicGo+Github搭建图床，方便图片上传和管理，&lt;a href=&quot;https://juejin.im/entry/5c4ec5aaf265da614420689f&quot; target=&quot;_blank
      
    
    </summary>
    
    
    
      <category term="Markdown" scheme="https://crunchybiscuits.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>MarkdownCheatSheet</title>
    <link href="https://crunchybiscuits.github.io/2020/07/17/MarkdownCheatSheet/"/>
    <id>https://crunchybiscuits.github.io/2020/07/17/MarkdownCheatSheet/</id>
    <published>2020-07-16T15:28:38.000Z</published>
    <updated>2020-07-18T23:56:45.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用Markdown语法"><a href="#常用Markdown语法" class="headerlink" title="常用Markdown语法"></a>常用Markdown语法</h1><p>仅列出常用的markdown语法，有不少情况没有列出可参考<a href="https://crunchybiscuits.github.io/2020/07/14/Markdown基础语法/">Markdown基础语法</a></p><table><thead><tr><th>类型</th><th>语法</th></tr></thead><tbody><tr><td>标题</td><td># 一级标题<br>## 二级标题<br>### 三级标题</td></tr><tr><td>加粗</td><td>*<em>文本*</em></td></tr><tr><td>斜体</td><td>*斜体*</td></tr><tr><td>有序列表</td><td>1. first<br>2. second<br>3. third</td></tr><tr><td>无序列表</td><td>- first<br>- second<br>- third</td></tr><tr><td>单行代码</td><td>`代码`</td></tr><tr><td>分隔符</td><td>***</td></tr><tr><td>链接</td><td>[title](<a href="https://example.com" target="_blank" rel="noopener">https://example.com</a>)</td></tr><tr><td>图片</td><td>![text](image.jpg)</td></tr><tr><td>块引用</td><td>&gt; 块引用</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常用Markdown语法&quot;&gt;&lt;a href=&quot;#常用Markdown语法&quot; class=&quot;headerlink&quot; title=&quot;常用Markdown语法&quot;&gt;&lt;/a&gt;常用Markdown语法&lt;/h1&gt;&lt;p&gt;仅列出常用的markdown语法，有不少情况没有列出可参考&lt;
      
    
    </summary>
    
    
    
      <category term="Markdown" scheme="https://crunchybiscuits.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Markdown基础语法</title>
    <link href="https://crunchybiscuits.github.io/2020/07/14/Markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://crunchybiscuits.github.io/2020/07/14/Markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2020-07-14T13:08:30.000Z</published>
    <updated>2020-07-18T23:56:24.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown-基础语法"><a href="#Markdown-基础语法" class="headerlink" title="Markdown 基础语法"></a>Markdown 基础语法</h1><p>Markdown 纯文本标记语言，语法简单易用且支持Markdown的地方都能有一样的效果，此文主要介绍基本语法，<a href="https://www.markdownguide.org/basic-syntax/" target="_blank" rel="noopener">文章参考</a>。</p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>标题以#开头，一个#表示一级标题，两个#表示二级标题，以此类推，最多到六级标题<br>#后需要接空格，不接空格有的可以识别，有的不行。</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><p>效果：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/markdown_2020-07-16_15-48-29.jpg" alt="各级标题效果"></p><hr><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>三个或以上的 * 或者 - 都有相同效果</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">------</span><br><span class="line"><span class="emphasis">***</span></span><br><span class="line"><span class="strong">*****</span>*</span><br></pre></td></tr></table></figure><p>效果：</p><hr><hr><hr><hr><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>超链接格式:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">名字</span>](<span class="link">链接</span>)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">谷歌</span>](<span class="link">https://www.google.com/</span>)</span><br><span class="line">[<span class="string">哔哩哔哩</span>](<span class="link">https://www.bilibili.com/</span>)</span><br></pre></td></tr></table></figure><p>效果：</p><p><a href="https://www.google.com/" target="_blank" rel="noopener">谷歌</a></p><p><a href="https://www.bilibili.com/" target="_blank" rel="noopener">哔哩哔哩</a></p><hr><h2 id="字体相关"><a href="#字体相关" class="headerlink" title="字体相关"></a>字体相关</h2><p>常见字体操作 <strong>加粗</strong>，<em>斜体</em>，<strong><em>斜体加粗</em></strong>，<del>删除线</del></p><p>示例:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**加粗**</span></span><br><span class="line"><span class="emphasis">*斜体*</span></span><br><span class="line"><span class="strong">***斜体加粗**</span>*</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>效果：</p><p><strong>加粗</strong></p><p><em>斜体</em></p><p><strong><em>斜体加粗</em></strong></p><p><del>删除线</del></p><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>在引用段落前添加 &gt;</p><p>如果引用段落有多行，需要每行添加 &gt;</p><p>嵌套引用则使用多个 &gt;</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 第一行引用</span></span><br><span class="line"><span class="quote">&gt; 第二行引用</span></span><br><span class="line">&gt;&gt; 嵌套引用</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>第一行引用</p><p>第二行引用</p><blockquote><p>嵌套引用</p></blockquote></blockquote><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>单行代码使用``包含</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`print('hello world')`</span></span><br></pre></td></tr></table></figure><p>效果：</p><p><code>print(&#39;hello world&#39;)</code></p><p>多行代码前后使用```包含</p><p>这里直接使用```会有格式错误，用括号包起来了</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="code">```</span>)</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"><span class="code">    System.out.println();</span></span><br><span class="line">&#125;</span><br><span class="line">(<span class="code">```</span>)</span><br></pre></td></tr></table></figure><p>效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>数字加点的形式（如 1.）</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>第一行</span><br><span class="line"><span class="bullet">2. </span>第二行</span><br><span class="line"><span class="bullet">3. </span>第三行</span><br></pre></td></tr></table></figure><p>效果：</p><ol><li>第一行</li><li>第二行</li><li>第三行</li></ol><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>在一行前使用 - ,+ ,* 任意一个即可 </p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>第1行</span><br><span class="line"><span class="bullet">+ </span>第2行</span><br><span class="line"><span class="bullet">* </span>第3行</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li>第一行</li></ul><ul><li>第二行</li></ul><ul><li>第三行</li></ul><hr><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>语法&amp;示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">这里是图片描述，显示在图片下方</span>](<span class="link">图片地址 "title，鼠标移动到图片上时显示"</span>)</span><br><span class="line"></span><br><span class="line">![<span class="string"> bilibili banner</span>](<span class="link">https://i0.hdslb.com/bfs/archive/22650682fd25a4a5aa96dd9ef53190c6b8d54912.png "bilibili banner"</span>)</span><br></pre></td></tr></table></figure><p>效果（点开可看到图片描述）</p><p><img src= "/img/loading.gif" data-src="https://i0.hdslb.com/bfs/archive/22650682fd25a4a5aa96dd9ef53190c6b8d54912.png" alt=" bilibili banner"></p><p>图片链接支持本地、网络链接以及将图片转码成base64存入markdown文件中</p><p>这里使用了PicGo+Github图床的方式</p><hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>语法格式：</p><p>其中每列的表头和内容用三个或三个以上 “-“ ( — ) 隔开，并用”|”分隔每一列</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 第一列 | 第二列 |</span><br><span class="line">| ----- | ----- |</span><br><span class="line">| zs    | 1     |</span><br><span class="line">| ls    | 2     |</span><br></pre></td></tr></table></figure><p>效果：</p><table><thead><tr><th>第一列</th><th>第二列</th></tr></thead><tbody><tr><td>zs</td><td>1</td></tr><tr><td>ls</td><td>2</td></tr></tbody></table><h3 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h3><p>通过在”—“处的左边，右边或者两边，来添加左对齐，右对齐和居中的效果</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| 第一列 | 第二列 | 第三列 |</span><br><span class="line">| :----- | :-----: | -----: |</span><br><span class="line">| 靠左   | 居中   | 靠右  |</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">第一列</th><th align="center">第二列</th><th align="right">第三列</th></tr></thead><tbody><tr><td align="left">靠左</td><td align="center">居中</td><td align="right">靠右</td></tr></tbody></table><hr><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>通过在字符前添加”\“，来防止字符被用于markdown文本格式</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>hello </span><br><span class="line">\* hello</span><br><span class="line"></span><br><span class="line"><span class="strong">**world**</span></span><br><span class="line">\<span class="emphasis">*\*</span>world**</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li>hello </li></ul><p>* hello</p><p><strong>world</strong></p><p>**world**</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Markdown-基础语法&quot;&gt;&lt;a href=&quot;#Markdown-基础语法&quot; class=&quot;headerlink&quot; title=&quot;Markdown 基础语法&quot;&gt;&lt;/a&gt;Markdown 基础语法&lt;/h1&gt;&lt;p&gt;Markdown 纯文本标记语言，语法简单易用且支持
      
    
    </summary>
    
    
    
      <category term="Markdown" scheme="https://crunchybiscuits.github.io/tags/Markdown/"/>
    
  </entry>
  
</feed>
