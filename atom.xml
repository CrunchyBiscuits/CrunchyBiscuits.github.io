<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZY-Zhang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://crunchybiscuits.github.io/"/>
  <updated>2021-03-22T17:10:57.732Z</updated>
  <id>https://crunchybiscuits.github.io/</id>
  
  <author>
    <name>ZY-Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基础shader记录</title>
    <link href="https://crunchybiscuits.github.io/2021/03/22/%E5%9F%BA%E7%A1%80shader%E8%AE%B0%E5%BD%95/"/>
    <id>https://crunchybiscuits.github.io/2021/03/22/%E5%9F%BA%E7%A1%80shader%E8%AE%B0%E5%BD%95/</id>
    <published>2021-03-22T12:35:48.000Z</published>
    <updated>2021-03-22T17:10:57.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础shader分析"><a href="#基础shader分析" class="headerlink" title="基础shader分析"></a>基础shader分析</h1><h2 id="常见的语义词："><a href="#常见的语义词：" class="headerlink" title="常见的语义词："></a>常见的语义词：</h2><ol><li>获取顶点 — float4 vertex : POSITION;</li><li>获取第一uv — float2 uv : TEXCOORD0;</li><li>获取发现 — float3 normal : NORMAL;</li><li>获取顶点色 — float4 color : COLOR；</li><li>获取切线 — float4 tan : TANGENT；</li></ol><p><strong>常用的数据类型对应</strong></p><p>精度设置float – 32位，half – 16位， fixed – 8位</p><ol><li>float常用于坐标点 </li><li>half常用于UV和大部分向量</li><li>fixed常用于颜色</li></ol><h2 id="基础shader内容："><a href="#基础shader内容：" class="headerlink" title="基础shader内容："></a>基础shader内容：</h2><h3 id="获取位置坐标并输出"><a href="#获取位置坐标并输出" class="headerlink" title="获取位置坐标并输出"></a>获取位置坐标并输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1. 基础变换 -- 顶点着色器中将物体转换到裁剪空间</span><br><span class="line">v2f vert(appdata v)&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    &#x2F;&#x2F; 模型转换到世界空间</span><br><span class="line">    float4 pos_world &#x3D; mul(_Object2World, v.vertex);</span><br><span class="line">    &#x2F;&#x2F; 世界空间到相机空间</span><br><span class="line">    float4 pos_view &#x3D; mul(UNITY_MATRIX_V, pos_world);</span><br><span class="line">    &#x2F;&#x2F; 相机空间到裁剪空间</span><br><span class="line">    float4 pos_clip &#x3D; mul(UNITY_MATRIX_P, pow_view);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 以上变换可以用mvp代替</span><br><span class="line">    &#x2F;&#x2F; o.pos &#x3D; UnityObjectToClipPos(v.vertex);</span><br><span class="line">    </span><br><span class="line">    o.pos &#x3D; pos_clip;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. 输出颜色 -- 片元着色器获取顶点并输出</span><br><span class="line">float4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">    return float4(0.5,1.0,0.5,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的内容</strong><br>在声明的构造体appdata和v2f中的TEXCOORD0是有差别的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct appdata&#123;</span><br><span class="line">    &#x2F;&#x2F; 第一套uv</span><br><span class="line">    float2 uv : TEXCOORD0;</span><br><span class="line">    &#x2F;&#x2F; 第二套uv</span><br><span class="line">    float2 uv2 : TEXCOORD1; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f&#123;</span><br><span class="line">    &#x2F;&#x2F; 这里表示的是存储器、插值器</span><br><span class="line">    float2 uv : TEXCOORD0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="获取uv贴图并输出"><a href="#获取uv贴图并输出" class="headerlink" title="获取uv贴图并输出"></a>获取uv贴图并输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. 基础变换 -- 顶点着色器中将物体转换到裁剪空间,获取uv</span><br><span class="line">sampler2D _MainTex;</span><br><span class="line">&#x2F;&#x2F; 这个参数是跟贴图的tilling和offset链接</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">v2f vert(appdata v)&#123;</span><br><span class="line">    v2f o;</span><br><span class="line"></span><br><span class="line">    o.pos &#x3D; UnityObjectToClipPos(v.vertex);</span><br><span class="line">    &#x2F;&#x2F; o.uv &#x3D; v.uv;</span><br><span class="line">    o.uv &#x3D; v.uv * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. 输出颜色 -- 片元着色器获uv并输出</span><br><span class="line">float4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">    &#x2F;&#x2F;获取uv并输出 </span><br><span class="line">    float4 col &#x3D; tex2D(_MainTex, i.uv);</span><br><span class="line">    return col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="背面剔除"><a href="#背面剔除" class="headerlink" title="背面剔除"></a>背面剔除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Properties&#123;</span><br><span class="line">    [Enum(UnityEngine.Rendering.CullMode)]_CullMode(&quot;CullMode&quot;, float) &#x3D; 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubShader&#123;</span><br><span class="line">    Pass&#123;</span><br><span class="line">        Cull[_CullMode]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Alpha-Test"><a href="#Alpha-Test" class="headerlink" title="Alpha Test"></a>Alpha Test</h3><p>对clip()函数的使用：</p><p>大体思路：</p><ol><li>通过tex2D获取r通道</li><li>对gradient进行操作</li><li>输出</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="纹理映射问题"><a href="#纹理映射问题" class="headerlink" title="纹理映射问题"></a>纹理映射问题</h3><h4 id="贴图平整采样的操作-32min"><a href="#贴图平整采样的操作-32min" class="headerlink" title="贴图平整采样的操作 32min"></a>贴图平整采样的操作 32min</h4><h4 id="uv不连续导致纹理图像失真，光栅化中导致插值不连续"><a href="#uv不连续导致纹理图像失真，光栅化中导致插值不连续" class="headerlink" title="uv不连续导致纹理图像失真，光栅化中导致插值不连续"></a>uv不连续导致纹理图像失真，光栅化中导致插值不连续</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础shader分析&quot;&gt;&lt;a href=&quot;#基础shader分析&quot; class=&quot;headerlink&quot; title=&quot;基础shader分析&quot;&gt;&lt;/a&gt;基础shader分析&lt;/h1&gt;&lt;h2 id=&quot;常见的语义词：&quot;&gt;&lt;a href=&quot;#常见的语义词：&quot; class
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>GAMES202作业0</title>
    <link href="https://crunchybiscuits.github.io/2021/03/22/GAMES202%E4%BD%9C%E4%B8%9A0/"/>
    <id>https://crunchybiscuits.github.io/2021/03/22/GAMES202%E4%BD%9C%E4%B8%9A0/</id>
    <published>2021-03-21T16:25:10.000Z</published>
    <updated>2021-03-21T16:32:17.620Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GAMES202作业0"><a href="#GAMES202作业0" class="headerlink" title="GAMES202作业0"></a>GAMES202作业0</h1><p>本次作业主要为熟悉框架，通过框架实现blinn-phong，无特殊要求</p><p>大致步骤：</p><ol><li>使用GLSL编写对应vert和frag shader</li><li>将shader的字符串形式传递到javascript实现的PhongMaterial类中</li><li>在index.html中导入</li><li>将框架中原来使用的Material替换为编写好的PhongMaterial类</li></ol><h3 id="最初效果"><a href="#最初效果" class="headerlink" title="最初效果"></a>最初效果</h3><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/202assign0_1.jpg" alt="渲染方程"></p><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/202assign0_2.jpg" alt="渲染方程"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GAMES202作业0&quot;&gt;&lt;a href=&quot;#GAMES202作业0&quot; class=&quot;headerlink&quot; title=&quot;GAMES202作业0&quot;&gt;&lt;/a&gt;GAMES202作业0&lt;/h1&gt;&lt;p&gt;本次作业主要为熟悉框架，通过框架实现blinn-phong，无特殊要
      
    
    </summary>
    
    
    
      <category term="GAMES202" scheme="https://crunchybiscuits.github.io/tags/GAMES202/"/>
    
  </entry>
  
  <entry>
    <title>GAMES202-Lecture2笔记</title>
    <link href="https://crunchybiscuits.github.io/2021/03/20/GAMES202-Lecture2%E7%AC%94%E8%AE%B0/"/>
    <id>https://crunchybiscuits.github.io/2021/03/20/GAMES202-Lecture2%E7%AC%94%E8%AE%B0/</id>
    <published>2021-03-20T08:59:35.000Z</published>
    <updated>2021-03-21T16:28:21.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GAMES202第二课"><a href="#GAMES202第二课" class="headerlink" title="GAMES202第二课"></a>GAMES202第二课</h1><h2 id="基本渲染管线"><a href="#基本渲染管线" class="headerlink" title="基本渲染管线"></a>基本渲染管线</h2><ol><li>体在空间中的表示 – 点，点和点之间的连接关系</li></ol><ul><li>顶点处理    MVP</li><li>图元装配和光栅化</li><li>片元处理</li><li>输出合并</li></ul><ol start="2"><li><p>型（Blinn-Phong等等）在光线的弹射和阴影的表现上并不是很好（并不是100%真实，在全局和间接光照上处理的不好）</p><p>好处是GPU上跑很快</p></li><li><p>纹理映射和插值–重心坐标</p></li></ol><h2 id="OpenGL-GLSL"><a href="#OpenGL-GLSL" class="headerlink" title="OpenGL(GLSL)"></a>OpenGL(GLSL)</h2><h3 id="OpenGL介绍"><a href="#OpenGL介绍" class="headerlink" title="OpenGL介绍"></a>OpenGL介绍</h3><p>OpenGL是一个API的集合，是CPU运行的负责调用GPU工作任务的。</p><p>优势：</p><ul><li>语言无关</li><li>跨平台</li></ul><p>坏处：</p><ul><li>版本特别碎片化</li><li>C语言风格，不方便使用</li></ul><p><strong>在每个pass中进行的过程</strong></p><ol><li>放置物体和模型<ol><li>模型声明</li><li>模型摆放 – model transformation</li><li>VBO：GPU中的一块区域用于存储模型与.obj文件特别相似</li></ol></li><li>设置相机位置<ol><li>视口变换 – view transformation</li><li>在OpenGL中创建framebuffer</li></ol></li><li>设置画布<ol><li>这里OpenGL可以multiple render target</li><li>垂直同步，双重缓冲，三重缓冲，目的都是为了防止画面撕裂，撕裂原因是在帧缓冲中上一帧画面渲染到一般又渲染了下一帧</li></ol></li><li>画 – shading<ol><li>vertex<ol><li>对顶点进行插值</li></ol></li><li>图元装配光栅化</li><li>fragment<ol><li>片段着色</li><li>lighting</li></ol></li></ol></li><li>接着画，画多次 – multiple passes<ol><li>shadowmap的作法<ol><li>计算光源能看到什么</li><li>再通过camera来计算这些物体能不能被light看到，不能就是在阴影中</li></ol></li></ol></li></ol><p>Shader setup步骤</p><ol><li>创建shader</li><li>编译shader</li><li>将shader加载到程序中(attach program)</li><li>连接程序(link program)</li><li>使用程序(use program)</li></ol><h3 id="Vertex-Shader-顶点着色器"><a href="#Vertex-Shader-顶点着色器" class="headerlink" title="Vertex Shader(顶点着色器)"></a>Vertex Shader(顶点着色器)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// attribute这个只可能在vertex shader中出现，fragment shader中没有</span></span><br><span class="line"><span class="comment">// 顶点位置</span></span><br><span class="line">attribute vec3 aVertexPosition;</span><br><span class="line"><span class="comment">// 法线位置</span></span><br><span class="line">attribute vec3 aNormalPosition;</span><br><span class="line"><span class="comment">// 纹理坐标</span></span><br><span class="line">attribute vec3 aTextureCoord;</span><br><span class="line"></span><br><span class="line"><span class="comment">// uniform关键字指定全局变量，vertex和fragment shader都可以用</span></span><br><span class="line">uniform mat4 uModeViewMatrix;</span><br><span class="line">uniform mat4 uProjectionMatrix;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过varying关键字指定fragment shader中需要插值的量</span></span><br><span class="line"><span class="comment">// highp指定计算精度</span></span><br><span class="line">varying highp vec2 vTextureCoord;</span><br><span class="line">varying highp vec3 vFragPos;</span><br><span class="line">varying highp vec3 vNormal;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 设置要传给frag的属性</span></span><br><span class="line">    vFragPos = aVertexPosition;</span><br><span class="line">    vNormal = aNormalPosition;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换成齐次坐标再进行MVP</span></span><br><span class="line">    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, <span class="number">1.0</span>);</span><br><span class="line">    </span><br><span class="line">    vTextureCoord = aTextureCoord;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Fragment-shader"><a href="#Fragment-shader" class="headerlink" title="Fragment shader"></a>Fragment shader</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uniform关键字指定全局变量，vertex和fragment shader都可以用</span></span><br><span class="line">uniform sampler2D uSampler;</span><br><span class="line"><span class="comment">// binn</span></span><br><span class="line">uniform vec3 uKd;</span><br><span class="line">uniform vec3 uKs;</span><br><span class="line">uniform vec3 uLightPos;</span><br><span class="line">uniform vec3 uCameraPos;</span><br><span class="line">uniform <span class="keyword">float</span> uLightIntensity;</span><br><span class="line">uniform <span class="keyword">int</span> uTextureSample;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过varying关键字指定fragment shader中需要插值的量</span></span><br><span class="line">varying highp vec2 vTextureCoord;</span><br><span class="line">varying highp vec3 vFragPos;</span><br><span class="line">varying highp vec3 vNormal;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    vec3 color;</span><br><span class="line">    <span class="keyword">if</span>(uTextureSample == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// vec3(2.2)表示伽马矫正</span></span><br><span class="line">        color = <span class="built_in">pow</span>(texture2D(uSampler, vTextureCoord).rgb, vec3(<span class="number">2.2</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        color = uKd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 环境光</span></span><br><span class="line">    vec3 ambient = <span class="number">0.05</span> * color;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 光线方向由光源位置-点位置得到</span></span><br><span class="line">    vec3 lightDir = normalize(uLightPos - vFragPos);</span><br><span class="line">    vec3 normal = normalize(vNormal);</span><br><span class="line">    <span class="comment">// 兰伯特</span></span><br><span class="line">    <span class="keyword">float</span> diff = max(dot(lightDir, normal), <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// 光照强度系数</span></span><br><span class="line">    <span class="keyword">float</span> light_atten_coff = uLightIntensity / length(uLightPos - vFragPos);</span><br><span class="line">    <span class="comment">// 漫反射</span></span><br><span class="line">    vec3 diffuse = diff * light_atten_coff * color;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 视线方向</span></span><br><span class="line">    vec3 viewDir = normalize(uCameraPos - vFragPos);</span><br><span class="line">    <span class="keyword">float</span> spec = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// 反射方向，需要从点出发，光源方向也是从点出发表示，因此为-lightDir</span></span><br><span class="line">    vec3 reflectDir = reflect(-lightDir, normal);</span><br><span class="line">    <span class="comment">// 高光</span></span><br><span class="line">    spec = <span class="built_in">pow</span>(max(dot(viewDir, reflectDir), <span class="number">0.0</span>), <span class="number">35.0</span>);</span><br><span class="line">    <span class="comment">// 加上高光强度</span></span><br><span class="line">    vec3 specular = uKs * light_atten_coff * spec;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// blinn-phong</span></span><br><span class="line">    gl_FragColor = vec4(<span class="built_in">pow</span>((ambient + diffuse + specular), vec3(<span class="number">1.0</span>/<span class="number">2.2</span>)), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h2><p>在渲染中是最为重要的</p><ul><li>描述了光线的传播</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/rendering%20equation.jpg" alt="渲染方程"></p><p>意思解释：</p><ol><li>outgoing radiance：当前点发出的radiance</li><li>emission：点的自发光</li><li>BRDF * cosθ * dw：BRDF乘上cosθ然后乘以其他地方打到这个点上的radiance<ol><li>cosθ * dw： 是将radiance转换成irradiance</li></ol></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/render%20equation2.jpg" alt="渲染方程"></p><p>V(p, w)：表示点是否可以接收到当前传过来的那束光</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GAMES202第二课&quot;&gt;&lt;a href=&quot;#GAMES202第二课&quot; class=&quot;headerlink&quot; title=&quot;GAMES202第二课&quot;&gt;&lt;/a&gt;GAMES202第二课&lt;/h1&gt;&lt;h2 id=&quot;基本渲染管线&quot;&gt;&lt;a href=&quot;#基本渲染管线&quot; cla
      
    
    </summary>
    
    
    
      <category term="GAMES202" scheme="https://crunchybiscuits.github.io/tags/GAMES202/"/>
    
  </entry>
  
  <entry>
    <title>unity shader代码结构</title>
    <link href="https://crunchybiscuits.github.io/2021/03/20/shader%E7%BB%93%E6%9E%84/"/>
    <id>https://crunchybiscuits.github.io/2021/03/20/shader%E7%BB%93%E6%9E%84/</id>
    <published>2021-03-19T16:14:00.000Z</published>
    <updated>2021-03-22T17:18:36.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity-Shader基础代码结构"><a href="#Unity-Shader基础代码结构" class="headerlink" title="Unity Shader基础代码结构"></a>Unity Shader基础代码结构</h1><p>部分资料取自冯乐乐的《Unity Shader入门精要》</p><h2 id="名字"><a href="#名字" class="headerlink" title="名字"></a>名字</h2><p>在shader第一行我们需要指定unity shader的名字，名字可以通过“/”来进行层次的划分，例如“Custom/TestShader”</p><p>在unity的材质面板中就能在Custom标签那一栏中找到TestShader</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/shader%E7%BB%93%E6%9E%84.jpg" alt="shader结构"></p><p><strong>语法：</strong></p><figure class="highlight plain"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom&#x2F;TestShader&quot;&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>在这里设置需要unity材质面板中能够方便调整的各种属性</p><p>这里的属性包含三个部分：</p><ol><li>名字：名字主要是在unity shader中访问需要的名字，通常是以”_”开始</li><li>显示名称：这里的名称是在unity材质面板中显示的名字</li><li>类型：类型则指定了unity shader中这些属性的类型，并且我们需要给这些属性提供默认值</li></ol><p>Properties中支持以下类型：</p><table><thead><tr><th>属性类型</th><th>例子</th></tr></thead><tbody><tr><td>Int</td><td>_Number (“Number”, Int) = 2</td></tr><tr><td>Float</td><td>_Intensity (“Intensity”, Float) = 1.5</td></tr><tr><td>Range(min, max)</td><td>_SideRange (“SideRange”, Range(0.0, 5.0)) = 3.0</td></tr><tr><td>Color</td><td>_RimColor (“RimColor”, Color) = (1,1,1,1)</td></tr><tr><td>Vector</td><td>_LightDir (“LightDir”, Vector) = (2,3,6,1)</td></tr><tr><td>2D</td><td>_2DTex (“2D”, 2D) = “”{}</td></tr><tr><td>Cube</td><td>_CubeTex (“Cube”, Cube) = “white”{}</td></tr><tr><td>3D</td><td>_3DTex (“3D”, 3D) = “white”{}</td></tr></tbody></table><h2 id="Subshader"><a href="#Subshader" class="headerlink" title="Subshader"></a>Subshader</h2><p>每个unity shader可以包含多个subshader，在加载shader的时候会扫描所有的subshader模块，然后选择第一个能够使用的subshader。如果都不行那么就会使用Fallback定义的unity shader。subshader和pass中都可以包含Tags和RenderSetup，如果设置在subshader中那么将适用于所有的pass</p><p><strong>subshader结构：</strong></p><figure class="highlight plain"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SubShader&#123;</span><br><span class="line">    &#x2F;&#x2F; 可选部分</span><br><span class="line">    [Tags]</span><br><span class="line">    </span><br><span class="line">    [RenderSetup]</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; pass定义，可以有多个pass</span><br><span class="line">    &#x2F;&#x2F; 第一个pass</span><br><span class="line">    Pass&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 第二个pass</span><br><span class="line">    Pass&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RenderSetup"><a href="#RenderSetup" class="headerlink" title="RenderSetup"></a>RenderSetup</h3><p>提供一些列渲染状态的设置，例如是否开启混合，开启深度测试等等</p><table><thead><tr><th>状态名称</th><th>设置指令</th><th>解释</th></tr></thead><tbody><tr><td>Cull</td><td>Cull Back|Front|Off</td><td>设置剔除模式：背面/正面/关闭</td></tr><tr><td>ZTest</td><td>ZTest Less|Greater|LEqual|GEqual|Equal|NotEqual|Always</td><td>设置深度测试使用函数</td></tr><tr><td>ZWrite</td><td>ZWrite On|Off</td><td>深度写入开关</td></tr><tr><td>Blend</td><td>Blend SrcFactor DstFactor</td><td>混合模式设置</td></tr></tbody></table><p>ZTest参数解释：</p><ul><li>LEqual：小于等于</li><li>GEqual：大于等于</li><li>Always：无论如何都通过</li></ul><h3 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h3><p>Tags是以键值对的形式存在的，主要是告诉渲染引擎，希望怎样来渲染这个对象</p><p><strong>标签结构</strong></p><figure class="highlight plain"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags &#123;&quot;TagName1&quot;&#x3D;&quot;Value1&quot; &quot;TagName2&quot;&#x3D;&quot;Value2&quot;&#125;</span><br></pre></td></tr></table></figure><p><strong>常用的两种标签类型</strong></p><table><thead><tr><th>标签类型</th><th>说明</th><th></th></tr></thead><tbody><tr><td>Queue</td><td>控制渲染顺序，指定渲染队列</td><td>Tags {“Queue”=”Transparent”}</td></tr><tr><td>RenderType</td><td>对着色器进行分类，例如不透明和透明着色器，可用于Shader replacement</td><td>Tags {“RenderType”=”Opaque”}</td></tr></tbody></table><h2 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h2><p>Fallback用于告诉unity如果所有subshader都不能用那么就用这里这个，Fallback还可用于阴影的投射</p><p>Fallback “shader名字”</p><p>Fallback off</p><hr><p>最终unity shader大致结构如下：</p><figure class="highlight plain"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom&#x2F;SimpleShader&quot;&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        pass&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="shader样例"><a href="#shader样例" class="headerlink" title="shader样例"></a>shader样例</h2><figure class="highlight plain"><figcaption><span>Shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom&#x2F;testShader&quot;&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        &#x2F;&#x2F; _Float为变量名字,可以自由更改，以_起头作为传统 </span><br><span class="line">        _Float(&quot;Float&quot;, Float) &#x3D; 0.0</span><br><span class="line">        _Range(&quot;Range&quot;, Range(0.0,1.0)) &#x3D; 0.0</span><br><span class="line">        _Vector(&quot;Vector&quot;, Vector) &#x3D; (1,1,1,1)</span><br><span class="line">        _Color(&quot;Color&quot;, Color) &#x3D; (0.5,0.5,0.5,0.5)</span><br><span class="line">        _MainTex(&quot;MainTex&quot;, 2D) &#x3D; &quot;black&quot;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        pass&#123;</span><br><span class="line">            &#x2F;&#x2F; 以CGPROGRAM和ENDCG包裹</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line"></span><br><span class="line">            struct appdata&#123;</span><br><span class="line">                float4 vertex:POSITION;</span><br><span class="line">                float2 uv:TEXCOORD0;&#x2F;&#x2F;TEXCOORD0这里是第一套uv的意思</span><br><span class="line">                &#x2F;&#x2F; float3 normal:NORMAL;</span><br><span class="line">                &#x2F;&#x2F; float4 color:COLOR;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos:SV_POSITION;</span><br><span class="line">                float2 uv:TEXCOORD0; &#x2F;&#x2F;TEXCOORD0是储存器</span><br><span class="line">            &#125;;</span><br><span class="line">            &#x2F;&#x2F; 这里声明的变量需要和Properties里面的一致</span><br><span class="line">            float4 _Color;</span><br><span class="line">            &#x2F;&#x2F; 纹理需要配一个float4才能够调用tilling和offset</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">            v2f vert(appdata v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                &#x2F;&#x2F; mvp变换的两种方式</span><br><span class="line">                &#x2F;&#x2F; float4 world_pos &#x3D; mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">                &#x2F;&#x2F; float4 camera_pos &#x3D; mul(UNITY_MATRIX_V, world_pos);</span><br><span class="line">                &#x2F;&#x2F; float4 projection_pos &#x3D; mul(UNITY_MATRIX_P, camera_pos);</span><br><span class="line">                float4 projection_pos &#x3D; UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.pos &#x3D; projection_pos;</span><br><span class="line">                &#x2F;&#x2F; 获取uv</span><br><span class="line">                o.uv &#x3D; v.uv * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            float4 frag(v2f i):SV_TARGET&#123;</span><br><span class="line">                &#x2F;&#x2F; 贴图采样</span><br><span class="line">                float4 col &#x3D; tex2D(_MainTex, i.uv);</span><br><span class="line">                return col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Unity-Shader基础代码结构&quot;&gt;&lt;a href=&quot;#Unity-Shader基础代码结构&quot; class=&quot;headerlink&quot; title=&quot;Unity Shader基础代码结构&quot;&gt;&lt;/a&gt;Unity Shader基础代码结构&lt;/h1&gt;&lt;p&gt;部分资料取自
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>Docker常用指令</title>
    <link href="https://crunchybiscuits.github.io/2021/03/02/Docker%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>https://crunchybiscuits.github.io/2021/03/02/Docker%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</id>
    <published>2021-03-02T11:39:54.000Z</published>
    <updated>2021-03-02T11:42:09.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker常用指令"><a href="#Docker常用指令" class="headerlink" title="Docker常用指令"></a>Docker常用指令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version         # 显示版本信息</span><br><span class="line">docker info        # 显示系统信息，包括镜像和容器数量</span><br><span class="line">docker 命令 --help    #  帮助命令</span><br></pre></td></tr></table></figure><p>帮助文档的地址：<a href="https://docs.docker.com/get-started/">https://docs.docker.com/get-started/</a></p><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><h3 id="docker-images：查看所有本地的主机上的镜像"><a href="#docker-images：查看所有本地的主机上的镜像" class="headerlink" title="docker images：查看所有本地的主机上的镜像"></a><strong>docker images</strong>：查看所有本地的主机上的镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY                                               TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">tensorflow&#x2F;serving                                       latest    784e871ab5a4   4 weeks ago    298MB</span><br><span class="line"></span><br><span class="line"># 解释</span><br><span class="line">REPOSITORY    镜像的仓库名</span><br><span class="line">TAG        镜像的标签</span><br><span class="line">IMAGE ID    镜像的ID</span><br><span class="line">CREATED        镜像创建时间</span><br><span class="line">SIZE        镜像的大小</span><br><span class="line"></span><br><span class="line"># 常用可选项</span><br><span class="line">Options:</span><br><span class="line">  -a, --all             # 列出所有的镜像</span><br><span class="line">  -q, --quiet           # 只显示镜像ID</span><br></pre></td></tr></table></figure><h3 id="docker-search：搜索镜像"><a href="#docker-search：搜索镜像" class="headerlink" title="docker search：搜索镜像"></a><strong>docker search</strong>：搜索镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(base) zzy@zzydeMacBook-Pro ~ % docker search mysql</span><br><span class="line">NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql                             MySQL is a widely used, open-source relation…   10565     [OK]</span><br><span class="line">mariadb                           MariaDB Server is a high performing open sou…   3947      [OK]</span><br><span class="line">mysql&#x2F;mysql-server                Optimized MySQL Server Docker images. Create…   774                  [OK]</span><br><span class="line">percona                           Percona Server is a fork of the MySQL relati…   527       [OK]</span><br><span class="line"></span><br><span class="line"># 解释</span><br><span class="line">STARS    收藏</span><br><span class="line"></span><br><span class="line"># 常用可选项</span><br><span class="line">--filter&#x3D;STARS&#x3D;3000    搜索出来的镜像STARS大于3000</span><br><span class="line"></span><br><span class="line">(base) zzy@zzydeMacBook-Pro ~ % docker search mysql --filter&#x3D;STARS&#x3D;3000</span><br><span class="line">NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql     MySQL is a widely used, open-source relation…   10565     [OK]</span><br><span class="line">mariadb   MariaDB Server is a high performing open sou…   3947      [OK]</span><br></pre></td></tr></table></figure><h3 id="docker-pull：下载镜像"><a href="#docker-pull：下载镜像" class="headerlink" title="docker pull：下载镜像"></a><strong>docker pull</strong>：下载镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 下载镜像 docker pull 镜像名[:tag]</span><br><span class="line"></span><br><span class="line">(base) zzy@zzydeMacBook-Pro ~ % docker pull mysql</span><br><span class="line">Using default tag: latest    #如果不指定tag，默认是最新的</span><br><span class="line">latest: Pulling from library&#x2F;mysql</span><br><span class="line">45b42c59be33: Pull complete        #分层下载，docker images的核心</span><br><span class="line">b4f790bd91da: Pull complete</span><br><span class="line">325ae51788e9: Pull complete</span><br><span class="line">adcb9439d751: Pull complete</span><br><span class="line">174c7fe16c78: Pull complete</span><br><span class="line">698058ef136c: Pull complete</span><br><span class="line">4690143a669e: Pull complete</span><br><span class="line">f7599a246fd6: Pull complete</span><br><span class="line">35a55bf0c196: Pull complete</span><br><span class="line">790ac54f4c47: Pull complete</span><br><span class="line">b0ddd5d1b543: Pull complete</span><br><span class="line">1aefd67cb33d: Pull complete</span><br><span class="line">Digest: sha256:7706e4c382be813b58ef514f2bdac747cd463a6866c6c81165d42a1d0e4fe947</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br><span class="line">docker.io&#x2F;library&#x2F;mysql:latest    #真实地址</span><br><span class="line"></span><br><span class="line"># 等价的, 版本必须来自docker hub</span><br><span class="line">docker pull mysql</span><br><span class="line">docker pull mysql:lastest</span><br></pre></td></tr></table></figure><h3 id="docker-rmi：删除镜像"><a href="#docker-rmi：删除镜像" class="headerlink" title="docker rmi：删除镜像"></a><strong>docker rmi</strong>：删除镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 删除指定容器</span><br><span class="line">docker rm -f 容器id</span><br><span class="line"># 删除所有</span><br><span class="line">docker rmi -f $(docker images -aq)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(base) zzy@zzydeMacBook-Pro ~ % docker rmi -f 8457e9155715</span><br><span class="line">Untagged: mysql:latest</span><br><span class="line">Untagged: mysql@sha256:7706e4c382be813b58ef514f2bdac747cd463a6866c6c81165d42a1d0e4fe947</span><br><span class="line">Deleted: sha256:8457e9155715d4e1c80c9e048d94c9b47b5b733fa927756280382dd326403644</span><br><span class="line">Deleted: sha256:f0d02d3f5fc5a0f745bf3a97ec0b26c6b2d8b05288d98d954eeb87c4a6d47146</span><br><span class="line">Deleted: sha256:bf1129a8799d8beaafa396d6333a3ba6eac9d0d7f606491f9794c470fb2dd311</span><br><span class="line">Deleted: sha256:4386f82820992c927b924177ed3e4c2ffd477d4db7a63539ac76fd09ee36cd89</span><br><span class="line">Deleted: sha256:d7494c9168a11444d8b13558068409ace7393452f08f878686eec45122ee56c1</span><br><span class="line">Deleted: sha256:08dbcab3fe630e39bbabaa9f0ae72ec6d100bf1e400ebb4b7f04151b18bca89c</span><br><span class="line">Deleted: sha256:c3f78dcd6bcc4c156554296323e0eed74a4d2d93b304be15f55c1ef62dd06e0a</span><br><span class="line">Deleted: sha256:f89b66495a65489290c8edb71e0dbf9e3d0d6213b82cebc2554b271599f2f99d</span><br><span class="line">Deleted: sha256:1918839317d9988ff5e0168e336717e32820af1e77c3121297efc73a387ecdc5</span><br><span class="line">Deleted: sha256:1d2bcd52664a92805e5f49d94d3649323dd0f5682ae3e1380fa07b7a54d6ceb0</span><br><span class="line">Deleted: sha256:787de05fee96c7ba99e49f17d72aec68769a7373a8881a27917bdbf83dca58e8</span><br><span class="line">Deleted: sha256:eb82f9a2fbd7a4a0fdfbe40b5e77a995ccf73ab91364d90f4db820fd59dbf63b</span><br><span class="line">Deleted: sha256:9eb82f04c782ef3f5ca25911e60d75e441ce0fe82e49f0dbf02c81a3161d1300</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p>说明：有了镜像才可以创建容器，这里下载一个centos镜像进行尝试</p><h3 id="新建容器并启动"><a href="#新建容器并启动" class="headerlink" title="新建容器并启动"></a>新建容器并启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker run [参数] image &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line"># 参数说明</span><br><span class="line">--name&#x3D;&quot;Name&quot;    容器名字，用来区分容器</span><br><span class="line">-d        后台方式运行</span><br><span class="line">-it        使用交互方式运行，进入容器查看内容</span><br><span class="line">-p        指定容器的端口</span><br><span class="line">    -p    主机端口：容器端口</span><br><span class="line">    -p    容器端口</span><br><span class="line">    容器端口</span><br><span class="line">-P        随机指定端口</span><br><span class="line"></span><br><span class="line"># 启动并进入容器</span><br><span class="line">docker run -it centos &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="列出所有运行的容器"><a href="#列出所有运行的容器" class="headerlink" title="列出所有运行的容器"></a>列出所有运行的容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker ps    # 列出当前正在运行的容器</span><br><span class="line"> -a         # 列出当前正在运行的容器+历史运行容器</span><br><span class="line"> -n&#x3D;?        # 显示最近创建的容器</span><br><span class="line"> -q        # 只显示容器编号</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit        # 直接停止容器并退出</span><br><span class="line">Ctrl + P + Q    # 容器不停止，但是退出</span><br></pre></td></tr></table></figure><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id            # 删除指定容器，不能删除正在运行中的容器</span><br><span class="line">docker rm -f $(docker ps -aq)    # 删除所有容器</span><br><span class="line">docker ps -a -q|xargs docker rm    # 删除所有容器(linux版)</span><br></pre></td></tr></table></figure><h3 id="启动和停止"><a href="#启动和停止" class="headerlink" title="启动和停止"></a>启动和停止</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id    # 启动容器</span><br><span class="line">docker restart 容器id    # 重启容器</span><br><span class="line">docker stop 容器id    # 停止当前正在运行的容器</span><br><span class="line">docker kill 容器id    # 强制停止当前容器</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker常用指令&quot;&gt;&lt;a href=&quot;#Docker常用指令&quot; class=&quot;headerlink&quot; title=&quot;Docker常用指令&quot;&gt;&lt;/a&gt;Docker常用指令&lt;/h1&gt;&lt;h2 id=&quot;帮助命令&quot;&gt;&lt;a href=&quot;#帮助命令&quot; class=&quot;head
      
    
    </summary>
    
    
    
      <category term="Docker" scheme="https://crunchybiscuits.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker梳理</title>
    <link href="https://crunchybiscuits.github.io/2021/02/27/Docker%E6%A2%B3%E7%90%86/"/>
    <id>https://crunchybiscuits.github.io/2021/02/27/Docker%E6%A2%B3%E7%90%86/</id>
    <published>2021-02-26T16:31:56.000Z</published>
    <updated>2021-03-01T16:31:43.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="联合文件系统"><a href="#联合文件系统" class="headerlink" title="联合文件系统"></a>联合文件系统</h2><p>它支持对文件系统的修改作为一次提交来一层一层的叠加，可以看到每一次修改，极大节省内存和空间</p><ul><li>bootfs，主要包含bootloader和kernal<ul><li>黑屏到开机的过程</li></ul></li><li>rootfs<ul><li>不同的发行版</li></ul></li></ul><h2 id="镜像分层"><a href="#镜像分层" class="headerlink" title="镜像分层"></a>镜像分层</h2><p>每操作一步都加新的一层<br>从远程pull下来的镜像层是无法改变的<br>run之后已经新加了一层<br>所有操作都是基于容器层的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; class=&quot;headerlink&quot; title=&quot;Docker&quot;&gt;&lt;/a&gt;Docker&lt;/h1&gt;&lt;h2 id=&quot;联合文件系统&quot;&gt;&lt;a href=&quot;#联合文件系统&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
    
      <category term="Docker" scheme="https://crunchybiscuits.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker打包上传训练模型</title>
    <link href="https://crunchybiscuits.github.io/2021/02/23/Docker%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B/"/>
    <id>https://crunchybiscuits.github.io/2021/02/23/Docker%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-02-23T15:53:15.000Z</published>
    <updated>2021-03-01T16:29:14.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker打包上传多个训练好的模型"><a href="#Docker打包上传多个训练好的模型" class="headerlink" title="Docker打包上传多个训练好的模型"></a>Docker打包上传多个训练好的模型</h1><h2 id="模型文件路径设置"><a href="#模型文件路径设置" class="headerlink" title="模型文件路径设置"></a>模型文件路径设置</h2><p>pbmodel</p><p>​    ├─model1<br>​        ├─0<br>​            ├─variables<br>​            ├─saved_model.pb<br>​    ├─model2<br>​        ├─0<br>​            ├─variables<br>​            ├─saved_model.pb<br>​    └models.config</p><h2 id="docker脚本设置"><a href="#docker脚本设置" class="headerlink" title="docker脚本设置"></a>docker脚本设置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> keras2tensorflow test.py</span></span><br><span class="line"></span><br><span class="line">base_repo_name=&#x27;tensorflow/serving&#x27; #基础镜像</span><br><span class="line">base_repo_tag=&#x27;latest&#x27;</span><br><span class="line">hub_repo_name=&#x27;hub.xxx.xx/xxx/video_blurred_model_base&#x27;</span><br><span class="line">hub_repo_tag=&#x27;v0.1&#x27;</span><br><span class="line">commit_msg=&#x27;添加花屏检测模型&#x27;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">container_id=`docker run -itd -p 8501:8501 <span class="variable">$&#123;base_repo_name&#125;</span><span class="string">&#x27;:&#x27;</span><span class="variable">$&#123;base_repo_tag&#125;</span> --model_config_file=/models/models.config /bin/bash`</span></span><br><span class="line">container_id=`docker run -itd -p 8501:8501 $&#123;base_repo_name&#125;&#x27;:&#x27;$&#123;base_repo_tag&#125; /bin/bash`</span><br><span class="line">echo &quot;container_id is : &quot;</span><br><span class="line">echo $container_id</span><br><span class="line">docker cp /Users/zzy/PycharmProjects/video-parsing-models/pbmodel/models.config $container_id:/models</span><br><span class="line">docker cp /Users/zzy/PycharmProjects/video-parsing-models/pbmodel/blurred_screen_model $container_id:/models</span><br><span class="line">sha_image_id=`docker commit -m $&#123;commit_msg&#125; $&#123;container_id&#125;`</span><br><span class="line">echo $&#123;sha_image_id&#125;</span><br><span class="line">image_id=($&#123;sha_image_id//sha256:/&#125;) #需要将返回的sha256:image_id进行过滤</span><br><span class="line">docker tag $&#123;image_id&#125; $&#123;hub_repo_name&#125;&#x27;:&#x27;$&#123;hub_repo_tag&#125;</span><br><span class="line">docker push $&#123;hub_repo_name&#125;&#x27;:&#x27;$&#123;hub_repo_tag&#125;</span><br><span class="line">docker restart $&#123;container_id&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="models-config文件设置"><a href="#models-config文件设置" class="headerlink" title="models.config文件设置"></a>models.config文件设置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">model_config_list &#123;</span><br><span class="line">  config &#123;</span><br><span class="line">    name: &#39;blurred_screen_model&#39;</span><br><span class="line">    base_path: &#39;&#x2F;models&#x2F;blurred_screen_model&#39;</span><br><span class="line">    model_platform: &#39;tensorflow&#39;</span><br><span class="line">  &#125;</span><br><span class="line">  config &#123;</span><br><span class="line">    name: &#39;blurred_screen_model2&#39;</span><br><span class="line">    base_path: &#39;&#x2F;models&#x2F;blurred_screen_model2&#39;</span><br><span class="line">    model_platform: &#39;tensorflow&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker打包上传多个训练好的模型&quot;&gt;&lt;a href=&quot;#Docker打包上传多个训练好的模型&quot; class=&quot;headerlink&quot; title=&quot;Docker打包上传多个训练好的模型&quot;&gt;&lt;/a&gt;Docker打包上传多个训练好的模型&lt;/h1&gt;&lt;h2 id=&quot;模
      
    
    </summary>
    
    
    
      <category term="Docker" scheme="https://crunchybiscuits.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>keras热力图</title>
    <link href="https://crunchybiscuits.github.io/2021/02/22/keras%E7%83%AD%E5%8A%9B%E5%9B%BE/"/>
    <id>https://crunchybiscuits.github.io/2021/02/22/keras%E7%83%AD%E5%8A%9B%E5%9B%BE/</id>
    <published>2021-02-22T14:12:02.000Z</published>
    <updated>2021-02-22T14:14:13.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="keras-热力图"><a href="#keras-热力图" class="headerlink" title="keras 热力图"></a>keras 热力图</h1><p>主要用于对神经网络训练的参考</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">keras神经网络的可视化</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.applications.vgg16 <span class="keyword">import</span> preprocess_input</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> load_model</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">image_size = <span class="number">224</span></span><br><span class="line"></span><br><span class="line">model_path = <span class="string">&quot;模型地址&quot;</span></span><br><span class="line">img_path = <span class="string">&quot;图片地址&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载之前训练好的模型</span></span><br><span class="line">model = load_model(model_path)</span><br><span class="line">image = cv2.imread(img_path)</span><br><span class="line">img_tensor = preprocessing.image.img_to_array(image)</span><br><span class="line">img_tensor = np.expand_dims(img_tensor, axis=<span class="number">0</span>)</span><br><span class="line">img_tensor = preprocess_input(img_tensor)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取最后一层卷积，以(Conv2d)标注的最后一个</span></span><br><span class="line">conv_layer = model.get_layer(<span class="string">&quot;conv2d_93&quot;</span>)</span><br><span class="line">heatmap_model = models.Model([model.inputs], [conv_layer.output, model.output])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取最后一层卷积的梯度</span></span><br><span class="line"><span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> gtape:</span><br><span class="line">    conv_output, predictions = heatmap_model(img_tensor)</span><br><span class="line">    loss = predictions[:, np.argmax(predictions[<span class="number">0</span>])]</span><br><span class="line">    grads = gtape.gradient(loss, conv_output)[<span class="number">0</span>]</span><br><span class="line">    pooled_grads = K.mean(grads, axis=(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 热力图归一化</span></span><br><span class="line">heatmap = tf.reduce_mean(tf.multiply(pooled_grads, conv_output), axis=<span class="number">-1</span>)</span><br><span class="line">heatmap = np.maximum(heatmap, <span class="number">0</span>)</span><br><span class="line">max_heat = np.max(heatmap)</span><br><span class="line"><span class="keyword">if</span> max_heat == <span class="number">0</span>:</span><br><span class="line">    max_heat = <span class="number">1e-10</span></span><br><span class="line">heatmap /= max_heat</span><br><span class="line">heatmap = np.uint8(<span class="number">255</span> * heatmap)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 热力图和原图合并</span></span><br><span class="line">img = cv2.imread(img_path)</span><br><span class="line">heatmap1 = cv2.resize(heatmap[<span class="number">0</span>], (img.shape[<span class="number">1</span>], img.shape[<span class="number">0</span>]), interpolation=cv2.INTER_CUBIC)</span><br><span class="line">heatmap1 = np.uint8(<span class="number">255</span>*heatmap1)</span><br><span class="line">heatmap1 = cv2.applyColorMap(heatmap1, cv2.COLORMAP_JET)</span><br><span class="line">frame_out = cv2.addWeighted(img, <span class="number">0.5</span>, heatmap1, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;热力图保存路径&#x27;</span>, frame_out)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;finish&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;keras-热力图&quot;&gt;&lt;a href=&quot;#keras-热力图&quot; class=&quot;headerlink&quot; title=&quot;keras 热力图&quot;&gt;&lt;/a&gt;keras 热力图&lt;/h1&gt;&lt;p&gt;主要用于对神经网络训练的参考&lt;/p&gt;
&lt;figure class=&quot;highligh
      
    
    </summary>
    
    
    
      <category term="keras" scheme="https://crunchybiscuits.github.io/tags/keras/"/>
    
  </entry>
  
  <entry>
    <title>渲染管线流程</title>
    <link href="https://crunchybiscuits.github.io/2021/02/20/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%B5%81%E7%A8%8B/"/>
    <id>https://crunchybiscuits.github.io/2021/02/20/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%B5%81%E7%A8%8B/</id>
    <published>2021-02-20T13:53:09.000Z</published>
    <updated>2021-03-01T16:35:08.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h1><p>大的流程</p><ol><li>数据资源</li><li>渲染管线</li><li>2d图像</li></ol><p>Unity内置的渲染管线分类</p><ol><li>CPU应用程序段渲染逻辑</li><li>GPU渲染管线</li></ol><h2 id="Unity渲染的流程："><a href="#Unity渲染的流程：" class="headerlink" title="Unity渲染的流程："></a>Unity渲染的流程：</h2><ol><li><p><strong>Camera组件调用Renderer()</strong></p></li><li><p><strong>剔除操作</strong></p><ol><li>视椎体剔除：根据field of view，近裁面和远裁面构成的锥体。剔除指会跟视椎体做一个碰撞检测，有相交的部分就表明应该被绘制，如果没有的话就应该剔掉。<strong>这里可以通过包围盒进行加速和优化</strong>。</li><li>遮挡剔除：</li><li>层级剔除：根据特定层级的物体进行剔除，Culling mask操作</li></ol></li><li><p><strong>渲染顺序</strong>：</p><ol><li>按距离</li><li>按渲染队列：Render Queue越小越先被渲染，不透明队列&lt;2500，半透明队列&gt;2500<ol><li>不透明物体默认是2000</li><li>半透明物体默认是3000</li><li>相等情况：不透明队列从前向后排序（优化方便剔除），半透明队列从后向前排序（渲染效果正确性）</li></ol></li></ol></li><li><p><strong>打包数据</strong>：</p><ol><li>模型信息：顶点坐标、法线(会合并相同的)、UV(会合并相同的，是一个二维数据，只有前两个分量有用)、顶点色、索引列表</li><li>变换矩阵：MVP</li><li>灯光、材质参数：Shader、材质参数、灯光信息</li></ol></li><li><p><strong>调用Shader</strong>: 告诉渲染管线现在要渲染哪些模型数据，要用哪个shader</p><ol><li>SetPassCall()：设置好渲染状态，使用哪种shader，哪种混合模式，设置好背面剔除</li><li>DrawCall()：使用哪些模型数据进行渲染</li></ol></li><li><p><strong>GPU渲染管线</strong>：25min</p><ol><li>顶点处理：从模型空间到裁剪空间，见顶点shader</li><li>图元装配和光栅化：<ol><li>裁剪操作：对三角面的操作而不是物体的剔除(通过判断顶点坐标进行操作)</li><li>NDC标准化设备坐标：透视除法(同时除以w)</li><li>背面剔除：引用模型的索引列表，如果索引排列顺序呈顺时针就留下，逆时针就是背面</li><li>屏幕坐标：通过视口转换(只针对x,y坐标)，z坐标用来判断前后关系</li><li>图元装配：连线，形成三角形(Bresenham画线)</li><li>光栅化：通过插值算法生成片元，z坐标变成深度值</li></ol></li><li>片元处理：见片元shader</li><li>输出合并：片源数据-&gt;alpha测试-&gt;模板测试-&gt;深度测试-&gt;混合-&gt;帧缓冲区<ol><li>最重要任务处理遮挡关系、处理半透明混合</li><li>帧缓冲区</li><li>深度测试<ol><li>zwrite 深度写入 即使通过深度测试也不会刷新缓冲区，并不影响颜色缓冲区的写入</li><li>ztest 深度测试 1h27min<ol><li>Early-z发生在片元shader之前或者顶点shader之后</li></ol></li></ol></li><li>混合：从后到前，关闭ZWrite</li></ol></li></ol></li><li><p><strong>帧缓冲区</strong>：一个跟屏幕大小一样的临时画布，等场景里的物体渲染完成后，屏幕就能从这个缓冲区里拿到图像</p></li><li><p><strong>后处理逻辑</strong>：这个阶段可再次调用逻辑</p></li><li><p><strong>再次GPU渲染管线</strong></p></li></ol><p><strong>多个摄像机</strong><br>每一个摄像机都会调用上述的流程<br>Unity摄像机：</p><ol><li>摄像机在清屏之前会调用clean flag，可以选择不清屏</li><li>depth可以选择先后顺序，越小越先渲染</li></ol><p><strong>Shader</strong></p><ol><li>顶点shader：主要处理投影成像操作，并不会完成2D成像，主要完成对3D场景的变形<ol><li>放置物体：模型空间-&gt;世界空间</li><li>摆好相机：世界空间-&gt;相机空间</li><li>摁下快门：相机空间-&gt;裁剪空间</li></ol></li><li>片元shader：最重要任务，上色<ol><li>纹理技术 56min<ol><li>纹理采样：根据采样公式给片元上色</li><li>纹理过滤机制 – 对应到Unity就是filter mode：<ol><li>四舍五入（不好用）</li><li>采样周围的四个插值进行计算（双线性插值）</li></ol></li><li>Mipmap：纹理链 – Unity可以生成Mipmap</li><li>纹理寻址模式：超出纹素范围的地址该怎么操作(uv坐标超过1怎么操作)</li><li>纹理压缩格式：RGBA，ASTC，ETC2，PVRTC</li></ol></li><li>光照计算<ol><li>光照组成</li><li>光照模型<ol><li>Phong光照模型 – 基于经验的光照模型 max(N<em>L,0.0)+pow(max(R</em>V,0.0),smoothness)+ambient = Phong<ol><li>漫反射  – 点乘得到cos值</li><li>高光反射 – 光滑度决定衰减范围，光滑度越小，衰减越大</li><li>环境光 – Lightmap、Reflection Probe、Light Probe</li></ol></li><li>基本思路：直接光漫反射+直接光镜面反射+间接光漫反射+间接光镜面反射</li></ol></li></ol></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;渲染管线&quot;&gt;&lt;a href=&quot;#渲染管线&quot; class=&quot;headerlink&quot; title=&quot;渲染管线&quot;&gt;&lt;/a&gt;渲染管线&lt;/h1&gt;&lt;p&gt;大的流程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据资源&lt;/li&gt;
&lt;li&gt;渲染管线&lt;/li&gt;
&lt;li&gt;2d图像&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>UV和像素</title>
    <link href="https://crunchybiscuits.github.io/2021/02/15/UV%E5%92%8C%E5%83%8F%E7%B4%A0/"/>
    <id>https://crunchybiscuits.github.io/2021/02/15/UV%E5%92%8C%E5%83%8F%E7%B4%A0/</id>
    <published>2021-02-15T13:23:07.000Z</published>
    <updated>2021-02-17T15:34:14.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UV介绍"><a href="#UV介绍" class="headerlink" title="UV介绍"></a>UV介绍</h1><p>每个模型，都是由一个个的面组成的，而UV纹理，我们可以通俗地看作是由这些所有的面构成的模型的“皮肤”，它的工作方式是将这些三维的“皮肤”二维化分布到一个正方形的画布上，然后通过绘制的贴图，将贴图的细节从正方形的画布投射到三维的空间上。</p><h2 id="在纹理贴图中"><a href="#在纹理贴图中" class="headerlink" title="在纹理贴图中"></a>在纹理贴图中</h2><p>对于纹理贴图而言，一张贴图的U和V坐标的数值范围都是0到1，而不管他的实际分辨率是多少，MAYA会自动把UV纹理坐标换算成贴图的象素坐标。</p><p>“UV”这里是指u,v纹理贴图坐标的简称(它和空间模型的X, Y, Z轴是类似的)，它定义了图片上每个点的位置的信息. 这些点与3D模型是相互联系的， 以决定表面纹理贴图的位置， UV就是将图像上每一个点精确对应到模型物体的表面， 在点与点之间的间隙位置由软件进行图像光滑插值处理， 这就是所谓的UV贴图</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;UV介绍&quot;&gt;&lt;a href=&quot;#UV介绍&quot; class=&quot;headerlink&quot; title=&quot;UV介绍&quot;&gt;&lt;/a&gt;UV介绍&lt;/h1&gt;&lt;p&gt;每个模型，都是由一个个的面组成的，而UV纹理，我们可以通俗地看作是由这些所有的面构成的模型的“皮肤”，它的工作方式是将这些三
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>渲染器的诞生(四)--Transformation和MVP</title>
    <link href="https://crunchybiscuits.github.io/2021/02/15/MVP/"/>
    <id>https://crunchybiscuits.github.io/2021/02/15/MVP/</id>
    <published>2021-02-15T07:37:01.000Z</published>
    <updated>2021-02-26T16:29:47.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h1><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>主要有两种变换</p><ul><li>模型变换</li><li>视图变换</li></ul><p>从三维世界到二维平面的投影</p><h2 id="基础变换"><a href="#基础变换" class="headerlink" title="基础变换"></a>基础变换</h2><ul><li>缩放</li><li>旋转</li><li>切变</li></ul><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><p>(x, y) –&gt; (sx, sy)</p><h3 id="切变"><a href="#切变" class="headerlink" title="切变"></a>切变</h3><p>(x, y) –&gt; (x+ay, y)<br>(x, y) –&gt; (x, y+bx)</p><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>旋转默认逆时针旋转</p><p>旋转的逆矩阵就是旋转的转置</p><p>旋转矩阵是正交矩阵</p><p>（x, y）–&gt; (ax+by, cx+dy)</p><h2 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h2><p>线性变换矩阵无法表示平移变换<br>(x, y) –&gt; (x+tx, y+ty)</p><ul><li>平移<br>引入齐次坐标就是为了能将平移变换也纳入线性变换的形式</li></ul><p>2D 点 = (x, y, 1)<br>2D 向量 = (x, y, 0)<br><strong>为什么为0，因为向量表示一种方向性，具有平移不变性，做任何平移还是等于原来的向量</strong><br>可进行的操作：</p><ul><li>向量 + 向量 = 向量 </li><li>点 - 点 = 向量</li><li>点 + 向量 = 点</li><li>点 + 点 = 表示这两个点的中点</li></ul><h2 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h2><p>通过齐次坐标的形式<br>(x, y, 1) –&gt; (x’, y’, 1)</p><h3 id="复合变换"><a href="#复合变换" class="headerlink" title="复合变换"></a>复合变换</h3><p>变换顺序是非常重要的，矩阵不满足交换律<br>变换是从右到左的顺序进行的<br>先应用线性变换，再平移</p><h2 id="分解复杂的变换"><a href="#分解复杂的变换" class="headerlink" title="分解复杂的变换"></a>分解复杂的变换</h2><p>举例</p><h1 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h1><ul><li><p>缩放</p></li><li><p>平移<br>两个同2d空间类似</p></li><li><p>旋转<br>绕y轴比较特殊</p></li></ul><h2 id="3D旋转"><a href="#3D旋转" class="headerlink" title="3D旋转"></a>3D旋转</h2><p>可以将任意旋转分解成Rxyz = Rx Ry Rz</p><h3 id="罗德里格斯旋转公式"><a href="#罗德里格斯旋转公式" class="headerlink" title="罗德里格斯旋转公式"></a>罗德里格斯旋转公式</h3><h1 id="View-Transformation"><a href="#View-Transformation" class="headerlink" title="View Transformation"></a>View Transformation</h1><ol><li>找一个好的物体 model transformation</li><li>找一个好的角度 view transformation</li><li>拍照 projection transformation</li><li>得到照片</li></ol><p>因为相机和物体一起进行变换，相对位置没变，之后改变相机位置就好</p><h2 id="如何进行view-transformation"><a href="#如何进行view-transformation" class="headerlink" title="如何进行view transformation"></a>如何进行view transformation</h2><p>拍照的过程</p><ol><li>确定位置</li><li>确定look at(往哪儿看)</li><li>确定up direction(向上方向)</li></ol><p>相机放在一个固定的位置，其他东西移动<br>相机永远在原点，看向-z轴，向上为y轴<br>可以让操作简化</p><h2 id="transformation过程"><a href="#transformation过程" class="headerlink" title="transformation过程"></a>transformation过程</h2><ol><li>将摄像机摆放好<ol><li>移到原点</li><li>look at转到-z</li><li>向上转到y</li></ol></li></ol><p>先平移再旋转<br>Mview = Rview Tview</p><h2 id="这里思想很重要"><a href="#这里思想很重要" class="headerlink" title="这里思想很重要"></a>这里思想很重要</h2><p>但是直接写旋转不好写，将其他轴转到规范轴<br>所以求逆变换，因为旋转是正交的，求转置就好，不用直接求逆</p><h1 id="Projection-Transformation"><a href="#Projection-Transformation" class="headerlink" title="Projection Transformation"></a>Projection Transformation</h1><ul><li>Orthographic projection</li><li>Perspective projection</li></ul><h2 id="Orthographic-projection"><a href="#Orthographic-projection" class="headerlink" title="Orthographic projection"></a>Orthographic projection</h2><ol><li>相机固定位置</li><li>扔掉z轴</li><li>将结果展到[-1,1]^2上</li></ol><p>在xyz上定义一个标准立方体(canonical) cube</p><h2 id="Perspective-projection"><a href="#Perspective-projection" class="headerlink" title="Perspective projection"></a>Perspective projection</h2><ol><li>先将透视的锥体压缩到标准立方体<ol><li>近平面永远不变</li><li>远平面z不发生改变，远平面中心点不变</li><li>相似三角形算出y‘=(n/z)y，x’=(n/z)x</li><li>z由特性得知，在近平面点不变<ol><li>再由远平面上中心点也是不变的</li><li>得到一个二次方程</li><li>A=n+f，B=-nf</li></ol></li></ol></li><li>再进行正交投影</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Transformation&quot;&gt;&lt;a href=&quot;#Transformation&quot; class=&quot;headerlink&quot; title=&quot;Transformation&quot;&gt;&lt;/a&gt;Transformation&lt;/h1&gt;&lt;h2 id=&quot;Why&quot;&gt;&lt;a href=&quot;#Wh
      
    
    </summary>
    
    
    
      <category term="Renderer" scheme="https://crunchybiscuits.github.io/tags/Renderer/"/>
    
  </entry>
  
  <entry>
    <title>渲染器的诞生(三)--深度缓冲</title>
    <link href="https://crunchybiscuits.github.io/2021/02/13/%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/"/>
    <id>https://crunchybiscuits.github.io/2021/02/13/%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/</id>
    <published>2021-02-13T04:21:06.000Z</published>
    <updated>2021-03-01T16:34:10.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度缓冲"><a href="#深度缓冲" class="headerlink" title="深度缓冲"></a>深度缓冲</h1><p>由于画家算法的缺陷，我们常常在3D渲染中碰到错位的情况，因此引入深度缓冲来解决这样的问题。通过深度缓冲来存放场景中点距离照相机的远近，以此来判断当前像素点应该渲染出的颜色。这样渲染器就可以顺序的去处理场景。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ul><li>遍历每一个三角形<ul><li>遍历三角形中的样本<ul><li>如果当前深度值小于之前的值</li><li>更新样本颜色</li><li>更新深度缓存</li><li>否则什么都不做</li></ul></li></ul></li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历包围盒</span></span><br><span class="line"><span class="keyword">for</span> (P.x=bboxmin.x; P.x&lt;=bboxmax.x; P.x++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (P.y=bboxmin.y; P.y&lt;=bboxmax.y; P.y++) &#123;</span><br><span class="line">        <span class="comment">// 通过重心坐标判断位置</span></span><br><span class="line">        Vec3f bc_screen  = barycentric(pts[<span class="number">0</span>], pts[<span class="number">1</span>], pts[<span class="number">2</span>], P);</span><br><span class="line">        <span class="comment">// 在三角形外就跳过</span></span><br><span class="line">        <span class="keyword">if</span> (bc_screen.x&lt;<span class="number">0</span> || bc_screen.y&lt;<span class="number">0</span> || bc_screen.z&lt;<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        P.z = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 获取z值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) P.z += pts[i][<span class="number">2</span>]*bc_screen[i];</span><br><span class="line">        <span class="comment">// 深度缓存更新</span></span><br><span class="line">        <span class="keyword">if</span> (zbuffer[<span class="keyword">int</span>(P.x+P.y*<span class="built_in">width</span>)]&lt;P.z) &#123;</span><br><span class="line">            zbuffer[<span class="keyword">int</span>(P.x+P.y*<span class="built_in">width</span>)] = P.z;</span><br><span class="line">            <span class="built_in">image</span>.<span class="built_in">set</span>(P.x, P.y, color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深度缓冲&quot;&gt;&lt;a href=&quot;#深度缓冲&quot; class=&quot;headerlink&quot; title=&quot;深度缓冲&quot;&gt;&lt;/a&gt;深度缓冲&lt;/h1&gt;&lt;p&gt;由于画家算法的缺陷，我们常常在3D渲染中碰到错位的情况，因此引入深度缓冲来解决这样的问题。通过深度缓冲来存放场景中点距离照相
      
    
    </summary>
    
    
    
      <category term="Renderer" scheme="https://crunchybiscuits.github.io/tags/Renderer/"/>
    
  </entry>
  
  <entry>
    <title>渲染器的诞生(二)--三角光栅</title>
    <link href="https://crunchybiscuits.github.io/2021/02/13/%E4%B8%89%E8%A7%92%E5%85%89%E6%A0%85%E5%8C%96%E5%92%8C%E8%83%8C%E9%9D%A2%E5%89%94%E9%99%A4/"/>
    <id>https://crunchybiscuits.github.io/2021/02/13/%E4%B8%89%E8%A7%92%E5%85%89%E6%A0%85%E5%8C%96%E5%92%8C%E8%83%8C%E9%9D%A2%E5%89%94%E9%99%A4/</id>
    <published>2021-02-13T04:20:51.000Z</published>
    <updated>2021-02-16T13:58:45.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三角光栅化"><a href="#三角光栅化" class="headerlink" title="三角光栅化"></a>三角光栅化</h1><p>通过之前的Bresenham画线算法，最简单的方式便是通过三组两两点的直线算法来实现画出三角形</p><p>在三角形之间通过平行的扫描线进行渲染</p><p><strong>一个好的光栅化算法需要做到以下几点</strong></p><ul><li>简单快速</li><li>不会受到输入的数据顺序的影响</li><li>如果两个三角形有公共点，那么这两个三角形之间重合的部分不能有断点之类出现</li></ul><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>光栅化的过程，扫描线算法line sweeping：</p><ol><li>将三角形的点根据y的值按照升序进行排列</li><li>将三角形分成平顶和平底两部分</li><li>扫描线进行渲染</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triangle</span><span class="params">(Vec2i t0, Vec2i t1, Vec2i t2, TGAImage&amp; <span class="built_in">image</span>, TGAColor color)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这不是三角形哈哈哈哈哈哈哈哈</span></span><br><span class="line">    <span class="keyword">if</span> (t0.y == t1.y &amp;&amp; t0.y == t2.y)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将三个点进行降序排序</span></span><br><span class="line">    <span class="keyword">if</span> (t0.y &gt; t1.y)<span class="built_in">std</span>::swap(t0, t1);</span><br><span class="line">    <span class="keyword">if</span> (t0.y &gt; t2.y)<span class="built_in">std</span>::swap(t0, t2);</span><br><span class="line">    <span class="keyword">if</span> (t1.y &gt; t2.y)<span class="built_in">std</span>::swap(t1, t2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总的高度</span></span><br><span class="line">    <span class="keyword">int</span> total_height = t2.y - t1.y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并进行渲染</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total_height; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断是否到第二部分，或者开始三角形就是平底的</span></span><br><span class="line">        <span class="keyword">bool</span> second_half = i &gt; (t1.y - t0.y) || t1.y==t0.y;</span><br><span class="line">        <span class="keyword">int</span> segment_height = second_half ? t2.y - t1.y : t1.y - t0.y;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> alpha = (<span class="keyword">float</span>)i / total_height;</span><br><span class="line">        <span class="comment">// 如果是在第二部分，应当减去第一段的值</span></span><br><span class="line">        <span class="keyword">float</span> beta = (<span class="keyword">float</span>)(i - (second_half ? t1.y - t0.y : <span class="number">0</span>)) / segment_height;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行插值</span></span><br><span class="line">        Vec2i A = t0 + (t2 - t0) * alpha;</span><br><span class="line">        Vec2i B = second_half ? t1 + (t2 - t1) * beta : t0 + (t1 - t0) * beta;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查A，B位置</span></span><br><span class="line">        <span class="keyword">if</span> (A.x &gt; B.x)<span class="built_in">std</span>::swap(A, B);</span><br><span class="line">        <span class="comment">// 扫描</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = A.x; j &lt;= B.x; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从t0开始</span></span><br><span class="line">            <span class="built_in">image</span>.<span class="built_in">set</span>(j, t0.y + i, color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="包围盒和重心坐标"><a href="#包围盒和重心坐标" class="headerlink" title="包围盒和重心坐标"></a>包围盒和重心坐标</h1><h2 id="重心坐标"><a href="#重心坐标" class="headerlink" title="重心坐标"></a>重心坐标</h2><p>在2D坐标系中，给定三角形ABC，存在一点p，有系数u,v使得</p><p>P = (1-u-v) * P1 + u * P2 + v * P3</p><p>通过连立方程组我们可以得到</p><ul><li>w1 = 1 - w2 - w3</li><li>Px = w1 * P1x + w2 * P2x + w3 * P3x</li><li>Py = w1 * P1y + w2 * P2y + w3 * P3y</li></ul><p>进行变换得到</p><ul><li>w1 = 1 - w2 - w3</li><li>Px - P3x = w1 * (P1x - P3x) + w2 * (P2x - P3x)</li><li>Py - P3y = w1 * (P1y - P3y) + w2 * (P2y - P3y)</li></ul><p>令C = P-P3, A = P1-P3, B = P2-P3， 可得</p><ul><li>Cx = w1 * Ax + w2 * Bx</li><li>Cy = w1* Ay + w2 * By</li><li>w3 = 1 - w1 - w2</li></ul><p>最后解出方程组可得，三个解是与对应的三角形面积成比例的，因此可以先用叉乘计算三角形面积，再求面积的比值</p><h2 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h2><ul><li>首先查找包围盒</li><li>遍历包围盒中的点<ul><li>判断点是否在三角形中</li><li>对三角形内的点进行光栅化</li></ul></li></ul><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec3f <span class="title">barycentric</span><span class="params">(Vec2i *pts, Vec2i p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 叉乘计算面积比值</span></span><br><span class="line">    Vec3f u = cross(Vec3f(pts[<span class="number">2</span>][<span class="number">0</span>] - pts[<span class="number">0</span>][<span class="number">0</span>], pts[<span class="number">1</span>][<span class="number">0</span>] - pts[<span class="number">0</span>][<span class="number">0</span>], pts[<span class="number">0</span>][<span class="number">0</span>] - P[<span class="number">0</span>]), Vec3f(pts[<span class="number">2</span>][<span class="number">1</span>] - pts[<span class="number">0</span>][<span class="number">1</span>], pts[<span class="number">1</span>][<span class="number">1</span>] - pts[<span class="number">0</span>][<span class="number">1</span>], pts[<span class="number">0</span>][<span class="number">1</span>] - P[<span class="number">1</span>]));</span><br><span class="line">    <span class="comment">// 如果不是三角形，那么直接返回一个不合法的值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(u[<span class="number">2</span>]) &lt; <span class="number">1</span>) <span class="keyword">return</span> Vec3f(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 除u.z是为了归一</span></span><br><span class="line">    <span class="keyword">return</span> Vec3f(<span class="number">1.f</span> - (u.x + u.y) / u.z, u.y / u.z, u.x / u.z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triangle</span><span class="params">(Vec2i *pts, TGAImage&amp; <span class="built_in">image</span>, TGAColor color)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置包围盒</span></span><br><span class="line">    <span class="function">Vec2i <span class="title">bboxmin</span><span class="params">(<span class="built_in">image</span>.get_width()<span class="number">-1</span>, <span class="built_in">image</span>.get_height()<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="function">Vec2i <span class="title">bboxmax</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Vec2i <span class="title">clamp</span><span class="params">(<span class="built_in">image</span>.get_width() <span class="number">-1</span>, <span class="built_in">image</span>.get_height()<span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            bboxmin[j] = <span class="built_in">std</span>::<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">std</span>::<span class="built_in">min</span>(bboxmin[j], pts[i][j]));</span><br><span class="line">            bboxmax[j] = <span class="built_in">std</span>::<span class="built_in">min</span>(clamp[j], <span class="built_in">std</span>::<span class="built_in">max</span>(bboxmax[j], pts[i][j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;三角光栅化&quot;&gt;&lt;a href=&quot;#三角光栅化&quot; class=&quot;headerlink&quot; title=&quot;三角光栅化&quot;&gt;&lt;/a&gt;三角光栅化&lt;/h1&gt;&lt;p&gt;通过之前的Bresenham画线算法，最简单的方式便是通过三组两两点的直线算法来实现画出三角形&lt;/p&gt;
&lt;p&gt;在三角
      
    
    </summary>
    
    
    
      <category term="Renderer" scheme="https://crunchybiscuits.github.io/tags/Renderer/"/>
    
  </entry>
  
  <entry>
    <title>渲染器的诞生(一)--Bresenham直线算法</title>
    <link href="https://crunchybiscuits.github.io/2021/02/12/Bresenham%E7%9B%B4%E7%BA%BF%E7%AE%97%E6%B3%95/"/>
    <id>https://crunchybiscuits.github.io/2021/02/12/Bresenham%E7%9B%B4%E7%BA%BF%E7%AE%97%E6%B3%95/</id>
    <published>2021-02-12T04:33:42.000Z</published>
    <updated>2021-03-01T16:33:41.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bresenham-直线算法"><a href="#Bresenham-直线算法" class="headerlink" title="Bresenham 直线算法"></a>Bresenham 直线算法</h1><p>来自tinyrenderer的第一课，目标是能够画出网格</p><p>常见的画线算法除了Bresenham算法，还有数值微分法(每次运算都需要一个浮点乘法和舍入运算)和中点画线法</p><h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><p>在屏幕上直线是由一个像素一个像素小块儿组成的因此没法像现实世界中在纸张上那样直接连线，只是由于像素小块在屏幕上足够多，而看起来像直线。Bresenham算法主要目的便是处理画线。</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p><strong>这里先默认斜率在0-1之间，直线指向第一象限</strong></p><ol><li>假设斜率<strong>k</strong>在0-1之间<ol><li>在x的变化上，每一次都是递增1</li><li>y要么保持不变要么递增1</li><li>我们通过一个参数 <strong>d</strong>，d的范围也在0-1之间，通过这个参数来确定y的变化。</li></ol></li><li>d的初始值为0，每一次变化相应的增加直线的斜率值，即 d=d+k。<ol><li>当d&gt;1的时候就前去1，保证d始终在0-1之间变换。</li><li>若d&gt;=0.5，那么与垂直网格的交点更加接近，则取当前像素右上方的像素(x+1, y+1)</li><li>若d&lt;0.5，那么取(x+1, y)</li></ol></li></ol><h3 id="误差项的优化"><a href="#误差项的优化" class="headerlink" title="误差项的优化"></a>误差项的优化</h3><ol><li>由于d在与0.5比较，因此假设 <strong>e</strong> = d-0.5，那么每次只需判定e&gt;=0即可</li><li>但是上述的计算需要用到小数和除法的计算，为了方便硬件计算假设 <strong>e’</strong>=2*e*dx</li><li>最终化简得到误差项 <strong>p</strong> = 2dy-dx</li></ol><h3 id="扩展到所有情况"><a href="#扩展到所有情况" class="headerlink" title="扩展到所有情况"></a>扩展到所有情况</h3><p>刚才只讨论了斜率在0-1，指向第一象限的情况，那么扩展到所有情况便有，斜率&gt;1和在不同象限</p><ol><li>对于斜率的变化，在同一象限中是关于y=x对称的，因此将代码中x和y对调位置，例如p=2dy-dx就变成p=2dx-dy</li><li>对于不同象限则调整符号，使其转移到第一象限进行计算。例如, 对于第二象限 dx &lt; 0, dy &gt; 0, 那么就取其关于y轴对称的点 (-x1, y1) (-x2, y2)应用Bresenham算法计算, 但是最后输出的点仍然是 (x1, y1) 而不是 (-x1, y1)</li></ol><p><strong>所有情况汇总：</strong></p><p><strong>若dx &gt; 0, dy &gt; 0, 0&lt; m &lt; 1:</strong></p><p>xi = x1, yi = y1</p><p>第一项: pi = 2dy -dx</p><p>若pi &lt; 0: pi = pi + 2dy, yi = yi</p><p>若pi &gt; 0: pi = pi + 2dy - 2dx, yi = yi + 1</p><p>xi = xi + 1</p><p>输出: (xi, yi)</p><p><strong>若dx &gt; 0, dy &gt; 0, m &gt; 1:</strong></p><p>xi = x1, yi = y1</p><p>第一项: pi = 2dx -dy</p><p>若pi &lt; 0: pi = pi + 2dx, xi = xi</p><p>若pi &gt; 0: pi = pi + 2dx - 2dy, xi = xi + 1</p><p>yi = yi + 1</p><p>输出: (xi, yi)</p><p><strong>若dx &gt; 0, dy &lt; 0, 0&lt; m &lt; 1:</strong></p><p>xi = x1, yi = -y1</p><p>第一项: pi = 2dy -dx</p><p>若pi &lt; 0: pi = pi + 2dy, yi = yi</p><p>若pi &gt; 0: pi = pi + 2dy - 2dx, yi = yi + 1</p><p>xi = xi + 1</p><p>输出: (xi, -yi)</p><p><strong>若dx &gt; 0, dy &lt; 0, m &gt; 1:</strong></p><p>xi = x1, yi = -y1</p><p>第一项: pi = 2dx -dy</p><p>若pi &lt; 0: pi = pi + 2dx, xi = xi</p><p>若pi &gt; 0: pi = pi + 2dx - 2dy, xi = xi + 1</p><p>yi = yi + 1</p><p>输出: (xi, yi)</p><p><strong>若dx &lt; 0, dy &gt; 0, 0&lt; m &lt; 1:</strong></p><p>xi = -x1, yi = y1</p><p>第一项: pi = 2dy -dx</p><p>若pi &lt; 0: pi = pi + 2dy, yi = yi</p><p>若pi &gt; 0: pi = pi + 2dy - 2dx, yi = yi + 1</p><p>xi = xi + 1</p><p>输出: (-xi, yi)</p><p><strong>若dx &lt; 0, dy &gt; 0, m &gt; 1:</strong></p><p>xi = -x1, yi = y1</p><p>第一项: pi = 2dx -dy</p><p>若pi &lt; 0: pi = pi + 2dx, xi = xi</p><p>若pi &gt; 0: pi = pi + 2dx - 2dy, xi = xi + 1</p><p>yi = yi + 1</p><p>输出: (-xi, yi)</p><p><strong>若dx &lt; 0, dy &lt; 0, 0&lt; m &lt; 1:</strong></p><p>xi = -x1, yi = -y1</p><p>第一项: pi = 2dy -dx</p><p>若pi &lt; 0: pi = pi + 2dy, yi = yi</p><p>若pi &gt; 0: pi = pi + 2dy - 2dx, yi = yi + 1</p><p>xi = xi + 1</p><p>输出: (-xi, -yi)</p><p><strong>若dx &lt; 0, dy &lt; 0, m &gt; 1:</strong></p><p>xi = -x1, yi = -y1</p><p>第一项: pi = 2dx -dy</p><p>若pi &lt; 0: pi = pi + 2dx, xi = xi</p><p>若pi &gt; 0: pi = pi + 2dx - 2dy, xi = xi + 1</p><p>yi = yi + 1</p><p>输出: (-xi, -yi)</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">line</span><span class="params">(Vec2i p0, Vec2i p1, TGAImage&amp; <span class="built_in">image</span>, TGAColor color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> steep = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 判断斜率&gt;1还是在0到1之间</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(p0.x - p1.x) &lt; <span class="built_in">std</span>::<span class="built_in">abs</span>(p0.y - p1.y))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(p0.x, p0.y);</span><br><span class="line">        <span class="built_in">std</span>::swap(p1.x, p1.y);</span><br><span class="line">        steep = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p0.x &gt; p1.x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(p0.x, p1.x);</span><br><span class="line">        <span class="built_in">std</span>::swap(p0.y, p1.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dx = p1.x - p0.x;</span><br><span class="line">    <span class="keyword">int</span> dy = p1.y - p0.y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化后的误差项</span></span><br><span class="line">    <span class="comment">// 将误差项变成e*2*dx</span></span><br><span class="line">    <span class="keyword">float</span> derror = <span class="built_in">std</span>::<span class="built_in">abs</span>(dy)*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">float</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> y = p0.y;</span><br><span class="line">    <span class="comment">// 优化判断的计算</span></span><br><span class="line">    <span class="keyword">if</span> (steep)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = p0.x; x &lt;= p1.x; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 斜率&gt;1结果需交换x和y</span></span><br><span class="line">            <span class="built_in">image</span>.<span class="built_in">set</span>(y, x, color);</span><br><span class="line">            error += derror;</span><br><span class="line">            <span class="keyword">if</span> (error &gt; dx)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 根据上升还是下降对y进行取值</span></span><br><span class="line">                y += (p1.y &gt; p0.y ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">                error -= dx * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = p0.x; x &lt;= p1.x; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">image</span>.<span class="built_in">set</span>(x, y, color);</span><br><span class="line">            error += derror;</span><br><span class="line">            <span class="keyword">if</span> (error &gt; dx)</span><br><span class="line">            &#123;</span><br><span class="line">                y += (p1.y &gt; p0.y ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">                error -= dx*<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Bresenham-直线算法&quot;&gt;&lt;a href=&quot;#Bresenham-直线算法&quot; class=&quot;headerlink&quot; title=&quot;Bresenham 直线算法&quot;&gt;&lt;/a&gt;Bresenham 直线算法&lt;/h1&gt;&lt;p&gt;来自tinyrenderer的第一课，目标是
      
    
    </summary>
    
    
    
      <category term="Renderer" scheme="https://crunchybiscuits.github.io/tags/Renderer/"/>
    
  </entry>
  
  <entry>
    <title>GAMES101Assignment4</title>
    <link href="https://crunchybiscuits.github.io/2020/12/21/GAMES101Assignment4/"/>
    <id>https://crunchybiscuits.github.io/2020/12/21/GAMES101Assignment4/</id>
    <published>2020-12-21T01:03:19.000Z</published>
    <updated>2021-03-01T16:32:47.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GAMES101-Assignment4-对应Lecture10-11"><a href="#GAMES101-Assignment4-对应Lecture10-11" class="headerlink" title="GAMES101 Assignment4 (对应Lecture10-11)"></a>GAMES101 Assignment4 (对应Lecture10-11)</h1><p>课程作业框架来自<a href="http://games-cn.org/forums/topic/allhw/">GAMES</a></p><h2 id="基础部分："><a href="#基础部分：" class="headerlink" title="基础部分："></a>基础部分：</h2><p>目标要求：需要实现de Casteljau 算法来绘制由4 个控制点表示的Bézier 曲线</p><p><strong>main.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    贝塞尔递归</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function">cv::Point2f <span class="title">recursive_bezier</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Point2f&gt; &amp;control_points, <span class="keyword">float</span> t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Implement de Casteljau&#x27;s algorithm</span></span><br><span class="line">    <span class="keyword">int</span> control_points_num = control_points.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (control_points_num == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">cv::Point2f <span class="title">pix_center_point</span><span class="params">(<span class="number">0.5</span>,<span class="number">0.5</span>)</span></span>;</span><br><span class="line">        pix_center_point += (cv::Point2f) control_points[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> pix_center_point;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cv::Point2d left_bezier_point, right_bezier_point;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Point2f&gt; <span class="title">left_control_points</span><span class="params">(&amp;(control_points[<span class="number">0</span>]), &amp;(control_points[control_points_num - <span class="number">1</span>]))</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Point2f&gt; <span class="title">right_control_points</span><span class="params">(&amp;(control_points[<span class="number">1</span>]), &amp;(control_points[control_points_num]))</span></span>;</span><br><span class="line">        left_bezier_point = recursive_bezier(left_control_points, t);</span><br><span class="line">        right_bezier_point = recursive_bezier(right_control_points, t);</span><br><span class="line">        <span class="keyword">return</span> left_bezier_point * (<span class="number">1</span>-t) + right_bezier_point*t;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bezier</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Point2f&gt; &amp;control_points, cv::Mat &amp;window)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Iterate through all t = 0 to t = 1 with small steps, and call de Casteljau&#x27;s </span></span><br><span class="line">    <span class="comment">// recursive Bezier algorithm.</span></span><br><span class="line">    <span class="keyword">static</span> cv::Point2f <span class="built_in">point</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> t = <span class="number">0.0</span>; t &lt;= <span class="number">1.0</span>; t+=<span class="number">0.005</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">point</span> = recursive_bezier(control_points, t);</span><br><span class="line">        window.at&lt;cv::Vec3b&gt;(<span class="built_in">point</span>.y, <span class="built_in">point</span>.x)[<span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GAMES101-Assignment4-对应Lecture10-11&quot;&gt;&lt;a href=&quot;#GAMES101-Assignment4-对应Lecture10-11&quot; class=&quot;headerlink&quot; title=&quot;GAMES101 Assignment4 (
      
    
    </summary>
    
    
    
      <category term="GAMES101" scheme="https://crunchybiscuits.github.io/tags/GAMES101/"/>
    
  </entry>
  
  <entry>
    <title>GAMES101Assignment3</title>
    <link href="https://crunchybiscuits.github.io/2020/12/20/GAMES101Assignment3/"/>
    <id>https://crunchybiscuits.github.io/2020/12/20/GAMES101Assignment3/</id>
    <published>2020-12-20T02:10:45.000Z</published>
    <updated>2021-03-01T16:32:40.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GAMES101-Assignment3-对应Lecture7-9"><a href="#GAMES101-Assignment3-对应Lecture7-9" class="headerlink" title="GAMES101 Assignment3 (对应Lecture7-9)"></a>GAMES101 Assignment3 (对应Lecture7-9)</h1><p>课程作业框架来自<a href="http://games-cn.org/forums/topic/allhw/">GAMES</a></p><h2 id="基础部分："><a href="#基础部分：" class="headerlink" title="基础部分："></a>基础部分：</h2><p>目标要求：实现与作业2 类似的插值算法，实现法向量、颜色、纹理颜色的插值。</p><p><strong>Rasterizer.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 在三角形内检测函数</span></span><br><span class="line"><span class="comment">* parameters:</span></span><br><span class="line"><span class="comment">*        point:x,y</span></span><br><span class="line"><span class="comment">*        triangle:_v</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">insideTriangle</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// TODO : Implement this function to check if the point (x, y) is inside the triangle represented by _v[0], _v[1], _v[2]</span></span><br><span class="line">    <span class="comment">// float xp = x, yp = y;</span></span><br><span class="line">    <span class="comment">// float xa = _v[0].x(), ya = _v[0].y();</span></span><br><span class="line">    <span class="comment">// float xb = _v[1].x(), yb = _v[1].y();</span></span><br><span class="line">    <span class="comment">// float xc = _v[2].x(), yc = _v[2].y();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// float gamma = ((xb-xa)*(yp-ya)-(xp-xa)*(yb-ya))/((xb-xa)*(yc-ya)-(xc-xa)*(yb-ya));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// float beta = (xp-xa-gamma*(xc-xa))/(xb-xa);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// float alpha = 1.0f - gamma - beta;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// return alpha&gt;0 &amp;&amp; alpha&lt;1; </span></span><br><span class="line"></span><br><span class="line">    <span class="function">Vector3f <span class="title">P</span><span class="params">(x,y,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ((_v[<span class="number">0</span>]-_v[<span class="number">1</span>]).cross(P-_v[<span class="number">1</span>]).z()&lt;<span class="number">0</span>&amp;&amp;</span><br><span class="line">            (_v[<span class="number">2</span>]-_v[<span class="number">0</span>]).cross(P-_v[<span class="number">0</span>]).z()&lt;<span class="number">0</span>&amp;&amp;</span><br><span class="line">            (_v[<span class="number">1</span>]-_v[<span class="number">2</span>]).cross(P-_v[<span class="number">2</span>]).z()&lt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Screen space rasterization</span></span><br><span class="line"><span class="comment">//此版本为使用MSAA版本，如不使用直接使用insideTriangle函数同时判断z-buffer即可</span></span><br><span class="line"><span class="keyword">void</span> rst::rasterizer::rasterize_triangle(<span class="keyword">const</span> Triangle&amp; t) &#123;</span><br><span class="line">    <span class="keyword">auto</span> v = t.toVector4();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// TODO : Find out the bounding box of current triangle.</span></span><br><span class="line">    <span class="comment">// iterate through the pixel and find if the current pixel is inside the triangle</span></span><br><span class="line">    <span class="keyword">int</span> left_bound = <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">0</span>].x(), <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">1</span>].x(), v[<span class="number">2</span>].x()));</span><br><span class="line">    <span class="keyword">int</span> right_bound = <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">0</span>].x(), <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">1</span>].x(), v[<span class="number">2</span>].x()));</span><br><span class="line">    <span class="keyword">int</span> bottom_bound = <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">0</span>].y(), <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">1</span>].y(), v[<span class="number">2</span>].y()));</span><br><span class="line">    <span class="keyword">int</span> up_bound = <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">0</span>].y(), <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">1</span>].y(), v[<span class="number">2</span>].y()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If so, use the following code to get the interpolated z value.</span></span><br><span class="line">    <span class="comment">//auto[alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);</span></span><br><span class="line">    <span class="comment">//float w_reciprocal = 1.0/(alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());</span></span><br><span class="line">    <span class="comment">//float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();</span></span><br><span class="line">    <span class="comment">//z_interpolated *= w_reciprocal;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO : set the current pixel (use the set_pixel function) to the color of the triangle (use getColor function) if it should be painted.</span></span><br><span class="line">    </span><br><span class="line">    Eigen::Vector3f p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = left_bound;x&lt;=right_bound;x++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = bottom_bound; y &lt;= up_bound; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用MSAA</span></span><br><span class="line">            <span class="keyword">float</span> percent = insideTrianglePercent(x,y,t.v,<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">if</span> (percent&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">//Depth interpolated</span></span><br><span class="line">            <span class="keyword">auto</span>[alpha, beta, gamma] = computeBarycentric2D(i+<span class="number">0.5</span>, j+<span class="number">0.5</span>, t.v);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> Z = <span class="number">1.0</span> / (alpha / v[<span class="number">0</span>].w() + beta / v[<span class="number">1</span>].w() + gamma / v[<span class="number">2</span>].w());</span><br><span class="line">            <span class="keyword">float</span> zp = alpha * v[<span class="number">0</span>].z() / v[<span class="number">0</span>].w() + beta * v[<span class="number">1</span>].z() / v[<span class="number">1</span>].w() + gamma * v[<span class="number">2</span>].z() / v[<span class="number">2</span>].w();</span><br><span class="line">            zp*=Z;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(zp &lt; depth_buf[get_index(i,j)])</span><br><span class="line">            &#123;</span><br><span class="line">                depth_buf[get_index(i,j)] = zp;</span><br><span class="line">                <span class="keyword">auto</span> interpolated_color = interpolate(alpha, beta, gamma, t.color[<span class="number">0</span>], t.color[<span class="number">1</span>], t.color[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> interpolated_normal = interpolate(alpha, beta, gamma,t.normal[<span class="number">0</span>],t.normal[<span class="number">1</span>],t.normal[<span class="number">2</span>],<span class="number">1</span>).normalized();</span><br><span class="line">                <span class="keyword">auto</span> interpolated_texcoords = interpolate(alpha, beta, gamma,t.tex_coords[<span class="number">0</span>],t.tex_coords[<span class="number">1</span>],t.tex_coords[<span class="number">2</span>],<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> interpolated_shadingcoords = interpolate(alpha, beta, gamma,view_pos[<span class="number">0</span>],view_pos[<span class="number">1</span>],view_pos[<span class="number">2</span>],<span class="number">1</span>);</span><br><span class="line">                <span class="function">fragment_shader_payload <span class="title">payload</span><span class="params">(interpolated_color,interpolated_normal,interpolated_texcoords,texture ? &amp;*texture : <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">                payload.view_pos = interpolated_shadingcoords;</span><br><span class="line">                <span class="keyword">auto</span> pixel_color = fragment_shader(payload);</span><br><span class="line">                set_pixel(Eigen::Vector2i(i,j),pixel_color);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GAMES101-Assignment3-对应Lecture7-9&quot;&gt;&lt;a href=&quot;#GAMES101-Assignment3-对应Lecture7-9&quot; class=&quot;headerlink&quot; title=&quot;GAMES101 Assignment3 (对应Le
      
    
    </summary>
    
    
    
      <category term="GAMES101" scheme="https://crunchybiscuits.github.io/tags/GAMES101/"/>
    
  </entry>
  
  <entry>
    <title>GAMES101Assignment2</title>
    <link href="https://crunchybiscuits.github.io/2020/12/18/GAMES101Assignment2/"/>
    <id>https://crunchybiscuits.github.io/2020/12/18/GAMES101Assignment2/</id>
    <published>2020-12-18T01:59:39.000Z</published>
    <updated>2021-03-01T16:32:34.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GAMES101-Assignment2-对应Lecture5-6"><a href="#GAMES101-Assignment2-对应Lecture5-6" class="headerlink" title="GAMES101 Assignment2 (对应Lecture5-6)"></a>GAMES101 Assignment2 (对应Lecture5-6)</h1><p>课程作业框架来自<a href="http://games-cn.org/forums/topic/allhw/">GAMES</a></p><h2 id="基础部分："><a href="#基础部分：" class="headerlink" title="基础部分："></a>基础部分：</h2><p>目标要求：正确实现三角形得栅格化算法，测试点是否在三角形内，正确实现z-buffer算法</p><p><strong>Rasterizer.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 在三角形内检测函数</span></span><br><span class="line"><span class="comment">* parameters:</span></span><br><span class="line"><span class="comment">*        point:x,y</span></span><br><span class="line"><span class="comment">*        triangle:_v</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">insideTriangle</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// TODO : Implement this function to check if the point (x, y) is inside the triangle represented by _v[0], _v[1], _v[2]</span></span><br><span class="line">    <span class="comment">// float xp = x, yp = y;</span></span><br><span class="line">    <span class="comment">// float xa = _v[0].x(), ya = _v[0].y();</span></span><br><span class="line">    <span class="comment">// float xb = _v[1].x(), yb = _v[1].y();</span></span><br><span class="line">    <span class="comment">// float xc = _v[2].x(), yc = _v[2].y();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// float gamma = ((xb-xa)*(yp-ya)-(xp-xa)*(yb-ya))/((xb-xa)*(yc-ya)-(xc-xa)*(yb-ya));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// float beta = (xp-xa-gamma*(xc-xa))/(xb-xa);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// float alpha = 1.0f - gamma - beta;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// return alpha&gt;0 &amp;&amp; alpha&lt;1; </span></span><br><span class="line"></span><br><span class="line">    <span class="function">Vector3f <span class="title">P</span><span class="params">(x,y,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ((_v[<span class="number">0</span>]-_v[<span class="number">1</span>]).cross(P-_v[<span class="number">1</span>]).z()&lt;<span class="number">0</span>&amp;&amp;</span><br><span class="line">            (_v[<span class="number">2</span>]-_v[<span class="number">0</span>]).cross(P-_v[<span class="number">0</span>]).z()&lt;<span class="number">0</span>&amp;&amp;</span><br><span class="line">            (_v[<span class="number">1</span>]-_v[<span class="number">2</span>]).cross(P-_v[<span class="number">2</span>]).z()&lt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Screen space rasterization</span></span><br><span class="line"><span class="comment">//此版本为使用MSAA版本，如不使用直接使用insideTriangle函数同时判断z-buffer即可</span></span><br><span class="line"><span class="keyword">void</span> rst::rasterizer::rasterize_triangle(<span class="keyword">const</span> Triangle&amp; t) &#123;</span><br><span class="line">    <span class="keyword">auto</span> v = t.toVector4();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// TODO : Find out the bounding box of current triangle.</span></span><br><span class="line">    <span class="comment">// iterate through the pixel and find if the current pixel is inside the triangle</span></span><br><span class="line">    <span class="keyword">int</span> left_bound = <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">0</span>].x(), <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">1</span>].x(), v[<span class="number">2</span>].x()));</span><br><span class="line">    <span class="keyword">int</span> right_bound = <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">0</span>].x(), <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">1</span>].x(), v[<span class="number">2</span>].x()));</span><br><span class="line">    <span class="keyword">int</span> bottom_bound = <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">0</span>].y(), <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">1</span>].y(), v[<span class="number">2</span>].y()));</span><br><span class="line">    <span class="keyword">int</span> up_bound = <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">0</span>].y(), <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">1</span>].y(), v[<span class="number">2</span>].y()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If so, use the following code to get the interpolated z value.</span></span><br><span class="line">    <span class="comment">//auto[alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);</span></span><br><span class="line">    <span class="comment">//float w_reciprocal = 1.0/(alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());</span></span><br><span class="line">    <span class="comment">//float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();</span></span><br><span class="line">    <span class="comment">//z_interpolated *= w_reciprocal;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO : set the current pixel (use the set_pixel function) to the color of the triangle (use getColor function) if it should be painted.</span></span><br><span class="line">    </span><br><span class="line">    Eigen::Vector3f p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = left_bound;x&lt;=right_bound;x++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = bottom_bound; y &lt;= up_bound; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用MSAA</span></span><br><span class="line">            <span class="keyword">float</span> percent = insideTrianglePercent(x,y,t.v,<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">if</span> (percent&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span>[alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);</span><br><span class="line">                <span class="keyword">float</span> w_reciprocal = <span class="number">1.0</span>/(alpha / v[<span class="number">0</span>].w() + beta / v[<span class="number">1</span>].w() + gamma / v[<span class="number">2</span>].w());</span><br><span class="line">                <span class="keyword">float</span> z_interpolated = alpha * v[<span class="number">0</span>].z() / v[<span class="number">0</span>].w() + beta * v[<span class="number">1</span>].z() / v[<span class="number">1</span>].w() + gamma * v[<span class="number">2</span>].z() / v[<span class="number">2</span>].w();</span><br><span class="line">                z_interpolated *= w_reciprocal;</span><br><span class="line"></span><br><span class="line">                p.x() = x;</span><br><span class="line">                p.y() = y;</span><br><span class="line">                <span class="keyword">if</span>(z_interpolated &lt; depth_buf[get_index(x,y)])&#123;</span><br><span class="line">                    set_pixel(p,t.getColor(),percent);</span><br><span class="line">                    depth_buf[get_index(x,y)] = z_interpolated;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提高部分："><a href="#提高部分：" class="headerlink" title="提高部分："></a>提高部分：</h2><p>目标要求：实现super-sampling处理反走样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 指定每个像素使用多少个采样点</span></span><br><span class="line"><span class="comment">* parameters:</span></span><br><span class="line"><span class="comment">*    place: x,y</span></span><br><span class="line"><span class="comment">*    vector: _v</span></span><br><span class="line"><span class="comment">*    density: num of sampling</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">insideTrianglePercent</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">const</span> Vector3f* _v, <span class="keyword">int</span> density)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> percent = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> <span class="built_in">step</span> = <span class="built_in">sqrt</span>(density);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算每个采样点的位置参数</span></span><br><span class="line">    <span class="keyword">float</span> fragment_spacing = <span class="number">1.0</span>/<span class="built_in">step</span>;</span><br><span class="line">    <span class="keyword">float</span> margin = fragment_spacing/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">float</span> weight = <span class="number">1.0</span>/density;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">step</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">step</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            percent += insideTriangle(x+margin+fragment_spacing*i,</span><br><span class="line">                        y+margin+fragment_spacing*j,_v)*weight;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> percent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GAMES101-Assignment2-对应Lecture5-6&quot;&gt;&lt;a href=&quot;#GAMES101-Assignment2-对应Lecture5-6&quot; class=&quot;headerlink&quot; title=&quot;GAMES101 Assignment2 (对应Le
      
    
    </summary>
    
    
    
      <category term="GAMES101" scheme="https://crunchybiscuits.github.io/tags/GAMES101/"/>
    
  </entry>
  
  <entry>
    <title>GAMES101 Assignment1</title>
    <link href="https://crunchybiscuits.github.io/2020/12/11/GAMES101Assignment1/"/>
    <id>https://crunchybiscuits.github.io/2020/12/11/GAMES101Assignment1/</id>
    <published>2020-12-11T02:25:28.000Z</published>
    <updated>2021-03-01T16:32:26.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GAMES101-Assignment1-对应Lecture3-4"><a href="#GAMES101-Assignment1-对应Lecture3-4" class="headerlink" title="GAMES101 Assignment1 (对应Lecture3-4)"></a>GAMES101 Assignment1 (对应Lecture3-4)</h1><p>课程作业框架来自<a href="http://games-cn.org/forums/topic/allhw/">GAMES</a></p><h2 id="基础部分："><a href="#基础部分：" class="headerlink" title="基础部分："></a>基础部分：</h2><p>目标要求：需要完成一个旋转矩阵和一个透视投影矩阵，根据给定的三维坐标在屏幕上绘制相应的三角形。</p><p><strong>main.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 绕Z轴旋转矩阵</span></span><br><span class="line"><span class="comment">*    return model</span></span><br><span class="line"><span class="comment">*    parameters:</span></span><br><span class="line"><span class="comment">*        rotation_angle:旋转角度</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function">Eigen::Matrix4f <span class="title">get_model_matrix</span><span class="params">(<span class="keyword">float</span> rotation_angle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Eigen::Matrix4f model = Eigen::Matrix4f::Identity();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Implement this function</span></span><br><span class="line">    <span class="comment">// Create the model matrix for rotating the triangle around the Z axis.</span></span><br><span class="line">    <span class="comment">// Then return it.</span></span><br><span class="line">    <span class="comment">// 框架提供的转为弧度制函数</span></span><br><span class="line">    <span class="keyword">float</span> angle = radian(rotation_angle);</span><br><span class="line">    <span class="keyword">float</span> cos_angle = <span class="built_in">cos</span>(angle);</span><br><span class="line">    <span class="keyword">float</span> sin_angle = <span class="built_in">sin</span>(angle); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 旋转矩阵</span></span><br><span class="line">    Eigen::Matrix4f rotation_matrix;</span><br><span class="line">    rotation_matrix&lt;&lt;cos_angle,-sin_angle,<span class="number">0</span>,<span class="number">0</span>,sin_angle,cos_angle,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>;</span><br><span class="line">    model = rotation_matrix * model;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  透视投影矩阵</span></span><br><span class="line"><span class="comment">*    return Eigen::Matrix4f projection</span></span><br><span class="line"><span class="comment">*    parameters</span></span><br><span class="line"><span class="comment">*        eye_fov: 垂直可视度</span></span><br><span class="line"><span class="comment">*        aspect_ratio: width/height</span></span><br><span class="line"><span class="comment">*        zNear&gt;0, zFar&gt;0</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function">Eigen::Matrix4f <span class="title">get_projection_matrix</span><span class="params">(<span class="keyword">float</span> eye_fov, <span class="keyword">float</span> aspect_ratio,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">float</span> zNear, <span class="keyword">float</span> zFar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Students will implement this function</span></span><br><span class="line">    <span class="comment">// 默认单位矩阵</span></span><br><span class="line">    Eigen::Matrix4f projection = Eigen::Matrix4f::Identity();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Implement this function</span></span><br><span class="line">    <span class="comment">// Create the projection matrix for the given parameters.</span></span><br><span class="line">    <span class="comment">// Then return it.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> half_height = <span class="built_in">tan</span>(eye_fov/<span class="number">2</span>*MY_PI/<span class="number">180</span>)*zNear;</span><br><span class="line">    <span class="keyword">float</span> half_width = aspect_ratio*half_height;</span><br><span class="line">    <span class="comment">// 透视范围顶部</span></span><br><span class="line">    <span class="keyword">float</span> t = half_height;</span><br><span class="line">    <span class="comment">// 透视范围右侧</span></span><br><span class="line">    <span class="keyword">float</span> r = half_width;</span><br><span class="line">    <span class="comment">// 透视范围底部</span></span><br><span class="line">    <span class="keyword">float</span> b = -half_height;</span><br><span class="line">    <span class="comment">// 透视范围左侧</span></span><br><span class="line">    <span class="keyword">float</span> l = -half_width;</span><br><span class="line">    <span class="comment">// 近端, 因为是z轴负方向</span></span><br><span class="line">    <span class="keyword">float</span> n = -zNear;</span><br><span class="line">    <span class="comment">// 远端</span></span><br><span class="line">    <span class="keyword">float</span> f = -zFar;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 变换透视投影的方式是将透视投影转变成正交投影</span></span><br><span class="line">    Eigen::Matrix4f S,T,M;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 缩放成canonical</span></span><br><span class="line">    S&lt;&lt;</span><br><span class="line">    <span class="number">2</span>/(r-l),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">2</span>/(t-b),<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>/(n-f),<span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正交投影的平移矩阵，平移到原点</span></span><br><span class="line">    T&lt;&lt;</span><br><span class="line">    <span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,-(l+r)/<span class="number">2</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-(b+t)/<span class="number">2</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-(n+f)/<span class="number">2</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 透视投影转正交投影</span></span><br><span class="line">    M&lt;&lt;</span><br><span class="line">    zNear,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,zNear,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,zNear+zFar,-zFar*zNear,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    projection = S * T * M * projection;</span><br><span class="line">    <span class="keyword">return</span> projection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提高部分："><a href="#提高部分：" class="headerlink" title="提高部分："></a>提高部分：</h2><p>目标要求：在main.cpp实现一个函数完成绕任意过原点轴的旋转变换矩阵</p><p>绕任意轴旋转函数(<strong>罗德里格斯公式</strong>)</p><p>绕n轴旋转α角度</p><p><strong>R(n,α) = cos(α) * I + (1 - cos(α)) * n * n_transpose + sin(α) * N；其中I为单位矩阵，N为n的反对称阵</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">*绕axis轴旋转rotation_angle</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function">Eigen::Matrix4f <span class="title">get_rotation</span><span class="params">(Vector3f axis, <span class="keyword">float</span> rotation_angle)</span></span>&#123;</span><br><span class="line">    Eigen::Matrix4f model = Eigen::Matrix4f::Identity();</span><br><span class="line">    <span class="keyword">float</span> angle = radian(rotation_angle);</span><br><span class="line">    </span><br><span class="line">    Eigen::Matrix3f I = Eigen::Matrix3f::Identity();</span><br><span class="line">    <span class="comment">// n的反对称阵</span></span><br><span class="line">    Eigen::Matrix3f N;</span><br><span class="line">    N&lt;&lt;</span><br><span class="line">         <span class="number">0</span>, -axis.z(), axis.y(),</span><br><span class="line">        axis.z(), <span class="number">0</span>, -axis.x(),</span><br><span class="line">        -axis.y(), axis.x(), <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 罗德里格斯</span></span><br><span class="line">    Eigen::Matrix3f rotation_matrix = <span class="built_in">cos</span>(angle) * I + (<span class="number">1</span>-<span class="built_in">cos</span>(angle)) * axis * axis.transpose() + <span class="built_in">sin</span>(angle) * N;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将3*3变成4*4</span></span><br><span class="line">    model.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>,<span class="number">0</span>) = rotation_matrix;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> model.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里main.cpp的main函数中两个位置的set_model切换为使用get_rotation函数，并自己设定axis</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GAMES101-Assignment1-对应Lecture3-4&quot;&gt;&lt;a href=&quot;#GAMES101-Assignment1-对应Lecture3-4&quot; class=&quot;headerlink&quot; title=&quot;GAMES101 Assignment1 (对应Le
      
    
    </summary>
    
    
    
      <category term="GAMES101" scheme="https://crunchybiscuits.github.io/tags/GAMES101/"/>
    
  </entry>
  
  <entry>
    <title>shader入门-(线性代数)</title>
    <link href="https://crunchybiscuits.github.io/2020/09/19/shader%E5%85%A5%E9%97%A8-(%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0)/"/>
    <id>https://crunchybiscuits.github.io/2020/09/19/shader%E5%85%A5%E9%97%A8-(%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0)/</id>
    <published>2020-09-19T01:36:59.000Z</published>
    <updated>2020-12-17T04:07:48.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shader基础数学"><a href="#Shader基础数学" class="headerlink" title="Shader基础数学"></a>Shader基础数学</h1><p>仅用作个人的常用提示，不会有全部详细介绍，资料来自《Unity Shader入门精要》</p><h1 id="笛卡尔坐标系"><a href="#笛卡尔坐标系" class="headerlink" title="笛卡尔坐标系"></a>笛卡尔坐标系</h1><h3 id="笛卡尔坐标系-1"><a href="#笛卡尔坐标系-1" class="headerlink" title="笛卡尔坐标系"></a>笛卡尔坐标系</h3><ul><li><p>构成</p><ul><li><p>原点</p></li><li><p>N条过原点，相互垂直的坐标轴，主要看是几维</p></li></ul></li></ul><p><strong>OpenGL和DirectX使用的笛卡尔坐标系不同</strong></p><p>坐标轴又称作，<strong>基矢量</strong></p><p>长度为1，的基矢量 — <strong>标准正交基</strong></p><p>四维空间 — <strong>齐次坐标系</strong></p><hr><h2 id="左-右手坐标系"><a href="#左-右手坐标系" class="headerlink" title="左/右手坐标系"></a>左/右手坐标系</h2><p> 三维的笛卡尔坐标系并不都是等价的，如果有相同<strong>旋向性</strong>，就可以通过旋转方法来让两个坐标系重合，但是如果旋向性不同，就不能重合。</p><p>在Unity中</p><ul><li><strong>模型空间</strong>和<strong>世界空间</strong>使用了<strong>左手坐标系</strong></li><li><strong>观察空间</strong>使用了<strong>右手坐标系</strong></li></ul><hr><h1 id="点和矢量"><a href="#点和矢量" class="headerlink" title="点和矢量"></a>点和矢量</h1><p>点 – 空间中的一个位置</p><p>矢量/向量 – 包含<strong>模</strong>和<strong>方向</strong>的有向线段， 通常用来表示相对于某个点的偏移，只要模和方向不变，放哪儿都一样</p><h2 id="矢量运算"><a href="#矢量运算" class="headerlink" title="矢量运算"></a>矢量运算</h2><h3 id="点积-—-结果是标量"><a href="#点积-—-结果是标量" class="headerlink" title="点积 — 结果是标量"></a>点积 — 结果是标量</h3><p><strong>a</strong> · <strong>b</strong> = (ax,ay,az) · (bx,by,bz) = axbx + ayby + azbz </p><p><strong>a</strong> · <strong>b</strong> = |<strong>a</strong>||<strong>b</strong>|cosθ </p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul><li><p><strong>a</strong> · <strong>b</strong> = <strong>b</strong> · <strong>a</strong></p></li><li><p>k<strong>a</strong> · <strong>b</strong> = <strong>a</strong> · k<strong>b</strong> </p></li><li><p><strong>a</strong> · (<strong>b</strong> + <strong>c</strong>) = <strong>a</strong> · <strong>b</strong> + <strong>a</strong> · <strong>c</strong>  </p></li><li><p><strong>a</strong> · <strong>a</strong> = |<strong>a</strong>|^2</p></li><li><p>几何意义 — 投影</p></li></ul><h3 id="叉积-—-结果是矢量"><a href="#叉积-—-结果是矢量" class="headerlink" title="叉积 — 结果是矢量"></a>叉积 — 结果是矢量</h3><p><strong>a</strong> X <strong>b</strong> = (ax,ay,az) X (bx,by,bz) = (aybz - azby, azbx - axbz, axby - aybx)</p><p><strong>a</strong> X <strong>b</strong> = |<strong>a</strong>||<strong>b</strong>|sinθ </p><h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><ul><li><strong>a</strong> X <strong>b</strong> ！= <strong>b</strong> X <strong>a</strong></li><li><strong>a</strong> X <strong>b</strong> = - (<strong>b</strong> X <strong>a</strong>)</li></ul><p><strong>a</strong> X <strong>b</strong> 方向的确认，先判断是左手还是右手坐标系，接着</p><hr><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p><strong>对角元素</strong> – 行号和列号相同的元素</p><p><strong>转置矩阵</strong> – r X c 变成 c X r   </p><p>行列式不为0，既是可逆</p><p><strong>正交矩阵</strong> – 矩阵和它转置矩阵的乘积是单位矩阵</p><ul><li>矩阵的每一行，即c1、c2 和c3 是单位矢量，因为只有这样它们与自己的点积才能是1；</li><li>矩阵的每一行，即c1、c2 和c3 之间互相垂直，因为只有这样它们之间的点积才能是0。</li><li>上述两条结论对矩阵的每一列同样适用，因为如果M是正交矩阵的话，MT 也会是正交矩阵。</li></ul><h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><p>线性 – 缩放，旋转，错切，镜像，正交投影</p><p>三维到四维的变化</p><ul><li><p>点 — 添加 1</p></li><li><p>矢量 — 添加 0</p></li></ul><h1 id="基础变换矩阵分解"><a href="#基础变换矩阵分解" class="headerlink" title="基础变换矩阵分解"></a>基础变换矩阵分解</h1><p>一个基础变换矩阵可以分解成4部分</p><p><img src= "/img/loading.gif" data-lazy-src="/img/shader1.jpg" alt=""></p><p>左上角矩阵<strong>M</strong>用于表示旋转和缩放，<strong>t</strong>用来表示平移，<strong>0</strong>表示零矩阵，右下角元素就是标量1</p><p>Unity中旋转顺序是ZXY</p><p>绕坐标系E 下的z 轴旋转z，绕坐标系E 下的y 轴旋转y，绕坐标系E 下的x 轴旋转x，即进行一次旋转时不一起旋转当前坐标系。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Shader基础数学&quot;&gt;&lt;a href=&quot;#Shader基础数学&quot; class=&quot;headerlink&quot; title=&quot;Shader基础数学&quot;&gt;&lt;/a&gt;Shader基础数学&lt;/h1&gt;&lt;p&gt;仅用作个人的常用提示，不会有全部详细介绍，资料来自《Unity Shader
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>链表练习中未注意的点</title>
    <link href="https://crunchybiscuits.github.io/2020/08/19/%E9%93%BE%E8%A1%A8%E7%BB%83%E4%B9%A0%E4%B8%AD%E6%9C%AA%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/"/>
    <id>https://crunchybiscuits.github.io/2020/08/19/%E9%93%BE%E8%A1%A8%E7%BB%83%E4%B9%A0%E4%B8%AD%E6%9C%AA%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/</id>
    <published>2020-08-19T04:19:31.000Z</published>
    <updated>2021-02-18T16:40:54.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="特定深度节点链表"><a href="#特定深度节点链表" class="headerlink" title="特定深度节点链表"></a>特定深度节点链表</h1><p>题目取自《程序员面试金典》4.3</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>类似广度优先遍历，通过遍历每一层，并逐层添加相应节点</p><h3 id="错误来源"><a href="#错误来源" class="headerlink" title="错误来源"></a>错误来源</h3><p>没有正确的处理链表头节点的位置，因为力扣题目里没有直接使用LinkedList类，而是使用了最基本的节点，所以需要使用一个指针对头节点进行保存，另一个指针进行添加操作。</p><p>错误示范</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode[] <span class="title">addLists</span>(<span class="params">ListNode[] listOfLevel, <span class="keyword">int</span> index, TreeNode tree</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tree == <span class="literal">null</span>) <span class="keyword">return</span> listOfLevel;</span><br><span class="line">        ListNode temp = listOfLevel[index];</span><br><span class="line">        <span class="keyword">while</span> (temp!= <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = <span class="keyword">new</span> ListNode(tree.val);</span><br><span class="line">        temp = temp.next;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> listOfLevel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a>正确答案</h3><p>先通过c#，list类对每一层进行节点的创建，设置计数器对每一层的节点数量进行控制，最后再创建答案的数组。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode[] <span class="title">ListOfDepth</span>(<span class="params">TreeNode tree</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    List&lt;ListNode&gt; listOfLevels = <span class="keyword">new</span> List&lt;ListNode&gt;();</span><br><span class="line">    <span class="keyword">int</span> curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> Queue&lt;TreeNode&gt;();</span><br><span class="line">    queue.Enqueue(tree);</span><br><span class="line">    ListNode node = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode find = node;</span><br><span class="line">    <span class="keyword">while</span> (queue.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode temp = queue.Dequeue();</span><br><span class="line">        node.next = <span class="keyword">new</span> ListNode(temp.val);</span><br><span class="line">        node = node.next;</span><br><span class="line">        curr--;</span><br><span class="line">        <span class="keyword">if</span> (temp.left != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            queue.Enqueue(temp.left);</span><br><span class="line">            next++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp.right != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            queue.Enqueue(temp.right);</span><br><span class="line">            next++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curr == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            curr = next;</span><br><span class="line">            next = <span class="number">0</span>;</span><br><span class="line">            listOfLevels.Add(find.next);</span><br><span class="line">            node = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            find = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> listOfLevels.ToArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;特定深度节点链表&quot;&gt;&lt;a href=&quot;#特定深度节点链表&quot; class=&quot;headerlink&quot; title=&quot;特定深度节点链表&quot;&gt;&lt;/a&gt;特定深度节点链表&lt;/h1&gt;&lt;p&gt;题目取自《程序员面试金典》4.3&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot;
      
    
    </summary>
    
    
    
      <category term="leetcode" scheme="https://crunchybiscuits.github.io/tags/leetcode/"/>
    
  </entry>
  
</feed>
