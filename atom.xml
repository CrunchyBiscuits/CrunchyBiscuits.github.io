<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZY-Zhang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://crunchybiscuits.github.io/"/>
  <updated>2021-10-16T06:29:42.000Z</updated>
  <id>https://crunchybiscuits.github.io/</id>
  
  <author>
    <name>ZY-Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PBR基础理论(二)</title>
    <link href="https://crunchybiscuits.github.io/2021/10/16/PBR%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA(%E4%BA%8C)/"/>
    <id>https://crunchybiscuits.github.io/2021/10/16/PBR%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA(%E4%BA%8C)/</id>
    <published>2021-10-16T06:28:38.000Z</published>
    <updated>2021-10-16T06:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PBR基础介绍-二"><a href="#PBR基础介绍-二" class="headerlink" title="PBR基础介绍(二)"></a>PBR基础介绍(二)</h1><p>本文将在unity中尝试复现上文提及的内容，主要参考了<a href="https://zhuanlan.zhihu.com/p/68025039">宋开心大佬的这篇</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_Theory_01.png" alt=""></p><p>根据BRDF的渲染方程需要实现的主要部分：</p><ol><li>直接光<ol><li>直接光漫反射</li><li>直接光高光<ol><li>法线分布函数 D</li><li>几何函数 G</li><li>菲涅尔函数 F</li></ol></li></ol></li><li>间接光<ol><li>IBL</li><li>SH</li></ol></li></ol><h2 id="实现之前"><a href="#实现之前" class="headerlink" title="实现之前"></a>实现之前</h2><h3 id="Unity的linear空间与Gamma空间"><a href="#Unity的linear空间与Gamma空间" class="headerlink" title="Unity的linear空间与Gamma空间"></a>Unity的linear空间与Gamma空间</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Shader中涉及到的参数如下</span><br><span class="line">_MainTex(&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">_Tint(&quot;Tint&quot;, Color) = (1 ,1 ,1 ,1)</span><br><span class="line">// 金属度</span><br><span class="line">_Metallic(&quot;Metallic&quot;, Range(0, 1)) = 0 </span><br><span class="line">// 粗糙度</span><br><span class="line">_Smoothness(&quot;Smoothness&quot;, Range(0, 1)) = 0.5</span><br></pre></td></tr></table></figure><p>需要注意的是设置金属度/光滑度贴图的时候，如果在linear空间下贴图设定勾选了SRGB的选项(这个勾选本质上就是对颜色做了一次pow(color,2.2)的操作)，那么需要在开头添加[Gamma]。一般来说PBR需要配合HDR进行开发。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 金属度</span><br><span class="line">[Gamma]_Metallic(&quot;Metallic&quot;, Range(0, 1)) = 0 </span><br><span class="line">// 粗糙度</span><br><span class="line">[Gamma]_Smoothness(&quot;Smoothness&quot;, Range(0, 1)) = 0.5</span><br></pre></td></tr></table></figure><p>这里是两个空间下进行的步骤</p><p>linear颜色空间：</p><p>1）unity对输入颜色做逆gamma校正</p><p>2）shader对颜色进行计算并返回</p><p>3）unity对返回颜色做gamma校正</p><p>4）显示器对显卡输出的颜色做逆校正</p><p>5）人眼对显示器显示的图像做gamma校正</p><p>gamma颜色空间：</p><p>1）shader对输入颜色进行计算并返回</p><p>2）显示器对显卡输出的颜色做逆gamma校正</p><p>3）人眼对显示器显示的图像做gamma校正</p><h3 id="Roughness和perceptualRoughness的关系"><a href="#Roughness和perceptualRoughness的关系" class="headerlink" title="Roughness和perceptualRoughness的关系"></a>Roughness和perceptualRoughness的关系</h3><p>由Disney提出，在diffuse和specular中roughness使用的是不同的值，如下图所示，个人觉得并没有很清晰的解释另一个roughness是怎么来的，只是知道了roughness需要更明显的表现对表面的凸起的平滑。在Unity中计算关系如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perceptualRoughness = 1.0 - _Smoothness;</span><br><span class="line">roughness = perceptualRoughness * perceptualRoughness;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_08.png" alt=""></p><h2 id="直接光"><a href="#直接光" class="headerlink" title="直接光"></a>直接光</h2><h3 id="直接光漫反射"><a href="#直接光漫反射" class="headerlink" title="直接光漫反射"></a>直接光漫反射</h3><p>由渲染方程可得 Kd * Color / PI</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">half3 diffuseColor = albedo * lightColor * NdotL / UNITY_PI;</span><br></pre></td></tr></table></figure><p>得到的结果如下，上方是从Unity官方扒下来的直接光部分，下方是除了PI之后的表现效果。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_09.png" alt=""></p><p>可以看到得到的结果相当暗，但是在UnityStandardBRDF.cginc的注释中得到了答案。我理解的是这里因为是经验性的设置，为了统一和旧版本shader效果，保证整体不会太暗，漫反射和高光项同时乘了PI。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_10.png" alt=""></p><p>因此漫反射改为如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">half3 diffuseColor = albedo * lightColor * NdotL;</span><br></pre></td></tr></table></figure><p>在Unity中主要使用的是Disney Diffuse</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Disney Diffuse</span><br><span class="line">half DisneyDiffuse(half NdotV, half NdotL, half LdotH, half perceptualRoughness)</span><br><span class="line">&#123;</span><br><span class="line">    half fd90 = 0.5 + 2 * LdotH * LdotH * perceptualRoughness;</span><br><span class="line">    // Two schlick fresnel term</span><br><span class="line">    half lightScatter   = (1 + (fd90 - 1) * Pow5(1 - NdotL));</span><br><span class="line">    half viewScatter    = (1 + (fd90 - 1) * Pow5(1 - NdotV));</span><br><span class="line"></span><br><span class="line">    return lightScatter * viewScatter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里采用的是渲染方程中的实现方式，得到的效果如下第四排</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_01.png" alt=""></p><h3 id="直接光镜面反射"><a href="#直接光镜面反射" class="headerlink" title="直接光镜面反射"></a>直接光镜面反射</h3><p>这边儿是重点，整个的形式如下，Unity中采用的是cook-torrance的公式</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_11.png" alt=""></p><h4 id="法线分布函数-D"><a href="#法线分布函数-D" class="headerlink" title="法线分布函数 D"></a>法线分布函数 D</h4><p>按上一篇理论来说，这个函数本质上输出的是一个比值，统计学上是一个正态分布函数，计算的是微平面上的半程向量H和宏观平面半程向量一致的数量有多少。在Unity中采用的是Trowbridge-Reitz GGX。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_12.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// NDF</span><br><span class="line">inline float TrowbridgeReitzGGX(float NdotH, float roughness)</span><br><span class="line">&#123;</span><br><span class="line">    float r = max(roughness, 0.003);</span><br><span class="line">    float r2 = r * r;</span><br><span class="line">    float d = (NdotH * NdotH) * (r2 - 1.0) + 1.0;</span><br><span class="line">    return UNITY_INV_PI * r2 / (d * d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将实现的值输出，得到结果如下图第四排，当_Smoothness为0的时候没有高光的显示，当_Smoothness为1的时候球体上呈现出的是很小很亮的光斑。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_02.png" alt=""></p><h4 id="几何函数-G"><a href="#几何函数-G" class="headerlink" title="几何函数 G"></a>几何函数 G</h4><p>这个函数描述的是遮挡的比率。需要注意的是几何函数内是计算两个方向的，一个是光线入射方向，一个是光线出射方向。<img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_13.png" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_14.png" alt=""></p><p>写入函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Geometric</span><br><span class="line">inline float SchlickGeometricGGX(float NdotV, float NdotL, float roughness)</span><br><span class="line">&#123;</span><br><span class="line">    float k = (roughness + 1.0) * (roughness + 1.0) * 0.125;</span><br><span class="line">    float lightTerm = NdotL / lerp(NdotL, 1.0, k);</span><br><span class="line">    float viewTerm = NdotV / lerp(NdotV, 1.0, k);</span><br><span class="line"></span><br><span class="line">    return lightTerm * viewTerm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照公式进行计算得到的结果如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_03.png" alt=""></p><h4 id="菲涅尔-F"><a href="#菲涅尔-F" class="headerlink" title="菲涅尔 F"></a>菲涅尔 F</h4><p>菲涅尔主要描述的是反射光线对比光线被折射的部分所占的比率，这个比率会随着我们观察的角度不同而不同。当光线碰撞到一个表面的时候，菲涅尔方程会根据观察角度告诉我们被反射的光线所占的百分比。利用这个反射比率和能量守恒，我们可以直接得出光线被折射的部分以及光线剩余的能量。一般当观察方向是垂直的时候获得的是对应物体最基本的反射性，基本没有菲涅尔相关的影响，当掠射角增加，菲涅尔现象会明显很多。</p><p>通常会采用Fresnel-Schlick的方法：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_15.png" alt=""></p><p>在经过Unreal拟合优化之后，通过exp2函数提高了计算效率，变成了这样：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_16.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">half3 F0 = lerp(half3(0.04,0.04,0.04), albedo, _Metallic);</span><br><span class="line"></span><br><span class="line">// Fresnel</span><br><span class="line">inline float3 Fresnel(float3 F0, float VdotH)</span><br><span class="line">&#123;</span><br><span class="line">    float power = (-5.55473 * VdotH - 6.98316) * VdotH;</span><br><span class="line">    return F0 + (1 - F0) * exp2(power);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终菲涅尔效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_04.png" alt=""></p><p>综合整体的直接光效果后，下边面两排分别是Unity自带的standard，和手写的shader对比</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_05.png" alt=""></p><h2 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h2><p>环境光的公式如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_17.png" alt=""></p><p>第一部分为间接光漫反射，第二部分为间接光镜面反射。</p><h3 id="间接光漫反射"><a href="#间接光漫反射" class="headerlink" title="间接光漫反射"></a>间接光漫反射</h3><p>根据<a href="https://learnopengl-cn.github.io/07%20PBR/03%20IBL/01%20Diffuse%20irradiance/">Learnopengl</a>提到的方法，通常情况下是对间接光进行预处理，将经过处理后的数据存到一张新的贴图，贴图计算主要是通过卷积完成。这张贴图又叫辐照度图，在每个入射方向取平均值的结果。Unity中已经自动完成了这一步，是通过球谐函数进行编码的全局光照，Unity整个的执行过程为：将环境贴图进行预积分得到辐照度图→将辐照度图进行球谐函数编码存储。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_18.png" alt=""></p><p>在Unity中通过直接调用UnityCG.cginc中的ShadeSH9函数获取相应的光照信息，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 获取辐照度</span><br><span class="line">half3 ambientContribution = ShadeSH9(float4(normalWorld, 1));</span><br><span class="line"></span><br><span class="line">half3 ambient = 0.03 * albedo;</span><br><span class="line">// </span><br><span class="line">half3 iblDiffuse = max(half3(0, 0, 0), ambient.rgb + ambientContribution);</span><br><span class="line"></span><br><span class="line">// 和直接光的系数不同需要重新计算</span><br><span class="line">float3 Flast = FresnelSchlickRoughness(max(NdotV, 0.0), F0, roughtness);</span><br><span class="line">float kdLast = (1 - Flast) * (1 - _Metallic);</span><br><span class="line"></span><br><span class="line">half3 iblDiffuseResult = iblDiffuse * kdLast * albedo;</span><br><span class="line"></span><br><span class="line">// ***************</span><br><span class="line"></span><br><span class="line">float3 fresnelSchlickRoughness(float cosTheta, float3 F0, float roughness)</span><br><span class="line">&#123;</span><br><span class="line">return F0 + (max(float3(1.0 - roughness, 1.0 - roughness, 1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加上间接光之后效果如下图第二排：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_06.png" alt=""></p><h3 id="间接光镜面反射"><a href="#间接光镜面反射" class="headerlink" title="间接光镜面反射"></a>间接光镜面反射</h3><p>Unreal给出的方法是使用近似算法将高光反射的方程简化成右边。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_19.png" alt=""></p><p>镜面反射部分，使用的是对预处理的环境贴图进行LOD操作之后会生成有多层的一张贴图，通过对这张贴图进行三线性插值，得到的就是对应的mip层级数据，最后在根据这个数据对HDR进行解码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 根据粗糙度获取mip的层级</span><br><span class="line">half mipRoughness = perceptualRoughness * (1.7 - 0.7 * perceptualRoughness);</span><br><span class="line">// 获取视线的反射</span><br><span class="line">half3 reflectVec = reflect(-viewDir, normalWorld);</span><br><span class="line">// 获取mip层级</span><br><span class="line">half mip = mipRoughness * UNITY_SPECCUBE_LOD_STEPS;</span><br><span class="line">// 三线性插值</span><br><span class="line">half4 rgbm = UNITY_SAMPLE_TEXCUBE_LOD(unity_SpecCube0, reflectVec, mip);</span><br><span class="line">// 从HDR下解码</span><br><span class="line">half3 iblSpecular = DecodeHDR(rgbm, unity_SpecCube0_HDR);</span><br></pre></td></tr></table></figure><p>这样就得到了简化方程的左半部分，而右半部分在Unity中并没有采用LUT的方法，而是通过surfaceReduction的系数，以及一个在F0（specColor就是我们的F0）和grazingTerm之间进行插值的菲涅尔系数。Unity中的计算如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">half surfaceReduction = 1.0 / (roughtness * roughtness + 1.0);</span><br><span class="line">half oneMinusReflectivity = unity_ColorSpaceDielectricSpec.a - _Metallic * unity_ColorSpaceDielectricSpec.a;</span><br><span class="line">half grazingTerm = saturate(_Smoothness + (1.0 - oneMinusReflectivity));</span><br><span class="line"></span><br><span class="line">half3 iblSpecularResult = iblSpecular * surfaceReduction * FresnelLerp(F0, grazingTerm, NdotV);</span><br></pre></td></tr></table></figure><p>最后综合得到的效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_07.png" alt=""></p><p>参考：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/68025039">https://zhuanlan.zhihu.com/p/68025039</a></li><li><a href="https://zhuanlan.zhihu.com/p/141904960">https://zhuanlan.zhihu.com/p/141904960</a></li><li><a href="https://learnopengl-cn.github.io/07%20PBR/03%20IBL/01%20Diffuse%20irradiance/">https://learnopengl-cn.github.io/07%20PBR/03%20IBL/01%20Diffuse%20irradiance/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PBR基础介绍-二&quot;&gt;&lt;a href=&quot;#PBR基础介绍-二&quot; class=&quot;headerlink&quot; title=&quot;PBR基础介绍(二)&quot;&gt;&lt;/a&gt;PBR基础介绍(二)&lt;/h1&gt;&lt;p&gt;本文将在unity中尝试复现上文提及的内容，主要参考了&lt;a href=&quot;http
      
    
    </summary>
    
    
    
      <category term="PBR" scheme="https://crunchybiscuits.github.io/tags/PBR/"/>
    
  </entry>
  
  <entry>
    <title>PBR基础理论(一)</title>
    <link href="https://crunchybiscuits.github.io/2021/10/14/PBR%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA(%E4%B8%80)/"/>
    <id>https://crunchybiscuits.github.io/2021/10/14/PBR%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA(%E4%B8%80)/</id>
    <published>2021-10-13T16:02:25.000Z</published>
    <updated>2021-10-13T17:31:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PBR基础介绍-一"><a href="#PBR基础介绍-一" class="headerlink" title="PBR基础介绍(一)"></a>PBR基础介绍(一)</h1><p>主要了解PBR的各种部分的作用以及相关参数的影响，非物理意义推导</p><h2 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h2><p>抛开自发光，渲染方程通常长成这个样子</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_Theory_00.png" alt=""></p><p>简单的理解成以下几个部分:</p><ol><li>Lo(v)表示从一个点反射出的光照强度。</li><li>f(l, v)表示该点入射光线强度和反射之间的比例，一般有BRDF， BTDF， BSDF和BSSRDF等。</li><li>Li(l) * (n · l)表示入射光照强度Li乘以衰减。</li><li>整个大的积分表示的是该点对应的半球积分的累加 — 这里积分是通过蒙特卡洛近似去求解的</li></ol><p>而PBR中的渲染方程通常长这样，本质上其实是计算某一点在经过反射，折射后相关信息的比值。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_Theory_01.png" alt=""></p><p>和第上一条公式相比变化的地方可以理解为以下几个部分：</p><ol><li>反射<ol><li>漫反射项 + 漫反射比例 — Kd * C / PI</li><li>镜面反射项 + 镜面反射比例 — Ks * ( D * F * G / 4 * (Wo · n) * (Wi · n)<ol><li>法线分布函数D — Normal Distribution</li><li>几何函数 G — Gemetric，有时候也会是 V (visibility)</li><li>菲涅尔 F — Fresnel</li></ol></li></ol></li><li>光源颜色以及其衰减 — Li(p, Wi) * (Wi · n)</li></ol><p>与PBR相关的基础理论如下：</p><ol><li>微平面理论 (Microfacet Theory) </li><li>能量守恒 (Energy Conservation)</li><li>菲涅尔反射 (Fresnel Reflectance)</li><li>线性空间 (Linear Space)</li><li>色调映射 (Tone Mapping)</li><li>物质的光学特性 (Substance Optical Properties)</li></ol><p>色调映射和线性空间在之前文章已经有过记录，这里不再提及。</p><h3 id="微平面理论"><a href="#微平面理论" class="headerlink" title="微平面理论"></a>微平面理论</h3><p>此理论主要涉及法线分布函数项D和几何函数项G，这里有两种类型的平面，一个是宏观上大的平面，另一个是微观上在这个大平面上的若干微小镜面。因此法线和几何关系也涉及到宏观上和微观上的区分，微平面理论处理的就是如何在宏观平面上，将其下那些微小镜面的产生的特性给展现出来。在实际的工作流程中，通常用粗糙度贴图或者高光贴图来表示。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_Theory_02.png" alt=""></p><p>上图可以看到光滑和粗糙的一个对比，从法线分布函数项上分析，这里比较的主要就是有多少微平面的法线和宏观上平面的法线是一致的，一致的比例越多，在宏观上表现越光滑。</p><p>几何函数项上分析，并不是所有和宏观平面法线一致的微表面都会有贡献，类似AO，在微表面上，入射和出射的时候都有可能会被遮挡。实际上，被遮挡的光线在微平面上来回反弹也会有为出射光线做出贡献的时候，但是在微平面理论中假设被遮挡的光线就不再为最后的出射光线做贡献了。<img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_Theory_03.png" alt=""></p><p>这两项在功能上和法线贴图还有AO贴图类似，但是这两张贴图做不到那么细致的精度，通常在PBR流程中用专门的粗糙度或者高光贴图代替。</p><p>两者本质上都是一个比例，一种系数。</p><h3 id="能量守恒"><a href="#能量守恒" class="headerlink" title="能量守恒"></a>能量守恒</h3><p>如同现实世界中那样，在某个点上遇到反射和折射的时候，会有能量被吸收和损耗，因此出射的光线强度肯定是小于入射光线的，并且越粗糙的平面高光区域越大，那么强度应该相对较小，但是如下图所示传统的Blinn-phong经验模型并不能体现出这一点。<strong>因此需要进行能量的统一由此引入了BRDF中漫反射的Kd和高光的Ks项</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_Theory_04.png" alt=""></p><h3 id="菲涅尔反射"><a href="#菲涅尔反射" class="headerlink" title="菲涅尔反射"></a>菲涅尔反射</h3><p>菲涅尔反射是一种现象，与视线还有物体表面的夹角有关，这里涉及到的一个概念是掠射角(入射角的余角)，当掠射角越大，那么菲涅尔的现象越明显。常言道万物皆有菲涅尔，不同的物质有不同的反射率。在F中会涉及到F0这个参数，这个表示的是入射角为0°的时候的菲涅尔的值，金属一般在0.7 - 1.0， 非金属一般在0.02 - 0.04。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_Theory_05.png" alt=""></p><h3 id="物质光学特性"><a href="#物质光学特性" class="headerlink" title="物质光学特性"></a>物质光学特性</h3><p>这个是和上述菲涅尔反射相联系的，主要分为金属和非金属，金属一般在0.7 - 1.0， 非金属一般在0.02 - 0.04。通常都是用一个float3表示，但是非金属的三个值通常是一致的因此常呈现灰，而金属则会因为不同而表现出彩色的反射颜色。因为非金属的值非常小，因此在unity中，通常用float3(0.04, 0.04, 0.04)来表示非金属，用Albedo去表示金属的F0值。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_Theory_06.png" alt=""></p><p>但是物体在现实世界中，即使是金属也会有氧化等各种情况，而出现金属和非金属结合的一种状态，所以通过Metallic值来做插值。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/PBR_Theory_07.png" alt=""></p><p>参考：</p><ol><li><a href="https://blog.selfshadow.com/publications/s2015-shading-course/hoffman/s2015_pbs_physics_math_slides.pdf">https://blog.selfshadow.com/publications/s2015-shading-course/hoffman/s2015_pbs_physics_math_slides.pdf</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PBR基础介绍-一&quot;&gt;&lt;a href=&quot;#PBR基础介绍-一&quot; class=&quot;headerlink&quot; title=&quot;PBR基础介绍(一)&quot;&gt;&lt;/a&gt;PBR基础介绍(一)&lt;/h1&gt;&lt;p&gt;主要了解PBR的各种部分的作用以及相关参数的影响，非物理意义推导&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
    
    
      <category term="PBR" scheme="https://crunchybiscuits.github.io/tags/PBR/"/>
    
  </entry>
  
  <entry>
    <title>FBX SDK简单使用(一)</title>
    <link href="https://crunchybiscuits.github.io/2021/07/18/FBX%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>https://crunchybiscuits.github.io/2021/07/18/FBX%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-07-18T03:02:21.000Z</published>
    <updated>2021-07-26T08:21:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FBX-SDK简单使用-一）"><a href="#FBX-SDK简单使用-一）" class="headerlink" title="FBX SDK简单使用(一）"></a>FBX SDK简单使用(一）</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>FBX是Autodesk的一个常用的跨平台的三维数据格式，应用很广泛，这里是<a href="https://help.autodesk.com/view/FBX/2020/ENU/?guid=FBX_Developer_Help_cpp_ref_index_html">官方API</a>，这里是<a href="https://help.autodesk.com/view/FBX/2020/ENU/?guid=FBX_Developer_Help_sample_programs_html">官方例子</a>。FBX的安装可以<a href="https://byteori.com/doc/FBX%20SDK%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE.pdf">参照这里</a>，基本介绍可以<a href="https://blog.csdn.net/larry233/article/details/78935657">参考这里</a>。</p><h2 id="查看FBX文件数据"><a href="#查看FBX文件数据" class="headerlink" title="查看FBX文件数据"></a>查看FBX文件数据</h2><p>这是在整个使用过程中个人认为帮助很大的一个功能，3ds MAX中可以直接设置，在导出的时候可以选择二进制的格式或者ASCII的格式，如下图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/FBX_SDK_00.png" alt=""></p><p>在FBX SDK中通过对FbxExporter设置可以得到一样的效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FBX设置输出ASCII格式文件</span></span><br><span class="line">FbxExporter* fbxExporter = FbxExporter::<span class="built_in">Create</span>(fbxManager, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="type">int</span> fbxFormat = fbxManager-&gt;<span class="built_in">GetIOPluginRegistry</span>()-&gt;<span class="built_in">FindWriterIDByDescription</span>(<span class="string">&quot;FBX ascii(*.fbx)&quot;</span>);</span><br><span class="line"><span class="type">bool</span> exportStatus = fbxExporter-&gt;<span class="built_in">Initialize</span>(fileOutput, fbxFormat, fbxManager-&gt;<span class="built_in">GetIOSettrings</span>());</span><br></pre></td></tr></table></figure><p>在VS Code中查看输出的文件显示如下：<img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/FBX_SDK_01.png" alt="">这样可以方便查看FBX文件是否包含需要的数据，导入到引擎的时候，也方便验证数据。</p><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>FBX文件是以树(SceneTree)的形式进行存储的，以RootNode作为起始，在官方的例子中可以看出<img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/FBX_SDK_02.png" alt=""></p><p>通过遍历Node可以得到相应Node存储的数据，每个Node有对应的在FbxNodeAttribute枚举中的类型。例如eMesh，eSkeleton等。</p><h2 id="常见概念"><a href="#常见概念" class="headerlink" title="常见概念"></a>常见概念</h2><h3 id="Control-Point-和-Polygon-Vertex"><a href="#Control-Point-和-Polygon-Vertex" class="headerlink" title="Control Point 和 Polygon Vertex"></a>Control Point 和 Polygon Vertex</h3><p>以3dsMax中最简单的Cube为例子，在正常格式下输出对应的Fbx得到的control point数量是8，polygon vertex数量是36，polygon数量是12。对应到Cube上，可以看到正常见到的Cube拥有8个顶点对应Control Point的数量，而正常box有6个面，在实际输出的时候，被分成了12个三角面，每个三角面对应一个polygon，而每个三角面三个顶点，因此polygon vertex的数量是12 * 3 = 36。每个polygon vertex可能拥有同一个位置，这时候是索引到同一个control point。</p><p>在Fbx SDK中通过以下代码获取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点序号</span></span><br><span class="line"><span class="type">int</span> vertexIdx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> polygonNum = mesh-&gt;<span class="built_in">GetPolygonCount</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;polygonNum;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 根据序号获取对应polygon的顶点数</span></span><br><span class="line">    <span class="type">int</span> polygonSize = mesh-&gt;<span class="built_in">GetPolygonSize</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;polygonSize;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根据polygon序号和顶点在对应polygon中序号获取对应的control point序号</span></span><br><span class="line"><span class="type">int</span> ctrlPointIdx = mesh-&gt;<span class="built_in">GetPolygonVertex</span>(i, j);</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        vertexIdx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Fbx-Layer"><a href="#Fbx-Layer" class="headerlink" title="Fbx Layer"></a>Fbx Layer</h3><p>在FBX的结构中，法线，切线，颜色，uv等都是通过layer进行添加，挂载在对应的mesh上。我们可以看到如下类似的代码，在GetElementNormal(0)括号中0代表第一层，例如uv等可能有好几套，通过这里可以指定第几套。特别需要注意的是，在3dsMax中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取法线</span></span><br><span class="line">FbxGeometryElementNormal* vertexNormal = mesh-&gt;<span class="built_in">GetElementNormal</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 获取切线</span></span><br><span class="line">FbxGeometryElementTangent* vertexTangent = mesh-&gt;<span class="built_in">GetElementTangent</span>(<span class="number">0</span>); </span><br><span class="line"><span class="comment">// 获取顶点色</span></span><br><span class="line">FbxGeometryElementVertexColor* vertexColor = mesh-&gt;<span class="built_in">GetElementVertexColor</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 获取UV</span></span><br><span class="line">FbxGeometryElementUV* vertexUV = mesh-&gt;<span class="built_in">GetElementUV</span>(<span class="number">0</span>); </span><br></pre></td></tr></table></figure><p><strong>需要注意的是：</strong></p><ol><li>通过maxscript指令box()创建的盒子和直接在max场景中创建的盒子数据是不一样的，box()指令直接创建的盒子不带uv，没法通过代码生成tangent。</li><li>在Unity中导入切线数据，需要同时生成副法线数据，Unity中才可见。</li></ol><h4 id="Mapping-Mode"><a href="#Mapping-Mode" class="headerlink" title="Mapping Mode"></a>Mapping Mode</h4><p><strong>eByControlPoint</strong></p><p>在这个模式下Layer的数据是通过控制点去添加的，每个顶点的数据和对应的控制点的数据相同，在这里用顶点和控制点的法线进行尝试，得到的结果如下，可以看到整个Cube的边缘显得十分的柔和。</p><p>对应效果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/FBX_SDK_07.png" alt=""></p><p><strong>eByPolygonVertex</strong></p><p>在这个模式下Layer的数据是通过顶点去添加的，在这里用顶点和控制点的法线进行尝试，得到的结果如下，可以看到整个Cube的边缘显得很锐利。</p><p>对应效果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/FBX_SDK_05.png" alt=""></p><h4 id="Reference-Mode"><a href="#Reference-Mode" class="headerlink" title="Reference Mode"></a>Reference Mode</h4><p>这是一种选择是否使用优化存储的模式，eDirect表示直接通过索引来获取相应的信息，对应数量与control point或者vertex相同，eIndexToDirect则会将相同数据合并，并通过control point或者vertex的二级索引指向需要的数据，这样重复数据能够指向同一个位置节省存储空间。</p><p>在eIndexToDirect中需要通过如下代码获取索引</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> index = vertexNormal-&gt;<span class="built_in">GetIndexArray</span>().<span class="built_in">GetAt</span>(vertexIdx);</span><br></pre></td></tr></table></figure><p><strong>eDirect在FBX文件中显示如下</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/FBX_SDK_09.jpg" alt=""></p><p><strong>eIndexToDirect在FBX文件中显示如下</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/FBX_SDK_010.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;FBX-SDK简单使用-一）&quot;&gt;&lt;a href=&quot;#FBX-SDK简单使用-一）&quot; class=&quot;headerlink&quot; title=&quot;FBX SDK简单使用(一）&quot;&gt;&lt;/a&gt;FBX SDK简单使用(一）&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot;
      
    
    </summary>
    
    
    
      <category term="3dsMAx, FBX SDK" scheme="https://crunchybiscuits.github.io/tags/3dsMAx-FBX-SDK/"/>
    
  </entry>
  
  <entry>
    <title>屏幕后处理Re(一)</title>
    <link href="https://crunchybiscuits.github.io/2021/05/27/%E5%90%8E%E5%A4%84%E7%90%86ReRe-1/"/>
    <id>https://crunchybiscuits.github.io/2021/05/27/%E5%90%8E%E5%A4%84%E7%90%86ReRe-1/</id>
    <published>2021-05-27T12:16:22.000Z</published>
    <updated>2021-05-27T12:18:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="屏幕后处理Re-一"><a href="#屏幕后处理Re-一" class="headerlink" title="屏幕后处理Re(一)"></a>屏幕后处理Re(一)</h1><h2 id="HDR，LDR"><a href="#HDR，LDR" class="headerlink" title="HDR，LDR"></a>HDR，LDR</h2><p>首先需要了解<strong>Color Grading（颜色分级）</strong>又叫调色，是游戏后期处理中常见也必备的一个环节。通过调整它能够改变或者矫正最终图像的颜色和亮度。</p><p>Dynamic Range是一种用数学的方式来描述场景亮度层次范围的技术，是图像从暗到亮的亮度/灰度分级，分级越多能够表现的画面层次就越丰富。</p><p>HDR和LDR：</p><ol><li>Low Dynamic Range(LDR)<ol><li>LDR作为8位的颜色图片，使用RGB模型，每个颜色有256种亮度等级，总共能够表示256^3种颜色。但是和现实相比仍有局限，所以引入HDR</li></ol></li><li>High Dynamic Range(HDR)<ol><li>HDR常见有12位和16位，因为显示器限制，显示的值只能在0，1，但是光照计算可以没有这样的限制，这样可以表示更多层次的明暗细节，亮的部分能够很亮，暗的部分能够很暗。</li><li>LDR范围确定，但是HDR并不，所以同样是HDR可能范围并不相同。因为范围不同，但是最终需要统一到[0,1]供显示器使用，所以引入了Tone Mapping (色调映射)</li></ol></li></ol><h2 id="色调映射-Tone-Mapping"><a href="#色调映射-Tone-Mapping" class="headerlink" title="色调映射(Tone Mapping)"></a>色调映射(Tone Mapping)</h2><p>用于将HDR转换到LDR，Tone mapping有不少算法的更迭，可以参考<a href="https://zhuanlan.zhihu.com/p/21983679">叛逆者</a>的文章和<a href="https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/">Krzysztof Narkowicz</a>的文章，目前最常用的是由美国电影艺术与科学学会提出的ACES Tone mapping，这也是基于经验的近似。 使用Tone Mapping的主要目的是获取一个S曲线，这样的话在S的两端，接近0和接近1的地方也能有更多层次的划分(暗的地方更暗，亮的地方更亮)。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/tone_mapping.png" alt=""></p><p><strong>实现</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">float3 <span class="title function_">ACESFilm</span><span class="params">(float3 x, <span class="type">float</span> adapted_lum)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> a = <span class="number">2.51f</span>;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">0.03f</span>;</span><br><span class="line">    <span class="type">float</span> c = <span class="number">2.43f</span>;</span><br><span class="line">    <span class="type">float</span> d = <span class="number">0.59f</span>;</span><br><span class="line">    <span class="type">float</span> e = <span class="number">0.14f</span>;</span><br><span class="line">    x *= adapted_lum;</span><br><span class="line">    <span class="keyword">return</span> saturate((x*(a*x+b))/(x*(c*x+d)+e));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float3 <span class="title function_">ACESFilm</span><span class="params">(float3 x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> a = <span class="number">2.51f</span>;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">0.03f</span>;</span><br><span class="line">    <span class="type">float</span> c = <span class="number">2.43f</span>;</span><br><span class="line">    <span class="type">float</span> d = <span class="number">0.59f</span>;</span><br><span class="line">    <span class="type">float</span> e = <span class="number">0.14f</span>;</span><br><span class="line">    <span class="keyword">return</span> saturate((x*(a*x+b))/(x*(c*x+d)+e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本后处理"><a href="#基本后处理" class="headerlink" title="基本后处理"></a>基本后处理</h2><h3 id="亮度"><a href="#亮度" class="headerlink" title="亮度"></a>亮度</h3><p>用于表示图片的明暗程度</p><p><strong>亮度计算方法:</strong></p><ul><li>线性空间：Luminance = color.rgb * float3(0.2125,0.7154,0.0721)</li></ul><p><strong>控制方法：</strong>系数直接与RGB相乘</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">half4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">half3 final_col = col.rgb * _Brightness;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/color_adj0.gif" alt=""></p><h3 id="饱和度"><a href="#饱和度" class="headerlink" title="饱和度"></a>饱和度</h3><p>用于表示在同亮度下，颜色偏离灰色的程度，偏离越大，颜色越深越鲜艳</p><p><strong>控制方法：</strong></p><ol><li>通过lerp函数与同亮度灰色进行插值</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">half3 luminance_col = half3(luminance,luminance,luminance);</span><br><span class="line">final_col = lerp(luminance_col, final_col,_Saturation);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/color_adj1.gif" alt=""></p><h3 id="对比度"><a href="#对比度" class="headerlink" title="对比度"></a>对比度</h3><p>对比度指的是一幅图像中明暗区域最亮的白和最暗的黑之间不同亮度层级的差异，差异范围越大代表对比越大，差异范围越小代表对比越小</p><p><strong>控制方法：</strong>通过与(0.5, 0.5, 0.5)的灰度插值进行控制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">half3 avg_col = half3(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br><span class="line">final_col = lerp(avg_col, final_col, _Contrast);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/color_adj3.gif" alt=""></p><h3 id="HSV颜色空间"><a href="#HSV颜色空间" class="headerlink" title="HSV颜色空间"></a>HSV颜色空间</h3><p>HSV(Hue, Saturation, Value) 也是一种颜色空间，常用在图像编辑工具中</p><ul><li>Hue：色调，用角度度量，范围在0°-360°，红色0°，绿色120°，蓝色240°</li><li>Saturation：饱和度，颜色和对应灰度的混合，0%-100%</li><li>Value：明度，颜色明亮程度，0%(黑)-100%(白)，这个明度和光强度之间没有直接联系</li></ul><p>RGB和CMY颜色空间是面向硬件的，HSV颜色空间是面向用户的，更加直观。</p><p><strong>转换算法(伪代码)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">RGB2HSV()&#123;</span><br><span class="line">max=max(R,G,B);</span><br><span class="line">min=min(R,G,B);</span><br><span class="line">V=max(R,G,B);</span><br><span class="line"><span class="keyword">if</span> (R = max) H =(G-B)/(max-min)* <span class="number">60</span>;</span><br><span class="line"><span class="keyword">if</span> (G = max) H = <span class="number">120</span>+(B-R)/(max-min)* <span class="number">60</span>;</span><br><span class="line"><span class="keyword">if</span> (B = max) H = <span class="number">240</span> +(R-G)/(max-min)* <span class="number">60</span>;</span><br><span class="line"><span class="keyword">if</span> (H &lt; <span class="number">0</span>) H = H+ <span class="number">360</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HSV2RGB()&#123;</span><br><span class="line"><span class="keyword">if</span> (s = <span class="number">0</span>)</span><br><span class="line">R=G=B=V;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">H /= <span class="number">60</span>;</span><br><span class="line">i = INTEGER(H);</span><br><span class="line">f = H - i;</span><br><span class="line">a = V * ( <span class="number">1</span> - s );</span><br><span class="line">b = V * ( <span class="number">1</span> - s * f );</span><br><span class="line">c = V * ( <span class="number">1</span> - s * (<span class="number">1</span> - f ) );</span><br><span class="line"><span class="keyword">switch</span>(i)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: R = V; G = c; B = a;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: R = b; G = v; B = a;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: R = a; G = v; B = c;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: R = a; G = b; B = v;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: R = c; G = a; B = v;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>: R = v; G = a; B = b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调整色相</strong></p><p>将RGB转成HSV之后，调整对应的H值，再转回RGB</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/color_adj4.gif" alt=""></p><h3 id="晕影、暗角"><a href="#晕影、暗角" class="headerlink" title="晕影、暗角"></a>晕影、暗角</h3><p>根据像素点在屏幕中的位置来设置权重，计算的思路在Unity的PostProcessing v.2的Uber.shader和ExposureHistogram.compute中都有用到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExposureHistogram.compute</span></span><br><span class="line"><span class="comment">// 这里通过计算像素位置为当前像素对应亮度的权重进行赋值，之后添加刀对应的EV直方图相应的桶下</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_VIGNETTE_WEIGHTING</span></span><br><span class="line">&#123;</span><br><span class="line">     float2 d = <span class="built_in">abs</span>(sspos - (<span class="number">0.5</span>).xx);</span><br><span class="line">     <span class="type">float</span> vfactor = saturate(<span class="number">1.0</span> - dot(d, d));</span><br><span class="line">     vfactor *= vfactor;</span><br><span class="line">     weight = (uint)(<span class="number">64.0</span> * vfactor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Uber.shader</span></span><br><span class="line"><span class="comment">// _Vignette_Settings: x: intensity, y: smoothness, z: roundness, w: rounded</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 计算距离并调整强度</span></span><br><span class="line">half2 d = <span class="built_in">abs</span>(uvDistorted - _Vignette_Center) * _Vignette_Settings.x;</span><br><span class="line"><span class="comment">// 调整暗角四周的圆角</span></span><br><span class="line">d.x *= lerp(<span class="number">1.0</span>, _ScreenParams.x / _ScreenParams.y, _Vignette_Settings.w);</span><br><span class="line">d = <span class="built_in">pow</span>(saturate(d), _Vignette_Settings.z); </span><br><span class="line"><span class="comment">// 调整暗角边缘平滑度</span></span><br><span class="line">half vfactor = <span class="built_in">pow</span>(saturate(<span class="number">1.0</span> - dot(d, d)), _Vignette_Settings.y);</span><br><span class="line">color.rgb *= lerp(_Vignette_Color, (<span class="number">1.0</span>).xxx, vfactor);</span><br><span class="line">color.a = lerp(<span class="number">1.0</span>, color.a, vfactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/color_adj2.gif" alt=""></p><h2 id="LUT-Look-Up-Table-调色"><a href="#LUT-Look-Up-Table-调色" class="headerlink" title="LUT(Look Up Table)调色"></a>LUT(Look Up Table)调色</h2><p>Look Up Table校色主要是通过查找表的方式对画面进行风格化的处理，本质上是一张映射表，将采样到的像素经过变换映射到另一个对应的颜色，在摄影软件中很常见，可以很方便的调出预留的风格。</p><p>常见的有3D和2D的查找表，3D查找表是将RGB数值作为三维的坐标，把颜色映射到一个立方体中，但是这样做会占用较大存储。</p><p>比较常见的是2D查找表，在b对应的数值区域进行了离散化，可以想象成本来3D对应的b值是连续的，但是在2D中我们根据b值将立方体切成了一片一片的，最后再将这些片连接起来。通过R和B来计算uv的x值，通过G通道来计算uv的y值。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/lut1.png" alt=""></p><p>下图是<a href="https://docs.unrealengine.com/4.26/en-US/RenderingAndGraphics/PostProcessEffects/UsingLUTs/">UE4</a>文档中显示的LUT效果</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/lut3.png" alt=""></p><h3 id="可能出现的问题："><a href="#可能出现的问题：" class="headerlink" title="可能出现的问题："></a>可能出现的问题：</h3><p>在实际的计算过程中，浮点数很有可能会长成这样</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/lut2.png" alt=""></p><p>所以不能完全的将范围内所有的映射加入，因为很有可能会碰到上图的样子，这样的话就会超出映射范围，采样到范围外</p><h3 id="计算方式"><a href="#计算方式" class="headerlink" title="计算方式"></a>计算方式</h3><p>计算方式参考<a href="https://halisavakis.com/my-take-on-shaders-color-grading-with-look-up-textures-lut/">这里</a>，通过先缩小一点采样范围，接着将采样范围进行右移，来防止数值的异常</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> maxColor = COLORS - <span class="number">1.0</span>;</span><br><span class="line">fixed4 col = saturate(tex2D(_MainTex, i.uv));</span><br><span class="line"><span class="comment">// 设置偏移范围</span></span><br><span class="line"><span class="type">float</span> halfColX = <span class="number">0.5</span> / _LUT_TexelSize.z;</span><br><span class="line"><span class="type">float</span> halfColY = <span class="number">0.5</span> / _LUT_TexelSize.w;</span><br><span class="line"><span class="comment">// 通过格子数量来计算阈值保证质量</span></span><br><span class="line"><span class="type">float</span> threshold = maxColor / COLORS;</span><br><span class="line"><span class="comment">// 新uv坐标生成</span></span><br><span class="line"><span class="type">float</span> xOffset = halfColX + col.r * threshold / COLORS;</span><br><span class="line"><span class="type">float</span> yOffset = halfColY + col.g * threshold;</span><br><span class="line"><span class="type">float</span> cell = <span class="built_in">floor</span>(col.b * maxColor);</span><br><span class="line">float2 lutPos = float2(cell / COLORS + xOffset, yOffset);</span><br><span class="line">float4 gradedCol = tex2D(_LUT, lutPos);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> lerp(col, gradedCol, _Contribution);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LUT制作方法"><a href="#LUT制作方法" class="headerlink" title="LUT制作方法 "></a><a href="https://docs.unrealengine.com/4.26/en-US/RenderingAndGraphics/PostProcessEffects/UsingLUTs/">LUT制作方法 </a></h3><ol><li>通过Photoshop对目标画面进行调色</li><li>导入需要存储的LUT</li><li>将调好色的图层拖入对应的LUT中</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/">Knarkowicz ACES</a></li><li><a href="https://zhuanlan.zhihu.com/p/21983679">Tone mapping进化论</a></li><li><a href="https://docs.unrealengine.com/4.26/en-US/RenderingAndGraphics/PostProcessEffects/UsingLUTs/">UE4 LookUpTable</a></li><li><a href="https://halisavakis.com/my-take-on-shaders-color-grading-with-look-up-textures-lut/">Halisavakis LUT</a></li><li><a href="https://baike.baidu.com/item/HSV/547122">HSV</a></li><li><a href="https://github.com/Unity-Technologies/PostProcessing">Unity-Technologies PostProcessing</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;屏幕后处理Re-一&quot;&gt;&lt;a href=&quot;#屏幕后处理Re-一&quot; class=&quot;headerlink&quot; title=&quot;屏幕后处理Re(一)&quot;&gt;&lt;/a&gt;屏幕后处理Re(一)&lt;/h1&gt;&lt;h2 id=&quot;HDR，LDR&quot;&gt;&lt;a href=&quot;#HDR，LDR&quot; class=&quot;
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>线性空间和伽马空间</title>
    <link href="https://crunchybiscuits.github.io/2021/05/14/%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4%E5%92%8C%E4%BC%BD%E9%A9%AC%E7%A9%BA%E9%97%B4/"/>
    <id>https://crunchybiscuits.github.io/2021/05/14/%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4%E5%92%8C%E4%BC%BD%E9%A9%AC%E7%A9%BA%E9%97%B4/</id>
    <published>2021-05-14T14:15:26.000Z</published>
    <updated>2021-05-27T12:14:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gamma和Linear"><a href="#Gamma和Linear" class="headerlink" title="Gamma和Linear"></a>Gamma和Linear</h1><h2 id="线性空间"><a href="#线性空间" class="headerlink" title="线性空间"></a>线性空间</h2><p>在线性空间下，我们感知到的强度和对应的数值强度是按比例对应的，也就是说如果有两个数值强度0.25和0.25那么他们相加的数值强度就是0.5。没有这样特性的空间就是非线性空间。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/gamma_01.png" alt=""></p><h2 id="伽马空间"><a href="#伽马空间" class="headerlink" title="伽马空间"></a>伽马空间</h2><p>之所以引入gamma空间一是因为显示器对颜色强度的感知是非线性的，另一个原因是人眼在较暗的环境下比起亮的环境能够更好的辨别细节。因此在图像压缩中我们希望能够在暗部获得更高的精确度，所以对图像每个像素引入了一个幂函数来进行处理。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/gamma.png" alt=""></p><p>上图(图片来自kinematicsoup)可以看到，当我们在0.45的gamma下，暗部区域有了更高的值，这样就为暗部获取了更高的精确度，但是亮部区域信息就被压缩了。以这样形式存储的图片就称为放在gamma空间中，在显示器上显示的时候会对图片进行一个gamma为2.2的幂的操作，在这里就抵消了0.45gamma的影响，因此能够显示正常。</p><h2 id="常见流程"><a href="#常见流程" class="headerlink" title="常见流程"></a>常见流程</h2><p>在游戏中为了达到更真实的渲染结果 (常见于PBR)，因此先去除gamma矫正再对图像进行操作</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/gamma_00.png" alt="这里写图片描述"></p><h2 id="Unity中的设置"><a href="#Unity中的设置" class="headerlink" title="Unity中的设置"></a>Unity中的设置</h2><p>在unity中通过<strong>Edit-&gt;Project Settings-&gt;Player-&gt;Other Settings</strong>中可以直接设置在线性空间中进行</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/gamma2.png" alt=""></p><p>Unity默认对移动平台不支持线性空间。但可以在着色器里来做类似实现：对传进来的贴图做幂为2.2的pow()函数处理，然后在颜色返回值前做幂为0.45的pow()函数处理。这种实现有计算开销，<strong>不能滥用</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.kinematicsoup.com/news/2016/6/15/gamma-and-linear-space-what-they-are-how-they-differ">kinematicsoup</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Gamma和Linear&quot;&gt;&lt;a href=&quot;#Gamma和Linear&quot; class=&quot;headerlink&quot; title=&quot;Gamma和Linear&quot;&gt;&lt;/a&gt;Gamma和Linear&lt;/h1&gt;&lt;h2 id=&quot;线性空间&quot;&gt;&lt;a href=&quot;#线性空间&quot; cla
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>Thinfilm研究</title>
    <link href="https://crunchybiscuits.github.io/2021/05/06/Thinfilm%E7%A0%94%E7%A9%B6/"/>
    <id>https://crunchybiscuits.github.io/2021/05/06/Thinfilm%E7%A0%94%E7%A9%B6/</id>
    <published>2021-05-06T13:40:06.000Z</published>
    <updated>2021-05-11T04:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="薄膜干涉尝试记录"><a href="#薄膜干涉尝试记录" class="headerlink" title="薄膜干涉尝试记录"></a>薄膜干涉尝试记录</h1><p>实习需要用到薄膜干涉的效果，看到《王者荣耀》里，婉儿的皮肤，尝试用仅有的一点知识去模仿下(待继续优化)</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/thin_film02.png" alt=""></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>康康目前我能做什么</p><ol><li>在旋转模型的时候颜色会根据光照和视线的变换发生变化，因此需要注意法线和视线 — 菲涅尔现象，法线和光线对效果产生的影响。</li><li>基础的光照模型 — 反射相关</li></ol><h2 id="贴图"><a href="#贴图" class="headerlink" title="贴图"></a>贴图</h2><p>贴图有两张，一张是通过在ps里ramp得到的</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/thin_film03.png" alt=""></p><p>一张来自<a href="https://www.zhihu.com/question/34259470">中国科普博览</a></p><h2 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h2><p>在最简单的材质球上实现的时候，先看NdotV的变换，中间为1，边缘为0与NdotV相符</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/thin_film05.png" alt=""></p><p>接着添加一个贴图并通过NdotV进行采样，这个时候什么角度看都是一样的</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/thin_film06.png" alt=""></p><p>接着加入光的影响，可以看到有根据希望的方向进行变化，既会收到光的影响也会收到视线的影响(背光面会有分界)</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/thin_film07.png" alt=""></p><p>想到之前做过matcap的一个效果，首先尝试通过菲涅尔直接对贴图采样观察效果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">half NdotV = dot(normal_dir, view_dir * _Tile);</span><br><span class="line">half fresnel = <span class="number">1.0</span> - NdotV;</span><br><span class="line">half2 uv_thinfilm = half2(fresnel, <span class="number">0.5</span>);</span><br><span class="line">half4 matcap_color = tex2D(_ThinfilmTex, uv_thinfilm);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/thinfilm5.gif" alt=""></p><p>可以看到效果的变化很单一也并没有实现对应的要求，因此尝试根据薄膜干涉原理来达到效果，根据<a href="https://baijiahao.baidu.com/s?id=1687788042959363447&wfr=spider&for=pc">Thepoly</a>大佬这篇文章，思路主要是通过NdotV对灰度的影响进行变化，但是大佬在纹理采样的时候仍然用的是正常的uv值，因此做出来的效果并不是我的目标，因为我希望纹理能够根据视线和光线产生变化。为此进行如下的修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NdotV</span></span><br><span class="line">half NdotV =  dot(normal_dir, view_dir * _Tile);</span><br><span class="line"><span class="comment">// 蓝色</span></span><br><span class="line">half3 Mask01 = saturate(<span class="built_in">acos</span>(NdotV)*<span class="number">2</span>/UNITY_PI * half3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line"><span class="comment">// 蓝色和白色叉乘得到绿色，这里是为了拿到绿色通道 --- 可以手动计算下看结果，有saturate所以-1会修正</span></span><br><span class="line"><span class="comment">// --- 绿色和白色叉乘得到红色</span></span><br><span class="line"><span class="comment">// --- 红色和白色叉乘得到蓝色</span></span><br><span class="line">half3 CrossColor = cross (half3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>) , half3(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line"><span class="comment">// 绿色和红色</span></span><br><span class="line">half3 Mask02 = saturate (<span class="built_in">asin</span>(NdotV)*<span class="number">2</span>/UNITY_PI * CrossColor);</span><br><span class="line"><span class="comment">// 得到红，绿，蓝三色通道</span></span><br><span class="line">half3 AddMask = Mask01 + Mask02;</span><br><span class="line"><span class="comment">// 转灰度</span></span><br><span class="line">half Rgb2Gray = saturate(<span class="number">0.2989</span> * AddMask.r + <span class="number">0.587</span> * AddMask.g + <span class="number">0.114</span> * AddMask.b);</span><br><span class="line"><span class="comment">// 这里是修改的地方</span></span><br><span class="line">half4 col = tex2D(_BubbleTex, half2(NdotV,NdotL));</span><br></pre></td></tr></table></figure><p>把shader加到之前记录的实验模型里得到效果如下，感觉更近了一步</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/thinfilm2.gif" alt=""></p><p>接着可以看到，颜色只是很单纯的白色，需要加入衣服本身的颜色信息，所以通过灰度对原本衣服的颜色和薄膜干涉的颜色进行了插值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">half3 thin_film = lerp(col, base_color, Rgb2Gray);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/thinfilm3.gif" alt=""></p><p>目前的计算仍然是有些问题（但是感觉效果再调整一下可以用），灰度计算上通过cos直接对NdotV的值直接进行计算，按照<a href="https://zhuanlan.zhihu.com/p/47575695">天源</a>大佬的文章，需要加入弧度对薄膜干涉进行映射，因此做了如下两处的修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改前</span></span><br><span class="line">half3 Mask01 = saturate(<span class="built_in">cos</span>(NdotV) * half3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">...</span><br><span class="line">half3 Mask02 = saturate (<span class="built_in">sin</span>(NdotV) * CrossColor);</span><br><span class="line"><span class="comment">// 修改后</span></span><br><span class="line">half3 Mask01 = saturate(<span class="built_in">acos</span>(NdotV)*<span class="number">2</span>/UNITY_PI * half3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">...</span><br><span class="line">half3 Mask02 = saturate (<span class="built_in">asin</span>(NdotV)*<span class="number">2</span>/UNITY_PI * CrossColor);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/thinfilm4.gif" alt=""></p><p>最后换一套白色的贴图可以看到，发现对比度有点高</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/thin_film_00.png" alt=""></p><p>通过替换直接的叠加方式，换成one minus</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">half3 soft_thin_film = thin_film + base_color * (<span class="number">1</span>-thin_film);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/thin_film_01.png" alt=""></p><p>在婉儿的衣服上能够看到比较光滑的质感，因此通过matcap添加玻璃材质进行模拟, 这里把ramp贴图左右对调了一下，可惜衣服其他材质不太像</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">half3 normal_viewspace = mul(UNITY_MATRIX_V, float4(normal_dir, <span class="number">0.0</span>)).xyz;</span><br><span class="line">half2 uv_matcap = (normal_viewspace.xy + float2(<span class="number">1.0</span>, <span class="number">1.0</span>)) * <span class="number">0.5</span>;</span><br><span class="line">half4 matcap_color = tex2D(_MatcapBase, uv_matcap) * _MatIntensity;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/thinfilm6.gif" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://baijiahao.baidu.com/s?id=1687788042959363447&wfr=spider&for=pc">Thepoly</a></p><p><a href="https://zhuanlan.zhihu.com/p/47575695">天源</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;薄膜干涉尝试记录&quot;&gt;&lt;a href=&quot;#薄膜干涉尝试记录&quot; class=&quot;headerlink&quot; title=&quot;薄膜干涉尝试记录&quot;&gt;&lt;/a&gt;薄膜干涉尝试记录&lt;/h1&gt;&lt;p&gt;实习需要用到薄膜干涉的效果，看到《王者荣耀》里，婉儿的皮肤，尝试用仅有的一点知识去模仿下(待
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>简易各向异性</title>
    <link href="https://crunchybiscuits.github.io/2021/04/26/%E7%AE%80%E6%98%93%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7/"/>
    <id>https://crunchybiscuits.github.io/2021/04/26/%E7%AE%80%E6%98%93%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7/</id>
    <published>2021-04-26T13:59:40.000Z</published>
    <updated>2021-04-26T14:00:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="各向异性高光"><a href="#各向异性高光" class="headerlink" title="各向异性高光"></a>各向异性高光</h1><p>主要参考来自ATI Research Inc的《Hair Rendering and Shading》</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>各向异性表现：光打到物体表面会在不同的表面发散</p><p>可以分为两部分处理：</p><ul><li>发光方向的处理</li><li>拉丝感的处理</li></ul><h3 id="发光方向"><a href="#发光方向" class="headerlink" title="发光方向"></a>发光方向</h3><p>使用kajiya-kay模型，不再使用法线和半程向量dot(N,H)去计算高光，而是使用每根头发对应的tangent值和半程向量的sin值去计算：sin(T,H) = sqrt(1-dot(T,H) * dot(T,H))</p><p>H越接近横截面，越亮，sin的特性也是如此(越接近横截面的时候值越大)，因此用sin表示</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/kk_02.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 半程向量</span></span><br><span class="line">half3 half_dir = normalize(light_dir + view_dir);</span><br><span class="line"><span class="comment">// 计算TH点积，这里binormal的原因是unity中切线方向是u方向因此需要副法线</span></span><br><span class="line">half TdotH = dot(binormal_dir, half_dir);</span><br><span class="line"><span class="comment">// 计算Sin</span></span><br><span class="line">half SinTH = <span class="built_in">sqrt</span>(<span class="number">1</span>-TdotH * TdotH);</span><br><span class="line"><span class="comment">// 高光</span></span><br><span class="line">half3 spec = <span class="built_in">pow</span>(max(<span class="number">0.0</span>, SinTH),_Shineness) </span><br><span class="line">                    * _LightColor0.xyz * _SpecIntensity;</span><br></pre></td></tr></table></figure><h3 id="拉丝感"><a href="#拉丝感" class="headerlink" title="拉丝感"></a>拉丝感</h3><p>通过shift texture实现分为两个部分</p><ul><li>shift texture</li><li>noise texture</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/kk_03.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采样噪声图来获取拉丝感</span></span><br><span class="line">half uv_shift = i.uv * _ShiftMap_ST.xy + _ShiftMap_ST.zw;</span><br><span class="line">half shiftNoise = tex2D(_ShiftMap, uv_shift).r;</span><br><span class="line"><span class="comment">// 为噪声添加强度</span></span><br><span class="line">shiftNoise = shiftNoise * _NoiseIntensity;</span><br><span class="line"><span class="comment">// 为副切线添加偏移(控制高光的位置)</span></span><br><span class="line">half3 b_offset = normal_dir * (_ShiftOffset + shiftNoise);</span><br><span class="line"><span class="comment">// 获取更新后的副法线</span></span><br><span class="line">binormal_dir = normalize(binormal_dir + b_offset);</span><br></pre></td></tr></table></figure><h2 id="金属"><a href="#金属" class="headerlink" title="金属"></a>金属</h2><p>金属的拉丝感需要通过贴图进行整理，思路类似凹凸贴图的使用，从贴图获取切线以及副切线的信息，对原本的副切线进行修改</p><p>颜色设置如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/kk_05.png" alt=""></p><p>PS中制作的贴图如下：</p><ol><li>r通道存储横向渐变</li><li>g通道存储纵向渐变</li><li>b通道存储拉丝的噪声</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/kk_06.png" alt=""></p><p>通过采样制作的贴图对binormal进行修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取贴图数据</span></span><br><span class="line">half3 noise_data = tex2D(_FlowMap, i.uv).rgb;</span><br><span class="line"><span class="comment">// 获取噪声数据</span></span><br><span class="line">half shiftNoise = noise_data.b * <span class="number">2.0</span> - <span class="number">1.0</span>;</span><br><span class="line"><span class="comment">// 获取切线以及副切线方向修改信息</span></span><br><span class="line">half2 noise_dir= noise_data.rg * <span class="number">2.0</span> - <span class="number">1.0</span>;</span><br><span class="line"><span class="comment">// 修改副切线</span></span><br><span class="line">binormal_dir = normalize(tangent_dir * noise_dir.x + binormal_dir * noise_dir.y);</span><br></pre></td></tr></table></figure><p>修改后效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/kk_04.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;各向异性高光&quot;&gt;&lt;a href=&quot;#各向异性高光&quot; class=&quot;headerlink&quot; title=&quot;各向异性高光&quot;&gt;&lt;/a&gt;各向异性高光&lt;/h1&gt;&lt;p&gt;主要参考来自ATI Research Inc的《Hair Rendering and Shading》&lt;/p
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>Billboarding</title>
    <link href="https://crunchybiscuits.github.io/2021/04/25/Billboarding/"/>
    <id>https://crunchybiscuits.github.io/2021/04/25/Billboarding/</id>
    <published>2021-04-25T13:23:56.000Z</published>
    <updated>2021-04-25T14:16:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Billboarding"><a href="#Billboarding" class="headerlink" title="Billboarding"></a>Billboarding</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Billboarding通常会根据需求来旋转一个被纹理着色的多边形，本质上是构建一个旋转矩阵，通常是基于法线或者基于向上的方向，还需要设定锚点来确定多边形在空间中的位置。</p><p>难点在于法线和向上的方向常常不是垂直的，需要构建的矩阵由法线方向(normal)，向上的方向(up)和向右的方向(right)组成</p><blockquote><ol><li>right = normal x up</li><li>up’ = normal x right</li></ol></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/billboarding_00.jpg" alt=""></p><p>如图，通过视线作为一个轴，获取设定好的向上方向之后，获取向右的方向，因为向上的向量恒定不变，因此叉乘出来的向右向量由视线决定，在更新了向右向量之后再反过来影响向上的向量。(图片来自shader入门精要)</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>参考《Unity Shader入门精要》</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">v2f <span class="title function_">vert</span> <span class="params">(appdata v)</span>&#123;</span><br><span class="line">v2f o;</span><br><span class="line"><span class="comment">// 设置模型空间中原点</span></span><br><span class="line">float3 center = float3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 模型空间中的视线</span></span><br><span class="line">half3 view_model = mul(unity_WorldToObject, float4(_WorldSpaceCameraPos, <span class="number">1</span>));</span><br><span class="line"><span class="comment">// 确定法线</span></span><br><span class="line">half3 normal_dir = view_model - center;</span><br><span class="line">        <span class="comment">// 加上法线和向上向量权重</span></span><br><span class="line">normal_dir.y = normal_dir.y * _VerticalBillboarding;</span><br><span class="line">normal_dir = normalize(normal_dir);</span><br><span class="line"><span class="comment">// 如果法线已经是向上的了，那么up就设置为向右, 防止叉乘中的平行</span></span><br><span class="line">half3 up_dir = <span class="built_in">abs</span>(normal_dir.y)&gt;<span class="number">0.999</span>?half3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>):half3(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 构建向右和新的向上向量</span></span><br><span class="line">half3 right_dir = normalize(cross(up_dir, normal_dir));</span><br><span class="line">up_dir = normalize(cross(normal_dir, right_dir));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算偏移，重新得到新的顶点位置</span></span><br><span class="line">half3 centerOffs = v.vertex.xyz - center;</span><br><span class="line">float3 localPos = center + right_dir * centerOffs.x + up_dir * centerOffs.y + normal_dir * centerOffs.z;</span><br><span class="line">o.pos = UnityObjectToClipPos(float4(localPos, <span class="number">1</span>));</span><br><span class="line">o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixed4 <span class="title function_">frag</span> <span class="params">(v2f i)</span> : SV_Target&#123;</span><br><span class="line">fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">col.rgb = _Color.rgb * col.rgb;</span><br><span class="line"><span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/billboarding_01.jpg" alt=""></p><p>图中是向上向量和视线向量分别来作为恒定轴时候的效果(图片来自shader入门精要)</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>如果单纯只是想实现一直朝向的效果，那么可以进行如下优化，因为本质上是通过构建旋转矩阵追踪视角变换的朝向，并将朝向的变换应用到物体上，那么反过来想，抵消掉物体朝向的变换也是可以的，因此通过mv矩阵的逆可以实现同样的保存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">v2f <span class="title function_">vert</span> <span class="params">(appdata v)</span></span><br><span class="line">&#123;</span><br><span class="line">v2f o;</span><br><span class="line"><span class="comment">// 计算偏移，重新得到新的顶点位置</span></span><br><span class="line">float3 localPos = mul(UNITY_MATRIX_T_MV, v.vertex.xyz);</span><br><span class="line">o.pos = UnityObjectToClipPos(float4(localPos, <span class="number">1</span>));</span><br><span class="line">o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line">fixed4 <span class="title function_">frag</span> <span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">col.rgb = _Color.rgb * col.rgb * _Intensity;</span><br><span class="line"><span class="keyword">return</span> col;</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/billboarding.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Billboarding&quot;&gt;&lt;a href=&quot;#Billboarding&quot; class=&quot;headerlink&quot; title=&quot;Billboarding&quot;&gt;&lt;/a&gt;Billboarding&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>GAMES202-作业1-part2</title>
    <link href="https://crunchybiscuits.github.io/2021/04/20/GAMES202-%E4%BD%9C%E4%B8%9A1-part2/"/>
    <id>https://crunchybiscuits.github.io/2021/04/20/GAMES202-%E4%BD%9C%E4%B8%9A1-part2/</id>
    <published>2021-04-20T13:48:18.000Z</published>
    <updated>2021-04-21T14:12:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GAMES202-作业1-part2"><a href="#GAMES202-作业1-part2" class="headerlink" title="GAMES202 作业1-part2"></a>GAMES202 作业1-part2</h1><p>应老师要求不会直接放上作业答案，会记录整体思路和核心代码</p><h2 id="PCF"><a href="#PCF" class="headerlink" title="PCF"></a>PCF</h2><p>主要步骤</p><ol><li>获取shadow map和对应的坐标</li><li>设置filter和随机采样的数目</li><li>使用泊松分布采样</li><li>判断每个采样点的shadow map值</li><li>进行累加求平均</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改了老师给的函数的签名，新增了一个参数，其实按照pdf的说明，加了这个参数才比较合理</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">PCF</span><span class="params">(sampler2D shadowMap, vec4 coords, <span class="type">float</span> filter_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filter_size是根据图片大小来的，这里是1.0/2048.0，可以根据实际需求乘以2.0-10.0</span></span><br><span class="line"><span class="comment">// 随机采样的样本数目是通过glsl文件开头的NUM_SAMPLES进行修改的</span></span><br></pre></td></tr></table></figure><p>接着使用泊松分布</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泊松分布采样，采样输出的范围会很大很可能覆盖整张图</span></span><br><span class="line">poissonDiskSamples(coords.xy);</span><br></pre></td></tr></table></figure><p>然后通过每个对采样点进行判断累加结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; PCF_NUM_SAMPLES; i++)&#123;</span><br><span class="line">    <span class="comment">// 因为shadowmap和归一化之后的坐标都是在[0,1]之前，因此需要filter_size对泊松分布的输出进行   // 缩小，不然会出现全屏黑点的效果</span></span><br><span class="line">    vec2 temp = poissonDisk[i] * filter_size + coords.xy;</span><br><span class="line">    <span class="type">float</span> depth_decode = (unpack(texture2D(shadowMap, temp)));</span><br><span class="line">    <span class="keyword">if</span>(depth_decode&gt;coords.z - bias)</span><br><span class="line">depth_sum += <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">      depth_sum += <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到效果如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/GAMES202hw1_03.png" alt=""></p><h2 id="PCSS"><a href="#PCSS" class="headerlink" title="PCSS"></a>PCSS</h2><p>PCSS主要步骤：</p><ol><li>blocker search<ol><li>进行泊松分布采样</li><li>和当前uv的深度进行对比、</li><li>判断是否有遮挡</li></ol></li><li>计算比值</li><li>通过PCF创建软阴影</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// blocker search核心的思路</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NUM_SAMPLES; i ++)&#123;</span><br><span class="line">  vec2 simpleUV = uv +poissonDisk[i] * (zReceiver<span class="number">-0.01</span>)/zReceiver;</span><br><span class="line">  <span class="type">float</span> shadowMapDepth = unpack(texture2D(uShadowMap,simpleUV));</span><br><span class="line">  <span class="keyword">if</span>(zReceiver &gt; (shadowMapDepth+EPS))&#123;</span><br><span class="line">    average_depth += shadowMapDepth;</span><br><span class="line">    count +=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有遮挡，但是想让效果看着柔和些</span></span><br><span class="line"><span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0.3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">average_depth /= <span class="type">float</span>(count);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PCSS函数</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">PCSS</span><span class="params">(sampler2D shadowMap, vec4 coords)</span>&#123;</span><br><span class="line">  <span class="comment">// STEP 1: avgblocker depth</span></span><br><span class="line">  <span class="type">float</span> blocker_depth = findBlocker(shadowMap, coords.xy, coords.z);</span><br><span class="line">  <span class="comment">// STEP 2: penumbra size</span></span><br><span class="line">  <span class="type">float</span> penumbra = (coords.z-blocker_depth)*LIGHT_WIDTH/blocker_depth;</span><br><span class="line">  <span class="comment">// STEP 3: filtering</span></span><br><span class="line">  <span class="keyword">return</span> PCF(shadowMap, coords, <span class="number">1.0</span>/<span class="number">2048.0</span> * <span class="number">5.0</span>  * penumbra);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/GAMES202hw1_04.png" alt=""></p><h2 id="优化效果"><a href="#优化效果" class="headerlink" title="优化效果"></a>优化效果</h2><p>开始的时候PCF和PCSS效果如下，可以看得出特别糊</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/GAMES202hw1_07.png" alt=""></p><p>通过修改NUM_SAMPLES进行优化，从20调到了60</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/GAMES202hw1_08.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GAMES202-作业1-part2&quot;&gt;&lt;a href=&quot;#GAMES202-作业1-part2&quot; class=&quot;headerlink&quot; title=&quot;GAMES202 作业1-part2&quot;&gt;&lt;/a&gt;GAMES202 作业1-part2&lt;/h1&gt;&lt;p&gt;应老师要求不
      
    
    </summary>
    
    
    
      <category term="GAMES202" scheme="https://crunchybiscuits.github.io/tags/GAMES202/"/>
    
  </entry>
  
  <entry>
    <title>GAMES202-作业1-part1</title>
    <link href="https://crunchybiscuits.github.io/2021/04/12/GAMES202-%E4%BD%9C%E4%B8%9A1-part1/"/>
    <id>https://crunchybiscuits.github.io/2021/04/12/GAMES202-%E4%BD%9C%E4%B8%9A1-part1/</id>
    <published>2021-04-12T13:35:55.000Z</published>
    <updated>2021-04-21T13:04:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GAMES202-作业1-part1"><a href="#GAMES202-作业1-part1" class="headerlink" title="GAMES202 作业1-part1"></a>GAMES202 作业1-part1</h1><p>应老师要求不会直接放上作业答案，会记录整体思路</p><h2 id="Two-Pass-Shadowmap"><a href="#Two-Pass-Shadowmap" class="headerlink" title="Two Pass Shadowmap"></a>Two Pass Shadowmap</h2><p>主要实现硬阴影，在shadowmap作业中需要修改的地方有两个</p><h3 id="DirectionalLight-js中CalcLightMVP-函数"><a href="#DirectionalLight-js中CalcLightMVP-函数" class="headerlink" title="DirectionalLight.js中CalcLightMVP()函数"></a>DirectionalLight.js中CalcLightMVP()函数</h3><p>MVP函数的参数签名如下</p><p>CalcLightMVP(translate, scale){}</p><p>首先需要做的是根据translate和scale进行model transform</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要使用的两个函数</span></span><br><span class="line"><span class="comment">// scale中a表示变换完之后存储的地方,b表示原矩阵,c表示变换</span></span><br><span class="line">mat4.<span class="title function_">scale</span>(a, b, c);</span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">mat4.<span class="title function_">scale</span>(modelMatrix, modelMatrix, scale);</span><br><span class="line"><span class="comment">// translate同理</span></span><br><span class="line">mat4.<span class="title function_">translate</span>(a, b, c);</span><br></pre></td></tr></table></figure><p>接着是view transform，这里是根据提供的lightPos，focalPoint和lightUp进行lookat矩阵的构造</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lookAt函数</span></span><br><span class="line"><span class="comment">// a - 存储结果</span></span><br><span class="line"><span class="comment">// b - light position</span></span><br><span class="line"><span class="comment">// c - focal point</span></span><br><span class="line"><span class="comment">// d - light up</span></span><br><span class="line">mat4.<span class="title function_">lookAt</span>(a,b,c,d);</span><br></pre></td></tr></table></figure><p>最后是投影矩阵，根据作业提示推荐使用了正交投影</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 投影矩阵设置</span></span><br><span class="line"><span class="comment">// a - 存储结果</span></span><br><span class="line"><span class="comment">// l, r - 控制矩阵左右</span></span><br><span class="line"><span class="comment">// b, t - 控制上下</span></span><br><span class="line"><span class="comment">// n, f - 控制远近</span></span><br><span class="line">mat4.<span class="title function_">ortho</span>(a,l,r,b,t,n,f);</span><br></pre></td></tr></table></figure><h3 id="phongFragment-glsl中useShadowMap-函数"><a href="#phongFragment-glsl中useShadowMap-函数" class="headerlink" title="phongFragment.glsl中useShadowMap()函数"></a>phongFragment.glsl中useShadowMap()函数</h3><p>首先通过shadowCoord获取坐标并通过texture2D()进行采样</p><p><code>vec4 depth_raw =texture2D(shadowMap,shadowCoord.xy);</code></p><p>接着通过unpack函数对depth进行decode</p><p><code>float depth_decode =unpack(depth_raw);</code></p><p>然后通过跟shadowCoord.z的值进行深度比较得到阴影</p><p><code>if(depth_decode &gt; shadowCoord.z)</code></p><p>在main中对坐标进行NDC操作并传入函数，得到结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// NDC</span></span><br><span class="line">vec3 projCoords = vPositionFromLight.xyz / vPositionFromLight.w;</span><br><span class="line"> <span class="comment">// 范围从[-1,1]转到[0,1]</span></span><br><span class="line">vec3 shadowCoord = projCoords * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line"> visibility = useShadowMap(uShadowMap, vec4(shadowCoord, <span class="number">1.0</span>));</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/GAMES202hw1_00.png" alt=""></p><p>出现如下错误原因是model transform顺序设置问题，本来操作应该是先缩放，再旋转，最后平移。但是这里是先translate，再scale(原因是将光源当作相机生成深度图，但是变换的时候本来思路是从原点变换到光源位置，但是在view transform的思路是逆变换，因此需要反过来) — 这里可能理解有误，mark一下，因为和朋友直接手写变换矩阵的时候按照SRT的顺序是对的</p><p>修改后如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/GAMES202hw1_01.png" alt=""></p><p>另一个需要优化的地方是阴影周围的锯齿，通过添加bias的方法，可以让整个阴影更加平滑。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/GAMES202hw1_05.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">getBias</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">// 解决自遮挡问题 -- 主要由shadow map精度导致</span></span><br><span class="line">  <span class="comment">// 第一个pass在渲染shadow map的时候会将场景离散化，但是shadow map精度有限因此记录不会很准去，</span></span><br><span class="line">  <span class="comment">// 在第二个pass进行判断的时候，就可能会有多个fragment对应到shadow map的同一个位置</span></span><br><span class="line">  vec3 lightDir = normalize(uLightPos);</span><br><span class="line">  vec3 normal = normalize(vNormal);</span><br><span class="line">  <span class="type">float</span> bias = max( <span class="number">0.003</span> *(<span class="number">1.0</span> - dot(normal, lightDir)), <span class="number">0.0003</span>);</span><br><span class="line">  <span class="keyword">return</span>  bias;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/GAMES202hw1_06.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GAMES202-作业1-part1&quot;&gt;&lt;a href=&quot;#GAMES202-作业1-part1&quot; class=&quot;headerlink&quot; title=&quot;GAMES202 作业1-part1&quot;&gt;&lt;/a&gt;GAMES202 作业1-part1&lt;/h1&gt;&lt;p&gt;应老师要求不
      
    
    </summary>
    
    
    
      <category term="GAMES202" scheme="https://crunchybiscuits.github.io/tags/GAMES202/"/>
    
  </entry>
  
  <entry>
    <title>光照模型和法线贴图(悲惨调试经历)</title>
    <link href="https://crunchybiscuits.github.io/2021/04/08/%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE-%E6%82%B2%E6%83%A8%E8%B0%83%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    <id>https://crunchybiscuits.github.io/2021/04/08/%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE-%E6%82%B2%E6%83%A8%E8%B0%83%E8%AF%95%E7%BB%8F%E5%8E%86/</id>
    <published>2021-04-08T14:04:25.000Z</published>
    <updated>2021-04-09T15:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>实习的悲惨事故，主要在两个细小得错误上花费了特别多的时间，两个都是出在宏定义的地方，先把这个东西高高挂起</p><p><strong>#pragma multi_compile_fwdadd</strong></p><p>写成了multi_comple_fwdadd，导致在写多光源部分找了很久没找到问题，一直以为是代码逻辑出错</p><h2 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h2><p>光照计算的思考方式</p><ol><li>光源</li><li>模型表面材质结构</li><li>观察方向</li></ol><h3 id="光源"><a href="#光源" class="headerlink" title="光源"></a>光源</h3><ol><li>光源类型<ol><li>聚光灯和点光有衰减</li><li>光源方向</li><li>光源颜色</li></ol></li><li>灯光数据传递方式—RenderPath<ol><li>Forward 前向渲染<ol><li>Unity内置渲染管线Built-in</li><li>Unity URP渲染管线<ol><li>光照方面，能够在单个pass处理多个灯光</li></ol></li></ol></li><li>Deferred 延迟渲染：以灯光为单位进行渲染，因为使用了MRT<ol><li>UE4默认路径</li><li>Unity UDRP渲染管线</li></ol></li></ol></li></ol><h3 id="RenderPath"><a href="#RenderPath" class="headerlink" title="RenderPath"></a>RenderPath</h3><p>决定了shader是以怎样的一个规则去计算灯光的</p><ul><li><p>前向渲染：unity内置的渲染管线， unity URP渲染管线</p></li><li><p>延迟渲染：UE4默认渲染路径， Unity HDRP渲染管线</p></li></ul><h4 id="前向渲染：物体被重复叠加绘制多次（实时灯光的数量）"><a href="#前向渲染：物体被重复叠加绘制多次（实时灯光的数量）" class="headerlink" title="前向渲染：物体被重复叠加绘制多次（实时灯光的数量）"></a>前向渲染：物体被重复叠加绘制多次（实时灯光的数量）</h4><p>forwardadd函数</p><p>前向渲染的消耗问题，引擎edit -&gt; project setting -&gt; quality -&gt; pixel light count，不调整会出现粗糙灯光</p><p>超过了light count的灯光，就会被当作顶点光源，只能在顶点shader里进行计算</p><p>需要shader里面写两个pass：</p><ol><li>forward base：主方向光，也处理超出数量的顶点灯光</li><li>forward pass：结果通过 blend one one的方式进行叠加</li></ol><h4 id="延迟渲染："><a href="#延迟渲染：" class="headerlink" title="延迟渲染："></a>延迟渲染：</h4><p>主要两个阶段</p><ol><li>RenderDeferred gbuffer<br>这里使用了MRT — Multi Render Target<br>RT0 diffuse<br>RT1 金属度<br>RT2 法线数据<br>Depth 深度</li><li>RenderDeferred lighting<br>以灯光为单位对场景进行渲染，因为把需要的信息已经提前渲染好了 </li></ol><p><strong>延迟渲染对多光源友好，有一定使用瓶颈，占用带宽高，普通机型可能受不了，前向渲染就很轻量化</strong></p><p><strong>怎么判断是否是主方向光 — 光的亮度最大那个</strong></p><h3 id="模型表面材质结构"><a href="#模型表面材质结构" class="headerlink" title="模型表面材质结构"></a>模型表面材质结构</h3><ol><li>顶点法线</li><li>法线贴图</li><li>光滑度</li><li>PBR理论框架</li></ol><h3 id="多光源的实现"><a href="#多光源的实现" class="headerlink" title="多光源的实现"></a>多光源的实现</h3><p>通过forwardadd pass实现</p><p>第二个pass修改地方</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tags&#123;<span class="string">&quot;LightMode&quot;</span>=<span class="string">&quot;ForwardAdd&quot;</span>&#125;</span><br><span class="line">Blend One One</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdadd</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br></pre></td></tr></table></figure><p><strong>衰减的计算</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(DIRECTIONAL)</span></span><br><span class="line"><span class="comment">// 平行光</span></span><br><span class="line">half3 light_dir = _WorldSpaceLightPos0.xyz;</span><br><span class="line">half attuenation = <span class="number">1.0</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(POINT)</span></span><br><span class="line"><span class="comment">// 点光</span></span><br><span class="line">half3 light_dir = normalize(_WorldSpaceLightPos0.xyz - i.pos_world);</span><br><span class="line"><span class="comment">// 衰减范围计算</span></span><br><span class="line">half distance = length(_WorldSpaceLightPos0.xyz - i.pos_world);</span><br><span class="line">half range = <span class="number">1.0</span> / unity_WorldToLight[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">half attuenation = saturate((range - distance)/range);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h2><p>思路：</p><ol><li><p>切线是在模型导入的时候确定的，根据UV中U方向走向定义的</p></li><li><p>再通过法线和切线cross得到副切线，就构成了切线空间</p></li></ol><p><strong>在shader中关键点在tangent.w分量的处理，主要是用来处理不同平台法线反转的问题</strong></p><p>压缩格式问题：PC上DXT/BC对法线贴图压缩，这样通道信息就会变更，只剩红色通道和alpha通道(所以红色不一定是错的)</p><p>在shader还需要解码操作，因为法线贴图范围是[0,1]，但是法线数据需要[-1,1]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vert(appdata v)&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    o.normal_dir = normalize(mul(float4(v.normal, <span class="number">0.0</span>),unity_WorldToObject).xyz);</span><br><span class="line">o.pos_world = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">o.tangent_dir = normalize(mul(unity_ObjectToWorld, float4(v.tangent.xyz,<span class="number">0.0</span>)).xyz);</span><br><span class="line">o.binormal_dir = normalize(cross(o.normal_dir, o.tangent_dir)) * v.tangent.w;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">frag(v2f i):SV_TARGET&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">half4 normalmap = tex2D(_NormalMap, i.uv);</span><br><span class="line">half3 normal_data = UnpackNormal(normalmap);</span><br><span class="line"></span><br><span class="line"><span class="comment">// normalmap</span></span><br><span class="line">half3 normal_dir =  normalize(i.normal_dir);</span><br><span class="line">half3 tangent_dir = normalize(i.tangent_dir);</span><br><span class="line">half3 binormal_dir = normalize(i.binormal_dir);</span><br><span class="line"></span><br><span class="line">normal_dir = normalize(tangent_dir * normal_data.x + binormal_dir * normal_data.y + normal_dir * normal_data.z);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="blinn-phong"><a href="#blinn-phong" class="headerlink" title="blinn-phong"></a>blinn-phong</h3><p>在phong上进行了优化，使用了半程向量</p><p>半程向量是光照和视线方向的中间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">half3 half_dir = normalize(light_dir + view_dir);</span><br><span class="line">half NdotH = dot(normalize_dir, half_dir);</span><br></pre></td></tr></table></figure><p>显示器的输出结果是在0-1的，但是shader的返回值可以很大，因此会有过曝</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实习的悲惨事故，主要在两个细小得错误上花费了特别多的时间，两个都是出在宏定义的地方，先把这个东西高高挂起&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#pragma multi_compile_fwdadd&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;写成了multi_comple_fwdadd，导
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>GAMES202-Lecture3笔记</title>
    <link href="https://crunchybiscuits.github.io/2021/04/06/GAMES202-Lecture3%E7%AC%94%E8%AE%B0/"/>
    <id>https://crunchybiscuits.github.io/2021/04/06/GAMES202-Lecture3%E7%AC%94%E8%AE%B0/</id>
    <published>2021-04-06T12:22:06.000Z</published>
    <updated>2021-04-20T13:32:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GAMES202-Lecture3"><a href="#GAMES202-Lecture3" class="headerlink" title="GAMES202-Lecture3"></a>GAMES202-Lecture3</h1><p>实时阴影</p><h2 id="Shadow-Mapping"><a href="#Shadow-Mapping" class="headerlink" title="Shadow Mapping"></a>Shadow Mapping</h2><p>特点：</p><ol><li>2个Pass的算法<ol><li>light pass生成shadow map</li><li>camera pass使用shadow map</li></ol></li><li>是图像空间的算法，当shadow map已经生成，那么就不需要实际的场景中的物体，直接使用shadow map就可以计算阴影</li><li>坏处：<ol><li>自遮挡现象</li><li>走样的问题</li></ol></li></ol><p>过程：</p><ul><li>pass1: 从光源方向渲染，只需要一个深度的信息</li><li>pass2: 从相机方向开始渲染</li><li>和光源方向的开始比较，如果点和相机方向的相同，那么就是能被光找到，如果不行那么就是在阴影中，用z值还是实际距离都行，但是要保持一致。</li></ul><h3 id="自遮挡问题"><a href="#自遮挡问题" class="headerlink" title="自遮挡问题"></a>自遮挡问题</h3><p>shadow map记录的是不连续的，因此会出现阴影和物体断开的现象，可以通过添加一个bias来减少自遮挡问题 — 当光源和平面夹角越大，那么bias越大(会导致阴影的断开)，bias的大小也会影响阴影的质量</p><p>second-depth shadow mapping:</p><ol><li>不仅存最小深度，还存次小的深度，之后用这两个深度取一个中间值</li><li>但是工业界不用</li></ol><h3 id="走样问题"><a href="#走样问题" class="headerlink" title="走样问题"></a>走样问题</h3><p>渲染的时候分辨率不够大</p><h2 id="shadow-mapping背后数学原理"><a href="#shadow-mapping背后数学原理" class="headerlink" title="shadow mapping背后数学原理"></a>shadow mapping背后数学原理</h2><p><strong>在实时渲染中关心近似相等，将不等式当作约等式使用</strong><br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/202-lecture3-00.jpg" alt=""></p><ol><li>约等式是把乘积的积分拆成了积分的乘积(数学意义上是不精确的)</li><li>分母是归一化的常数</li><li>什么时候是准确的(两个有一个就行)？<ol><li>当g的积分范围特别小的时候</li><li>g在足够光滑的时候</li></ol></li></ol><p>约等式用法：<br>将渲染方程拆成了，shading和visibility两部分<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/202-lecture3-01.jpg" alt=""></p><ol><li>g积分范围小的情形: 对于点光源和方向光源就特别精确</li><li>smooth的情形: 当光源是正常的面光源，shading point是diffuse的情况下 — 51min</li></ol><h2 id="Percentage-Closer-Soft-Shadows（PCSS）–-55min"><a href="#Percentage-Closer-Soft-Shadows（PCSS）–-55min" class="headerlink" title="Percentage Closer Soft Shadows（PCSS）– 55min"></a>Percentage Closer Soft Shadows（PCSS）– 55min</h2><p>使用理由，从硬阴影到软阴影，因为日常生活中，绝大多数情况是面光源</p><h3 id="Percentage-Closer-Filtering-PCF"><a href="#Percentage-Closer-Filtering-PCF" class="headerlink" title="Percentage Closer Filtering(PCF)"></a>Percentage Closer Filtering(PCF)</h3><ol><li>主要用来做anti-aliasing的，本质上是求平均 – 类似卷积(在那个点找一圈像素)，<strong>在做阴影判断的时候使用Filtering</strong>。</li><li>但是开销很大，从检查一次变成7*7或者9*9</li><li>主要步骤<ol><li>获取shadow map和对应的坐标</li><li>设置filter和随机采样的数目</li><li>判断每个采样点的shadow map值</li><li>进行累加求平均</li></ol></li></ol><h3 id="PCSS-–-70min"><a href="#PCSS-–-70min" class="headerlink" title="PCSS – 70min"></a>PCSS – 70min</h3><ol><li>PCF的使用 — 使用PCF将filter size调大，硬阴影就会变soft</li><li>阴影接受物到阴影投射物的远近程度(blocker distance)，决定阴影的软硬，因此不同位置，不同的filter size<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/202-lecture3-02.jpg" alt=""></li><li>如何确定filter size – 74min<ol><li>对一个shading point来说要看有多少像素能挡住它的，这些像素的平均值就是average blocker depth</li><li>如何决定blocker search的范围 — 77min<ol><li>离光源的距离</li><li>光源大小<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/202-lecture3-03.jpg" alt=""></li></ol></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GAMES202-Lecture3&quot;&gt;&lt;a href=&quot;#GAMES202-Lecture3&quot; class=&quot;headerlink&quot; title=&quot;GAMES202-Lecture3&quot;&gt;&lt;/a&gt;GAMES202-Lecture3&lt;/h1&gt;&lt;p&gt;实时阴影&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
    
      <category term="GAMES202" scheme="https://crunchybiscuits.github.io/tags/GAMES202/"/>
    
  </entry>
  
  <entry>
    <title>模糊算法</title>
    <link href="https://crunchybiscuits.github.io/2021/04/05/%E6%A8%A1%E7%B3%8A%E7%AE%97%E6%B3%95/"/>
    <id>https://crunchybiscuits.github.io/2021/04/05/%E6%A8%A1%E7%B3%8A%E7%AE%97%E6%B3%95/</id>
    <published>2021-04-05T04:27:00.000Z</published>
    <updated>2021-04-05T10:13:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模糊算法"><a href="#模糊算法" class="headerlink" title="模糊算法"></a>模糊算法</h1><p>大部分模糊算法参考在<a href="https://zhuanlan.zhihu.com/p/125744132">这里</a></p><h2 id="均值模糊"><a href="#均值模糊" class="headerlink" title="均值模糊"></a>均值模糊</h2><p>原理：通过卷积核对周围的像素进行平均，所有权重都是一样的</p><figure class="highlight plaintext"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 这个是内置变量，x = 1/width, y = 1/height, z = width, w = height</span><br><span class="line">// 这样x，y就能代表偏移值</span><br><span class="line">float4 _MainTex_TexelSize;</span><br></pre></td></tr></table></figure><p>2 * 2均值模糊，其他模糊以此类推</p><figure class="highlight plaintext"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 2*2 均值模糊</span><br><span class="line">half4 d = _MainTex_TexelSize.xyxy * half4(-1,-1,1,1) * _BlurOffset;</span><br><span class="line">half4 s= 0;</span><br><span class="line">s += tex2D(_MainTex, i.uv + d.zw);</span><br><span class="line">s += tex2D(_MainTex, i.uv + d.zx);</span><br><span class="line">s += tex2D(_MainTex, i.uv + d.xz);</span><br><span class="line">s += tex2D(_MainTex, i.uv + d.xy);</span><br><span class="line">s *= 0.25;</span><br></pre></td></tr></table></figure><p>可通过在C#脚本中可以提高迭代次数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Graphics.Blit(source, rt1, material);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i =<span class="number">0</span>;i&lt;_Interation;i++)&#123;</span><br><span class="line">Graphics.Blit(rt1,rt2,material);</span><br><span class="line">       Graphics.Blit(rt2,rt1,material);</span><br><span class="line">   &#125;</span><br><span class="line">       </span><br><span class="line">   Graphics.Blit(rt1, destination, material);</span><br></pre></td></tr></table></figure><h2 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h2><p>原理：同均值模糊，但是权重从中心往边缘呈高斯分布</p><p>优化后的高斯模糊 —&gt; 直接使用5<em>5高斯核会很浪费，转换成两次1\</em>5的操作，一次横向，一次纵向</p><p>因为已经有权重所以不用最后再除了</p><figure class="highlight plaintext"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 水平方向</span><br><span class="line">    half4 frag_HorizontalBlur (v2f_img i) : SV_Target&#123;</span><br><span class="line">        half4 d = _BlurOffset.xyxy * half4(-1,-1,1,1);</span><br><span class="line">        half2 uv1 = i.uv + _BlurOffset*half2(1,0)*-2.0;</span><br><span class="line">        half2 uv2 = i.uv + _BlurOffset*half2(1,0)*-1.0;</span><br><span class="line">        half2 uv3 = i.uv;</span><br><span class="line">        half2 uv4 = i.uv + _BlurOffset*half2(1,0);</span><br><span class="line">        half2 uv5 = i.uv + _BlurOffset*half2(1,0)*2.0;</span><br><span class="line"></span><br><span class="line">        half4 s= 0;</span><br><span class="line">        s += tex2D(_MainTex, uv1) * 0.05;</span><br><span class="line">        s += tex2D(_MainTex, uv2) * 0.25;</span><br><span class="line">        s += tex2D(_MainTex, uv3) * 0.4;</span><br><span class="line">        s += tex2D(_MainTex, uv4) * 0.25;</span><br><span class="line">        s += tex2D(_MainTex, uv5) * 0.05;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="双重模糊"><a href="#双重模糊" class="headerlink" title="双重模糊"></a>双重模糊</h2><p>先降采样，再升采样</p><p>shader层面不用修改</p><p>C#中在迭代过程中降低和增加图片大小</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 降采样</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i =<span class="number">0</span>;i&lt;_Interation;i++)&#123;</span><br><span class="line">    <span class="comment">// 水平方向</span></span><br><span class="line">    RenderTexture.ReleaseTemporary(rt2);</span><br><span class="line">    width /= <span class="number">2</span>;</span><br><span class="line">    height /= <span class="number">2</span>;</span><br><span class="line">    rt2 = RenderTexture.GetTemporary(width,height);</span><br><span class="line">    Graphics.Blit(rt1,rt2,material,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 垂直方向</span></span><br><span class="line">    RenderTexture.ReleaseTemporary(rt1);</span><br><span class="line">    width /= <span class="number">2</span>;</span><br><span class="line">    height /= <span class="number">2</span>;</span><br><span class="line">    rt1 = RenderTexture.GetTemporary(width,height);</span><br><span class="line">    Graphics.Blit(rt2,rt1,material,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 升采样 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i =<span class="number">0</span>;i&lt;_Interation;i++)&#123;</span><br><span class="line">    <span class="comment">// 水平方向</span></span><br><span class="line">    RenderTexture.ReleaseTemporary(rt2);</span><br><span class="line">    width *= <span class="number">2</span>;</span><br><span class="line">    height *= <span class="number">2</span>;</span><br><span class="line">    rt2 = RenderTexture.GetTemporary(width,height);</span><br><span class="line">    Graphics.Blit(rt1,rt2,material,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 垂直方向</span></span><br><span class="line">    RenderTexture.ReleaseTemporary(rt1);</span><br><span class="line">    width *= <span class="number">2</span>;</span><br><span class="line">    height *= <span class="number">2</span>;</span><br><span class="line">    rt1 = RenderTexture.GetTemporary(width,height);</span><br><span class="line">    Graphics.Blit(rt2,rt1,material,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;模糊算法&quot;&gt;&lt;a href=&quot;#模糊算法&quot; class=&quot;headerlink&quot; title=&quot;模糊算法&quot;&gt;&lt;/a&gt;模糊算法&lt;/h1&gt;&lt;p&gt;大部分模糊算法参考在&lt;a href=&quot;https://zhuanlan.zhihu.com/p/125744132&quot;&gt;这里&lt;
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>后处理逻辑</title>
    <link href="https://crunchybiscuits.github.io/2021/04/04/%E5%90%8E%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91/"/>
    <id>https://crunchybiscuits.github.io/2021/04/04/%E5%90%8E%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91/</id>
    <published>2021-04-04T12:27:21.000Z</published>
    <updated>2021-04-09T15:51:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="后处理逻辑"><a href="#后处理逻辑" class="headerlink" title="后处理逻辑"></a>后处理逻辑</h1><p>原理：根据屏幕的大小设置一个正方形的面片，重新渲染这个面片，调用shader，之后对帧缓冲区图像进行自定义的处理。</p><p>OnRenderImage()的on一定要大写！一定要大写！查错查了可久</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExecuteInEditMode函数让脚本在编辑阶段可运行</span></span><br><span class="line">[<span class="meta">ExecuteInEditMode()</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ImageEffectTest</span>: <span class="title">MonoBehaviour</span>&#123;</span><br><span class="line"><span class="keyword">public</span> Material material;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span>&#123;</span><br><span class="line">        <span class="comment">// 是否使用当前后处理的判断逻辑</span></span><br><span class="line">        <span class="keyword">if</span>(material == <span class="literal">null</span> || SystemInfo.supportsImageEffects == <span class="literal">false</span></span><br><span class="line">        || material.shader == <span class="literal">null</span> || material.shader.isSupported == <span class="literal">false</span>)&#123;</span><br><span class="line">            enabled = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只能挂在摄像机上</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture source, RenderTexture destination</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 第四个参数表示是哪个pass</span></span><br><span class="line">Graphics.Blit(source, destination, material, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算屏幕空间坐标"><a href="#计算屏幕空间坐标" class="headerlink" title="计算屏幕空间坐标"></a>计算屏幕空间坐标</h2><h3 id="起因和原理"><a href="#起因和原理" class="headerlink" title="起因和原理"></a>起因和原理</h3><p><strong>起因</strong>：因为希望图片在屏幕尺寸变换的时候，跟着一起变换</p><p><strong>原理</strong>：NDC坐标归一化的时候将图片展到和设备坐标相同的位置</p><p><strong>注意：写后处理逻辑的shader的时候一定设置，Cull Off， ZWrite Off，ZTest Always</strong></p><figure class="highlight plaintext"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 透视除法,这一步操作不能在顶点阶段做，提前做了screen_uv就不是线性的值了</span><br><span class="line">half2 screen_uv = i.screen_pos.xy / (i.screen_pos.w + 0.000001);</span><br><span class="line">// 映射到0-1</span><br><span class="line">screen_uv = (screen_uv + 1.0) * 0.5;</span><br></pre></td></tr></table></figure><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><p><strong>直接使用上述方法可能会遇到屏幕上下反转的问题，原因是平台坐标不同起始点导致</strong></p><p>使用_ProjectionParams.x处理屏幕翻转问题 — 主要是不同平台的处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.screen_pos.y = o.screen_pos.y * _ProjectionParams.x;</span><br></pre></td></tr></table></figure><h3 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h3><ol><li>ComputeScreenPos(clip_pos) 处理屏幕翻转以及缩放 _ProjectionParams.x</li><li>ComputeGrabScreenPos(clip_pos) 处理Grab图像的翻转UNITY_UV_STARTS_AT_TOP</li><li><strong>可以使用vert_img顶点函数和v2f_img结构体来方便编写</strong></li></ol><h2 id="ColorAdjustment"><a href="#ColorAdjustment" class="headerlink" title="ColorAdjustment"></a>ColorAdjustment</h2><h3 id="色相-饱和度-对比度-亮度"><a href="#色相-饱和度-对比度-亮度" class="headerlink" title="色相/饱和度/对比度/亮度"></a>色相/饱和度/对比度/亮度</h3><p><strong>亮度</strong>：</p><figure class="highlight plaintext"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">half4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">half3 finalcol = col.rgb * _Brightness;</span><br></pre></td></tr></table></figure><p><strong>饱和度</strong>：</p><p><strong>饱和度分为两种，线性空间和伽马空间，计算后再通过lerp插值得到饱和度</strong></p><figure class="highlight plaintext"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 伽马空间</span><br><span class="line">dot(col, float3(0.22,0.707,0.071));</span><br><span class="line">// 线性空间</span><br><span class="line">dot(col, float3(0.0396, 0.458, 0.0061));</span><br></pre></td></tr></table></figure><p><strong>对比度</strong>：</p><p>和计算饱和度很相似，和(0.5,0.5,0.5)作插值</p><p><strong>色相</strong>：</p><p>调整色相先rgb-&gt;hsv，对r分量进行操作之后再hsv-&gt;rgb, 函数取自unity</p><h3 id="晕影-暗角"><a href="#晕影-暗角" class="headerlink" title="晕影/暗角"></a>晕影/暗角</h3><p>原理：中心距离周围点的距离，越远越暗</p><p>思路：计算中心点到周围距离长度的绝对值</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/post_out.gif" alt=""></p><h2 id="碎屏效果及对应处理"><a href="#碎屏效果及对应处理" class="headerlink" title="碎屏效果及对应处理"></a>碎屏效果及对应处理</h2><ol><li><p>在unity材质面板中设置wrap mode</p></li><li><p>根据屏幕宽高比例进行设置，shader对应使用_ScreenParams.x和_ScreenParams.y</p></li></ol><h3 id="法线图Noise修正"><a href="#法线图Noise修正" class="headerlink" title="法线图Noise修正"></a>法线图Noise修正</h3><p>出现原因：法线贴图中有噪点</p><p>修改方法：ps中修改贴图</p><h3 id="UV边缘扭曲限制"><a href="#UV边缘扭曲限制" class="headerlink" title="UV边缘扭曲限制"></a>UV边缘扭曲限制</h3><figure class="highlight plaintext"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">half2 d = 1.0 - smoothstep(0.9,1,abs(i.uv * 2.0 -1.0));</span><br><span class="line">half vfactor = d.x * d.y;</span><br><span class="line"></span><br><span class="line">half2 uv_distort = i.uv + glass_normal.xy * _Distort * vfactor;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;后处理逻辑&quot;&gt;&lt;a href=&quot;#后处理逻辑&quot; class=&quot;headerlink&quot; title=&quot;后处理逻辑&quot;&gt;&lt;/a&gt;后处理逻辑&lt;/h1&gt;&lt;p&gt;原理：根据屏幕的大小设置一个正方形的面片，重新渲染这个面片，调用shader，之后对帧缓冲区图像进行自定义的处理。&lt;
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>基础shader记录</title>
    <link href="https://crunchybiscuits.github.io/2021/03/22/%E5%9F%BA%E7%A1%80shader%E8%AE%B0%E5%BD%95/"/>
    <id>https://crunchybiscuits.github.io/2021/03/22/%E5%9F%BA%E7%A1%80shader%E8%AE%B0%E5%BD%95/</id>
    <published>2021-03-22T12:35:48.000Z</published>
    <updated>2021-03-25T12:06:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础shader分析"><a href="#基础shader分析" class="headerlink" title="基础shader分析"></a>基础shader分析</h1><h3 id="常见的语义词："><a href="#常见的语义词：" class="headerlink" title="常见的语义词："></a>常见的语义词：</h3><ol><li>获取顶点 — float4 vertex : POSITION;</li><li>获取第一uv — float2 uv : TEXCOORD0;</li><li>获取发现 — float3 normal : NORMAL;</li><li>获取顶点色 — float4 color : COLOR；</li><li>获取切线 — float4 tan : TANGENT；</li></ol><h3 id="常用的数据类型对应"><a href="#常用的数据类型对应" class="headerlink" title="常用的数据类型对应"></a>常用的数据类型对应</h3><p>精度设置float – 32位，half – 16位， fixed – 8位</p><ol><li>float常用于坐标点 </li><li>half常用于UV和大部分向量</li><li>fixed常用于颜色</li></ol><h2 id="基础shader内容："><a href="#基础shader内容：" class="headerlink" title="基础shader内容："></a>基础shader内容：</h2><h3 id="获取位置坐标并输出"><a href="#获取位置坐标并输出" class="headerlink" title="获取位置坐标并输出"></a>获取位置坐标并输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1. 基础变换 -- 顶点着色器中将物体转换到裁剪空间</span><br><span class="line">v2f vert(appdata v)&#123;</span><br><span class="line">v2f o;</span><br><span class="line">// 模型转换到世界空间</span><br><span class="line">float4 pos_world = mul(_Object2World, v.vertex);</span><br><span class="line">// 世界空间到相机空间</span><br><span class="line">float4 pos_view = mul(UNITY_MATRIX_V, pos_world);</span><br><span class="line">// 相机空间到裁剪空间</span><br><span class="line">float4 pos_clip = mul(UNITY_MATRIX_P, pow_view);</span><br><span class="line"></span><br><span class="line">// 以上变换可以用mvp代替</span><br><span class="line">// o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">o.pos = pos_clip;</span><br><span class="line">return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. 输出颜色 -- 片元着色器获取顶点并输出</span><br><span class="line">float4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">return float4(0.5,1.0,0.5,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的内容</strong><br>在声明的构造体appdata和v2f中的TEXCOORD0是有差别的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct appdata&#123;</span><br><span class="line">// 第一套uv</span><br><span class="line">float2 uv : TEXCOORD0;</span><br><span class="line">// 第二套uv</span><br><span class="line">float2 uv2 : TEXCOORD1; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f&#123;</span><br><span class="line">// 这里表示的是存储器、插值器</span><br><span class="line">float2 uv : TEXCOORD0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="获取uv贴图并输出"><a href="#获取uv贴图并输出" class="headerlink" title="获取uv贴图并输出"></a>获取uv贴图并输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. 基础变换 -- 顶点着色器中将物体转换到裁剪空间,获取uv</span><br><span class="line">sampler2D _MainTex;</span><br><span class="line">// 这个参数是跟贴图的tilling和offset链接</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">v2f vert(appdata v)&#123;</span><br><span class="line">v2f o;</span><br><span class="line"></span><br><span class="line">o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">// o.uv = v.uv;</span><br><span class="line">o.uv = v.uv * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. 输出颜色 -- 片元着色器获uv并输出</span><br><span class="line">float4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">//获取uv并输出 </span><br><span class="line">float4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">return col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="背面剔除"><a href="#背面剔除" class="headerlink" title="背面剔除"></a>背面剔除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Properties&#123;</span><br><span class="line">[Enum(UnityEngine.Rendering.CullMode)]_CullMode(&quot;CullMode&quot;, float) = 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubShader&#123;</span><br><span class="line">Pass&#123;</span><br><span class="line">Cull[_CullMode]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Alpha-Test"><a href="#Alpha-Test" class="headerlink" title="Alpha Test"></a>Alpha Test</h3><p>对clip()函数的使用：</p><p>大体思路：</p><ol><li>通过tex2D获取r通道</li><li>对gradient进行操作</li><li>输出gradient.xxxx</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">half4 frag(v2f i): SV_Target&#123;</span><br><span class="line">half gradient = tex2D(_MainTex, i.uv+_Time.y * _Speed.xy).r;</span><br><span class="line">half noise = tex2D(_NoiseTex, i.uv+_Time.y*_Speed.zw).r;</span><br><span class="line">clip(gradient - noise - _Cutout);</span><br><span class="line">return _MainColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="半透明混合"><a href="#半透明混合" class="headerlink" title="半透明混合"></a>半透明混合</h3><p>大体思路：</p><ol><li>在pass中打开Blend src dst</li><li>关掉Zwrite – Zwrite off</li><li>Subshader中Tags = {“Queue” = “Transparent”}</li></ol><p><strong>在贴图没有alpha通道的时候怎么做</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 尽量将颜色和alpha分开写，最后再组合</span><br><span class="line">half3 col = _MainColor.xyz;</span><br><span class="line">// 用贴图灰度值 * 颜色的alpha代替alpha</span><br><span class="line">half alpha = tex2D(_MainTex, i.uv).r * _MainColor.a;</span><br><span class="line">return float4(col, alpha);</span><br></pre></td></tr></table></figure><h3 id="边缘光"><a href="#边缘光" class="headerlink" title="边缘光"></a>边缘光</h3><p><strong>实质，dot(n,v)</strong></p><ol><li>实现设置强度</li><li>实现设置对比度</li><li>预先写深度 — 通过提前写一个pass，并且在里面设置ColorMask 0将颜色信息的写入取消<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 这里顶点着色器仅写了相关代码</span><br><span class="line">v2f vert(appdata v)&#123;</span><br><span class="line">// normal计算方式</span><br><span class="line">o.normal_world = normalize(mul(float4(v.normal,0.0), _Object2World).xyz);</span><br><span class="line"></span><br><span class="line">// 视线计算方式，相机位置减去点的位置</span><br><span class="line">float3 pos_world = mul(_Object2World, v.vertex).xyz;</span><br><span class="line">float3 view_world = normalize(_WolrdSpaceCameraPos.xyz - pos_world);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 片元着色器中计算 N dot V</span><br><span class="line">half4 frag(v2f i):SV_Target&#123;</span><br><span class="line">float3 normal_world = normalize(i.normal_world);</span><br><span class="line">float3 view_world = normalize(i.view_world);</span><br><span class="line">float NdotV = saturate(dot(normal_world, view_world));</span><br><span class="line"></span><br><span class="line">float3 col = _MainColor.xyz * _Emiss;</span><br><span class="line">// 对比度</span><br><span class="line">float fresnel = pow((1.0 - NdotV), _RimPower);</span><br><span class="line">// 强度</span><br><span class="line">float alpha = saturate(fresnel * _Emiss);</span><br><span class="line"></span><br><span class="line">return float4(col, alpha);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如何设置强度</span><br><span class="line">float alpha = (1.0 - NdotV) * _Emiss;</span><br><span class="line"></span><br><span class="line">// 如何设置对比度</span><br><span class="line">float fresnel = pow((1.0 - NdotV), _RimPower);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础shader分析&quot;&gt;&lt;a href=&quot;#基础shader分析&quot; class=&quot;headerlink&quot; title=&quot;基础shader分析&quot;&gt;&lt;/a&gt;基础shader分析&lt;/h1&gt;&lt;h3 id=&quot;常见的语义词：&quot;&gt;&lt;a href=&quot;#常见的语义词：&quot; class
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>GAMES202作业0</title>
    <link href="https://crunchybiscuits.github.io/2021/03/22/GAMES202%E4%BD%9C%E4%B8%9A0/"/>
    <id>https://crunchybiscuits.github.io/2021/03/22/GAMES202%E4%BD%9C%E4%B8%9A0/</id>
    <published>2021-03-21T16:25:10.000Z</published>
    <updated>2021-03-21T16:32:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GAMES202作业0"><a href="#GAMES202作业0" class="headerlink" title="GAMES202作业0"></a>GAMES202作业0</h1><p>本次作业主要为熟悉框架，通过框架实现blinn-phong，无特殊要求</p><p>大致步骤：</p><ol><li>使用GLSL编写对应vert和frag shader</li><li>将shader的字符串形式传递到javascript实现的PhongMaterial类中</li><li>在index.html中导入</li><li>将框架中原来使用的Material替换为编写好的PhongMaterial类</li></ol><h3 id="最初效果"><a href="#最初效果" class="headerlink" title="最初效果"></a>最初效果</h3><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/202assign0_1.jpg" alt="渲染方程"></p><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/202assign0_2.jpg" alt="渲染方程"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GAMES202作业0&quot;&gt;&lt;a href=&quot;#GAMES202作业0&quot; class=&quot;headerlink&quot; title=&quot;GAMES202作业0&quot;&gt;&lt;/a&gt;GAMES202作业0&lt;/h1&gt;&lt;p&gt;本次作业主要为熟悉框架，通过框架实现blinn-phong，无特殊要
      
    
    </summary>
    
    
    
      <category term="GAMES202" scheme="https://crunchybiscuits.github.io/tags/GAMES202/"/>
    
  </entry>
  
  <entry>
    <title>GAMES202-Lecture2笔记</title>
    <link href="https://crunchybiscuits.github.io/2021/03/20/GAMES202-Lecture2%E7%AC%94%E8%AE%B0/"/>
    <id>https://crunchybiscuits.github.io/2021/03/20/GAMES202-Lecture2%E7%AC%94%E8%AE%B0/</id>
    <published>2021-03-20T08:59:35.000Z</published>
    <updated>2021-03-21T16:28:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GAMES202第二课"><a href="#GAMES202第二课" class="headerlink" title="GAMES202第二课"></a>GAMES202第二课</h1><h2 id="基本渲染管线"><a href="#基本渲染管线" class="headerlink" title="基本渲染管线"></a>基本渲染管线</h2><ol><li>体在空间中的表示 – 点，点和点之间的连接关系</li></ol><ul><li>顶点处理    MVP</li><li>图元装配和光栅化</li><li>片元处理</li><li>输出合并</li></ul><ol start="2"><li><p>型（Blinn-Phong等等）在光线的弹射和阴影的表现上并不是很好（并不是100%真实，在全局和间接光照上处理的不好）</p><p>好处是GPU上跑很快</p></li><li><p>纹理映射和插值–重心坐标</p></li></ol><h2 id="OpenGL-GLSL"><a href="#OpenGL-GLSL" class="headerlink" title="OpenGL(GLSL)"></a>OpenGL(GLSL)</h2><h3 id="OpenGL介绍"><a href="#OpenGL介绍" class="headerlink" title="OpenGL介绍"></a>OpenGL介绍</h3><p>OpenGL是一个API的集合，是CPU运行的负责调用GPU工作任务的。</p><p>优势：</p><ul><li>语言无关</li><li>跨平台</li></ul><p>坏处：</p><ul><li>版本特别碎片化</li><li>C语言风格，不方便使用</li></ul><p><strong>在每个pass中进行的过程</strong></p><ol><li>放置物体和模型<ol><li>模型声明</li><li>模型摆放 – model transformation</li><li>VBO：GPU中的一块区域用于存储模型与.obj文件特别相似</li></ol></li><li>设置相机位置<ol><li>视口变换 – view transformation</li><li>在OpenGL中创建framebuffer</li></ol></li><li>设置画布<ol><li>这里OpenGL可以multiple render target</li><li>垂直同步，双重缓冲，三重缓冲，目的都是为了防止画面撕裂，撕裂原因是在帧缓冲中上一帧画面渲染到一般又渲染了下一帧</li></ol></li><li>画 – shading<ol><li>vertex<ol><li>对顶点进行插值</li></ol></li><li>图元装配光栅化</li><li>fragment<ol><li>片段着色</li><li>lighting</li></ol></li></ol></li><li>接着画，画多次 – multiple passes<ol><li>shadowmap的作法<ol><li>计算光源能看到什么</li><li>再通过camera来计算这些物体能不能被light看到，不能就是在阴影中</li></ol></li></ol></li></ol><p>Shader setup步骤</p><ol><li>创建shader</li><li>编译shader</li><li>将shader加载到程序中(attach program)</li><li>连接程序(link program)</li><li>使用程序(use program)</li></ol><h3 id="Vertex-Shader-顶点着色器"><a href="#Vertex-Shader-顶点着色器" class="headerlink" title="Vertex Shader(顶点着色器)"></a>Vertex Shader(顶点着色器)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// attribute这个只可能在vertex shader中出现，fragment shader中没有</span></span><br><span class="line"><span class="comment">// 顶点位置</span></span><br><span class="line">attribute vec3 aVertexPosition;</span><br><span class="line"><span class="comment">// 法线位置</span></span><br><span class="line">attribute vec3 aNormalPosition;</span><br><span class="line"><span class="comment">// 纹理坐标</span></span><br><span class="line">attribute vec3 aTextureCoord;</span><br><span class="line"></span><br><span class="line"><span class="comment">// uniform关键字指定全局变量，vertex和fragment shader都可以用</span></span><br><span class="line">uniform mat4 uModeViewMatrix;</span><br><span class="line">uniform mat4 uProjectionMatrix;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过varying关键字指定fragment shader中需要插值的量</span></span><br><span class="line"><span class="comment">// highp指定计算精度</span></span><br><span class="line">varying highp vec2 vTextureCoord;</span><br><span class="line">varying highp vec3 vFragPos;</span><br><span class="line">varying highp vec3 vNormal;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 设置要传给frag的属性</span></span><br><span class="line">    vFragPos = aVertexPosition;</span><br><span class="line">    vNormal = aNormalPosition;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换成齐次坐标再进行MVP</span></span><br><span class="line">    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, <span class="number">1.0</span>);</span><br><span class="line">    </span><br><span class="line">    vTextureCoord = aTextureCoord;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Fragment-shader"><a href="#Fragment-shader" class="headerlink" title="Fragment shader"></a>Fragment shader</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uniform关键字指定全局变量，vertex和fragment shader都可以用</span></span><br><span class="line">uniform sampler2D uSampler;</span><br><span class="line"><span class="comment">// binn</span></span><br><span class="line">uniform vec3 uKd;</span><br><span class="line">uniform vec3 uKs;</span><br><span class="line">uniform vec3 uLightPos;</span><br><span class="line">uniform vec3 uCameraPos;</span><br><span class="line">uniform <span class="type">float</span> uLightIntensity;</span><br><span class="line">uniform <span class="type">int</span> uTextureSample;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过varying关键字指定fragment shader中需要插值的量</span></span><br><span class="line">varying highp vec2 vTextureCoord;</span><br><span class="line">varying highp vec3 vFragPos;</span><br><span class="line">varying highp vec3 vNormal;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    vec3 color;</span><br><span class="line">    <span class="keyword">if</span>(uTextureSample == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// vec3(2.2)表示伽马矫正</span></span><br><span class="line">        color = <span class="built_in">pow</span>(texture2D(uSampler, vTextureCoord).rgb, vec3(<span class="number">2.2</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        color = uKd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 环境光</span></span><br><span class="line">    vec3 ambient = <span class="number">0.05</span> * color;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 光线方向由光源位置-点位置得到</span></span><br><span class="line">    vec3 lightDir = normalize(uLightPos - vFragPos);</span><br><span class="line">    vec3 normal = normalize(vNormal);</span><br><span class="line">    <span class="comment">// 兰伯特</span></span><br><span class="line">    <span class="type">float</span> diff = max(dot(lightDir, normal), <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// 光照强度系数</span></span><br><span class="line">    <span class="type">float</span> light_atten_coff = uLightIntensity / length(uLightPos - vFragPos);</span><br><span class="line">    <span class="comment">// 漫反射</span></span><br><span class="line">    vec3 diffuse = diff * light_atten_coff * color;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 视线方向</span></span><br><span class="line">    vec3 viewDir = normalize(uCameraPos - vFragPos);</span><br><span class="line">    <span class="type">float</span> spec = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// 反射方向，需要从点出发，光源方向也是从点出发表示，因此为-lightDir</span></span><br><span class="line">    vec3 reflectDir = reflect(-lightDir, normal);</span><br><span class="line">    <span class="comment">// 高光</span></span><br><span class="line">    spec = <span class="built_in">pow</span>(max(dot(viewDir, reflectDir), <span class="number">0.0</span>), <span class="number">35.0</span>);</span><br><span class="line">    <span class="comment">// 加上高光强度</span></span><br><span class="line">    vec3 specular = uKs * light_atten_coff * spec;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// blinn-phong</span></span><br><span class="line">    gl_FragColor = vec4(<span class="built_in">pow</span>((ambient + diffuse + specular), vec3(<span class="number">1.0</span>/<span class="number">2.2</span>)), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h2><p>在渲染中是最为重要的</p><ul><li>描述了光线的传播</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/rendering%20equation.jpg" alt="渲染方程"></p><p>意思解释：</p><ol><li>outgoing radiance：当前点发出的radiance</li><li>emission：点的自发光</li><li>BRDF * cosθ * dw：BRDF乘上cosθ然后乘以其他地方打到这个点上的radiance<ol><li>cosθ * dw： 是将radiance转换成irradiance</li></ol></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/render%20equation2.jpg" alt="渲染方程"></p><p>V(p, w)：表示点是否可以接收到当前传过来的那束光</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GAMES202第二课&quot;&gt;&lt;a href=&quot;#GAMES202第二课&quot; class=&quot;headerlink&quot; title=&quot;GAMES202第二课&quot;&gt;&lt;/a&gt;GAMES202第二课&lt;/h1&gt;&lt;h2 id=&quot;基本渲染管线&quot;&gt;&lt;a href=&quot;#基本渲染管线&quot; cla
      
    
    </summary>
    
    
    
      <category term="GAMES202" scheme="https://crunchybiscuits.github.io/tags/GAMES202/"/>
    
  </entry>
  
  <entry>
    <title>unity shader代码结构</title>
    <link href="https://crunchybiscuits.github.io/2021/03/20/shader%E7%BB%93%E6%9E%84/"/>
    <id>https://crunchybiscuits.github.io/2021/03/20/shader%E7%BB%93%E6%9E%84/</id>
    <published>2021-03-19T16:14:00.000Z</published>
    <updated>2021-03-22T17:18:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity-Shader基础代码结构"><a href="#Unity-Shader基础代码结构" class="headerlink" title="Unity Shader基础代码结构"></a>Unity Shader基础代码结构</h1><p>部分资料取自冯乐乐的《Unity Shader入门精要》</p><h2 id="名字"><a href="#名字" class="headerlink" title="名字"></a>名字</h2><p>在shader第一行我们需要指定unity shader的名字，名字可以通过“/”来进行层次的划分，例如“Custom/TestShader”</p><p>在unity的材质面板中就能在Custom标签那一栏中找到TestShader</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/shader%E7%BB%93%E6%9E%84.jpg" alt="shader结构"></p><p><strong>语法：</strong></p><figure class="highlight plaintext"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/TestShader&quot;&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>在这里设置需要unity材质面板中能够方便调整的各种属性</p><p>这里的属性包含三个部分：</p><ol><li>名字：名字主要是在unity shader中访问需要的名字，通常是以”_”开始</li><li>显示名称：这里的名称是在unity材质面板中显示的名字</li><li>类型：类型则指定了unity shader中这些属性的类型，并且我们需要给这些属性提供默认值</li></ol><p>Properties中支持以下类型：</p><table><thead><tr><th>属性类型</th><th>例子</th></tr></thead><tbody><tr><td>Int</td><td>_Number (“Number”, Int) = 2</td></tr><tr><td>Float</td><td>_Intensity (“Intensity”, Float) = 1.5</td></tr><tr><td>Range(min, max)</td><td>_SideRange (“SideRange”, Range(0.0, 5.0)) = 3.0</td></tr><tr><td>Color</td><td>_RimColor (“RimColor”, Color) = (1,1,1,1)</td></tr><tr><td>Vector</td><td>_LightDir (“LightDir”, Vector) = (2,3,6,1)</td></tr><tr><td>2D</td><td>_2DTex (“2D”, 2D) = “”{}</td></tr><tr><td>Cube</td><td>_CubeTex (“Cube”, Cube) = “white”{}</td></tr><tr><td>3D</td><td>_3DTex (“3D”, 3D) = “white”{}</td></tr></tbody></table><h2 id="Subshader"><a href="#Subshader" class="headerlink" title="Subshader"></a>Subshader</h2><p>每个unity shader可以包含多个subshader，在加载shader的时候会扫描所有的subshader模块，然后选择第一个能够使用的subshader。如果都不行那么就会使用Fallback定义的unity shader。subshader和pass中都可以包含Tags和RenderSetup，如果设置在subshader中那么将适用于所有的pass</p><p><strong>subshader结构：</strong></p><figure class="highlight plaintext"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SubShader&#123;</span><br><span class="line">// 可选部分</span><br><span class="line">[Tags]</span><br><span class="line"></span><br><span class="line">[RenderSetup]</span><br><span class="line"></span><br><span class="line">// pass定义，可以有多个pass</span><br><span class="line">// 第一个pass</span><br><span class="line">Pass&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第二个pass</span><br><span class="line">Pass&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RenderSetup"><a href="#RenderSetup" class="headerlink" title="RenderSetup"></a>RenderSetup</h3><p>提供一些列渲染状态的设置，例如是否开启混合，开启深度测试等等</p><table><thead><tr><th>状态名称</th><th>设置指令</th><th>解释</th></tr></thead><tbody><tr><td>Cull</td><td>Cull Back|Front|Off</td><td>设置剔除模式：背面/正面/关闭</td></tr><tr><td>ZTest</td><td>ZTest Less|Greater|LEqual|GEqual|Equal|NotEqual|Always</td><td>设置深度测试使用函数</td></tr><tr><td>ZWrite</td><td>ZWrite On|Off</td><td>深度写入开关</td></tr><tr><td>Blend</td><td>Blend SrcFactor DstFactor</td><td>混合模式设置</td></tr></tbody></table><p>ZTest参数解释：</p><ul><li>LEqual：小于等于</li><li>GEqual：大于等于</li><li>Always：无论如何都通过</li></ul><h3 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h3><p>Tags是以键值对的形式存在的，主要是告诉渲染引擎，希望怎样来渲染这个对象</p><p><strong>标签结构</strong></p><figure class="highlight plaintext"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags &#123;&quot;TagName1&quot;=&quot;Value1&quot; &quot;TagName2&quot;=&quot;Value2&quot;&#125;</span><br></pre></td></tr></table></figure><p><strong>常用的两种标签类型</strong></p><table><thead><tr><th>标签类型</th><th>说明</th><th></th></tr></thead><tbody><tr><td>Queue</td><td>控制渲染顺序，指定渲染队列</td><td>Tags {“Queue”=”Transparent”}</td></tr><tr><td>RenderType</td><td>对着色器进行分类，例如不透明和透明着色器，可用于Shader replacement</td><td>Tags {“RenderType”=”Opaque”}</td></tr></tbody></table><h2 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h2><p>Fallback用于告诉unity如果所有subshader都不能用那么就用这里这个，Fallback还可用于阴影的投射</p><p>Fallback “shader名字”</p><p>Fallback off</p><hr><p>最终unity shader大致结构如下：</p><figure class="highlight plaintext"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/SimpleShader&quot;&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        pass&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="shader样例"><a href="#shader样例" class="headerlink" title="shader样例"></a>shader样例</h2><figure class="highlight plaintext"><figcaption><span>Shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/testShader&quot;&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        // _Float为变量名字,可以自由更改，以_起头作为传统 </span><br><span class="line">        _Float(&quot;Float&quot;, Float) = 0.0</span><br><span class="line">        _Range(&quot;Range&quot;, Range(0.0,1.0)) = 0.0</span><br><span class="line">        _Vector(&quot;Vector&quot;, Vector) = (1,1,1,1)</span><br><span class="line">        _Color(&quot;Color&quot;, Color) = (0.5,0.5,0.5,0.5)</span><br><span class="line">        _MainTex(&quot;MainTex&quot;, 2D) = &quot;black&quot;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        pass&#123;</span><br><span class="line">        // 以CGPROGRAM和ENDCG包裹</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line"></span><br><span class="line">            struct appdata&#123;</span><br><span class="line">                float4 vertex:POSITION;</span><br><span class="line">                float2 uv:TEXCOORD0;//TEXCOORD0这里是第一套uv的意思</span><br><span class="line">                // float3 normal:NORMAL;</span><br><span class="line">                // float4 color:COLOR;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos:SV_POSITION;</span><br><span class="line">                float2 uv:TEXCOORD0; //TEXCOORD0是储存器</span><br><span class="line">            &#125;;</span><br><span class="line">            // 这里声明的变量需要和Properties里面的一致</span><br><span class="line">            float4 _Color;</span><br><span class="line">            // 纹理需要配一个float4才能够调用tilling和offset</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">            v2f vert(appdata v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">// mvp变换的两种方式</span><br><span class="line">                // float4 world_pos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">                // float4 camera_pos = mul(UNITY_MATRIX_V, world_pos);</span><br><span class="line">                // float4 projection_pos = mul(UNITY_MATRIX_P, camera_pos);</span><br><span class="line">                float4 projection_pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.pos = projection_pos;</span><br><span class="line">                // 获取uv</span><br><span class="line">                o.uv = v.uv * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            float4 frag(v2f i):SV_TARGET&#123;</span><br><span class="line">            // 贴图采样</span><br><span class="line">                float4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">                return col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Unity-Shader基础代码结构&quot;&gt;&lt;a href=&quot;#Unity-Shader基础代码结构&quot; class=&quot;headerlink&quot; title=&quot;Unity Shader基础代码结构&quot;&gt;&lt;/a&gt;Unity Shader基础代码结构&lt;/h1&gt;&lt;p&gt;部分资料取自
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>Docker常用指令</title>
    <link href="https://crunchybiscuits.github.io/2021/03/02/Docker%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>https://crunchybiscuits.github.io/2021/03/02/Docker%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</id>
    <published>2021-03-02T11:39:54.000Z</published>
    <updated>2021-03-02T11:42:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker常用指令"><a href="#Docker常用指令" class="headerlink" title="Docker常用指令"></a>Docker常用指令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version     # 显示版本信息</span><br><span class="line">docker info# 显示系统信息，包括镜像和容器数量</span><br><span class="line">docker 命令 --help#  帮助命令</span><br></pre></td></tr></table></figure><p>帮助文档的地址：<a href="https://docs.docker.com/get-started/">https://docs.docker.com/get-started/</a></p><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><h3 id="docker-images：查看所有本地的主机上的镜像"><a href="#docker-images：查看所有本地的主机上的镜像" class="headerlink" title="docker images：查看所有本地的主机上的镜像"></a><strong>docker images</strong>：查看所有本地的主机上的镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY                                               TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">tensorflow/serving                                       latest    784e871ab5a4   4 weeks ago    298MB</span><br><span class="line"></span><br><span class="line"># 解释</span><br><span class="line">REPOSITORY镜像的仓库名</span><br><span class="line">TAG镜像的标签</span><br><span class="line">IMAGE ID镜像的ID</span><br><span class="line">CREATED镜像创建时间</span><br><span class="line">SIZE镜像的大小</span><br><span class="line"></span><br><span class="line"># 常用可选项</span><br><span class="line">Options:</span><br><span class="line">  -a, --all             # 列出所有的镜像</span><br><span class="line">  -q, --quiet           # 只显示镜像ID</span><br></pre></td></tr></table></figure><h3 id="docker-search：搜索镜像"><a href="#docker-search：搜索镜像" class="headerlink" title="docker search：搜索镜像"></a><strong>docker search</strong>：搜索镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(base) zzy@zzydeMacBook-Pro ~ % docker search mysql</span><br><span class="line">NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql                             MySQL is a widely used, open-source relation…   10565     [OK]</span><br><span class="line">mariadb                           MariaDB Server is a high performing open sou…   3947      [OK]</span><br><span class="line">mysql/mysql-server                Optimized MySQL Server Docker images. Create…   774                  [OK]</span><br><span class="line">percona                           Percona Server is a fork of the MySQL relati…   527       [OK]</span><br><span class="line"></span><br><span class="line"># 解释</span><br><span class="line">STARS收藏</span><br><span class="line"></span><br><span class="line"># 常用可选项</span><br><span class="line">--filter=STARS=3000搜索出来的镜像STARS大于3000</span><br><span class="line"></span><br><span class="line">(base) zzy@zzydeMacBook-Pro ~ % docker search mysql --filter=STARS=3000</span><br><span class="line">NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql     MySQL is a widely used, open-source relation…   10565     [OK]</span><br><span class="line">mariadb   MariaDB Server is a high performing open sou…   3947      [OK]</span><br></pre></td></tr></table></figure><h3 id="docker-pull：下载镜像"><a href="#docker-pull：下载镜像" class="headerlink" title="docker pull：下载镜像"></a><strong>docker pull</strong>：下载镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 下载镜像 docker pull 镜像名[:tag]</span><br><span class="line"></span><br><span class="line">(base) zzy@zzydeMacBook-Pro ~ % docker pull mysql</span><br><span class="line">Using default tag: latest#如果不指定tag，默认是最新的</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">45b42c59be33: Pull complete#分层下载，docker images的核心</span><br><span class="line">b4f790bd91da: Pull complete</span><br><span class="line">325ae51788e9: Pull complete</span><br><span class="line">adcb9439d751: Pull complete</span><br><span class="line">174c7fe16c78: Pull complete</span><br><span class="line">698058ef136c: Pull complete</span><br><span class="line">4690143a669e: Pull complete</span><br><span class="line">f7599a246fd6: Pull complete</span><br><span class="line">35a55bf0c196: Pull complete</span><br><span class="line">790ac54f4c47: Pull complete</span><br><span class="line">b0ddd5d1b543: Pull complete</span><br><span class="line">1aefd67cb33d: Pull complete</span><br><span class="line">Digest: sha256:7706e4c382be813b58ef514f2bdac747cd463a6866c6c81165d42a1d0e4fe947</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br><span class="line">docker.io/library/mysql:latest#真实地址</span><br><span class="line"></span><br><span class="line"># 等价的, 版本必须来自docker hub</span><br><span class="line">docker pull mysql</span><br><span class="line">docker pull mysql:lastest</span><br></pre></td></tr></table></figure><h3 id="docker-rmi：删除镜像"><a href="#docker-rmi：删除镜像" class="headerlink" title="docker rmi：删除镜像"></a><strong>docker rmi</strong>：删除镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 删除指定容器</span><br><span class="line">docker rm -f 容器id</span><br><span class="line"># 删除所有</span><br><span class="line">docker rmi -f $(docker images -aq)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(base) zzy@zzydeMacBook-Pro ~ % docker rmi -f 8457e9155715</span><br><span class="line">Untagged: mysql:latest</span><br><span class="line">Untagged: mysql@sha256:7706e4c382be813b58ef514f2bdac747cd463a6866c6c81165d42a1d0e4fe947</span><br><span class="line">Deleted: sha256:8457e9155715d4e1c80c9e048d94c9b47b5b733fa927756280382dd326403644</span><br><span class="line">Deleted: sha256:f0d02d3f5fc5a0f745bf3a97ec0b26c6b2d8b05288d98d954eeb87c4a6d47146</span><br><span class="line">Deleted: sha256:bf1129a8799d8beaafa396d6333a3ba6eac9d0d7f606491f9794c470fb2dd311</span><br><span class="line">Deleted: sha256:4386f82820992c927b924177ed3e4c2ffd477d4db7a63539ac76fd09ee36cd89</span><br><span class="line">Deleted: sha256:d7494c9168a11444d8b13558068409ace7393452f08f878686eec45122ee56c1</span><br><span class="line">Deleted: sha256:08dbcab3fe630e39bbabaa9f0ae72ec6d100bf1e400ebb4b7f04151b18bca89c</span><br><span class="line">Deleted: sha256:c3f78dcd6bcc4c156554296323e0eed74a4d2d93b304be15f55c1ef62dd06e0a</span><br><span class="line">Deleted: sha256:f89b66495a65489290c8edb71e0dbf9e3d0d6213b82cebc2554b271599f2f99d</span><br><span class="line">Deleted: sha256:1918839317d9988ff5e0168e336717e32820af1e77c3121297efc73a387ecdc5</span><br><span class="line">Deleted: sha256:1d2bcd52664a92805e5f49d94d3649323dd0f5682ae3e1380fa07b7a54d6ceb0</span><br><span class="line">Deleted: sha256:787de05fee96c7ba99e49f17d72aec68769a7373a8881a27917bdbf83dca58e8</span><br><span class="line">Deleted: sha256:eb82f9a2fbd7a4a0fdfbe40b5e77a995ccf73ab91364d90f4db820fd59dbf63b</span><br><span class="line">Deleted: sha256:9eb82f04c782ef3f5ca25911e60d75e441ce0fe82e49f0dbf02c81a3161d1300</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p>说明：有了镜像才可以创建容器，这里下载一个centos镜像进行尝试</p><h3 id="新建容器并启动"><a href="#新建容器并启动" class="headerlink" title="新建容器并启动"></a>新建容器并启动</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker run [参数] image /bin/bash</span><br><span class="line"></span><br><span class="line"># 参数说明</span><br><span class="line">--name=&quot;Name&quot;容器名字，用来区分容器</span><br><span class="line">-d后台方式运行</span><br><span class="line">-it使用交互方式运行，进入容器查看内容</span><br><span class="line">-p指定容器的端口</span><br><span class="line">-p主机端口：容器端口</span><br><span class="line">-p容器端口</span><br><span class="line">容器端口</span><br><span class="line">-P随机指定端口</span><br><span class="line"></span><br><span class="line"># 启动并进入容器</span><br><span class="line">docker run -it centos /bin/bash</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="列出所有运行的容器"><a href="#列出所有运行的容器" class="headerlink" title="列出所有运行的容器"></a>列出所有运行的容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker ps# 列出当前正在运行的容器</span><br><span class="line"> -a # 列出当前正在运行的容器+历史运行容器</span><br><span class="line"> -n=?# 显示最近创建的容器</span><br><span class="line"> -q# 只显示容器编号</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit# 直接停止容器并退出</span><br><span class="line">Ctrl + P + Q# 容器不停止，但是退出</span><br></pre></td></tr></table></figure><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id# 删除指定容器，不能删除正在运行中的容器</span><br><span class="line">docker rm -f $(docker ps -aq)# 删除所有容器</span><br><span class="line">docker ps -a -q|xargs docker rm# 删除所有容器(linux版)</span><br></pre></td></tr></table></figure><h3 id="启动和停止"><a href="#启动和停止" class="headerlink" title="启动和停止"></a>启动和停止</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id# 启动容器</span><br><span class="line">docker restart 容器id# 重启容器</span><br><span class="line">docker stop 容器id# 停止当前正在运行的容器</span><br><span class="line">docker kill 容器id# 强制停止当前容器</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker常用指令&quot;&gt;&lt;a href=&quot;#Docker常用指令&quot; class=&quot;headerlink&quot; title=&quot;Docker常用指令&quot;&gt;&lt;/a&gt;Docker常用指令&lt;/h1&gt;&lt;h2 id=&quot;帮助命令&quot;&gt;&lt;a href=&quot;#帮助命令&quot; class=&quot;head
      
    
    </summary>
    
    
    
      <category term="Docker" scheme="https://crunchybiscuits.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker梳理</title>
    <link href="https://crunchybiscuits.github.io/2021/02/27/Docker%E6%A2%B3%E7%90%86/"/>
    <id>https://crunchybiscuits.github.io/2021/02/27/Docker%E6%A2%B3%E7%90%86/</id>
    <published>2021-02-26T16:31:56.000Z</published>
    <updated>2021-03-01T16:31:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="联合文件系统"><a href="#联合文件系统" class="headerlink" title="联合文件系统"></a>联合文件系统</h2><p>它支持对文件系统的修改作为一次提交来一层一层的叠加，可以看到每一次修改，极大节省内存和空间</p><ul><li>bootfs，主要包含bootloader和kernal<ul><li>黑屏到开机的过程</li></ul></li><li>rootfs<ul><li>不同的发行版</li></ul></li></ul><h2 id="镜像分层"><a href="#镜像分层" class="headerlink" title="镜像分层"></a>镜像分层</h2><p>每操作一步都加新的一层<br>从远程pull下来的镜像层是无法改变的<br>run之后已经新加了一层<br>所有操作都是基于容器层的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; class=&quot;headerlink&quot; title=&quot;Docker&quot;&gt;&lt;/a&gt;Docker&lt;/h1&gt;&lt;h2 id=&quot;联合文件系统&quot;&gt;&lt;a href=&quot;#联合文件系统&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
    
      <category term="Docker" scheme="https://crunchybiscuits.github.io/tags/Docker/"/>
    
  </entry>
  
</feed>
