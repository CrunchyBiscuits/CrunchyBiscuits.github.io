<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZY-Zhang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://crunchybiscuits.github.io/"/>
  <updated>2021-02-17T11:25:06.983Z</updated>
  <id>https://crunchybiscuits.github.io/</id>
  
  <author>
    <name>ZY-Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>渲染器的诞生(七)--Ambient Occlusion</title>
    <link href="https://crunchybiscuits.github.io/2021/02/17/AmbientOcclusion/"/>
    <id>https://crunchybiscuits.github.io/2021/02/17/AmbientOcclusion/</id>
    <published>2021-02-17T04:23:08.000Z</published>
    <updated>2021-02-17T11:25:06.983Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
      <category term="Renderer" scheme="https://crunchybiscuits.github.io/tags/Renderer/"/>
    
  </entry>
  
  <entry>
    <title>渲染器的诞生(六)--Shadow Mapping</title>
    <link href="https://crunchybiscuits.github.io/2021/02/17/ShadowMapping/"/>
    <id>https://crunchybiscuits.github.io/2021/02/17/ShadowMapping/</id>
    <published>2021-02-17T04:22:47.000Z</published>
    <updated>2021-02-17T15:34:26.431Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
      <category term="Renderer" scheme="https://crunchybiscuits.github.io/tags/Renderer/"/>
    
  </entry>
  
  <entry>
    <title>渲染器的诞生(五)--shader</title>
    <link href="https://crunchybiscuits.github.io/2021/02/17/shader/"/>
    <id>https://crunchybiscuits.github.io/2021/02/17/shader/</id>
    <published>2021-02-17T04:18:18.000Z</published>
    <updated>2021-02-17T04:21:02.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础渲染流程"><a href="#基础渲染流程" class="headerlink" title="基础渲染流程"></a>基础渲染流程</h1><h1 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h1><h2 id="Texture"><a href="#Texture" class="headerlink" title="Texture"></a>Texture</h2><h2 id="Normal-mapping"><a href="#Normal-mapping" class="headerlink" title="Normal mapping"></a>Normal mapping</h2><h2 id="Specular-mapping"><a href="#Specular-mapping" class="headerlink" title="Specular mapping"></a>Specular mapping</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础渲染流程&quot;&gt;&lt;a href=&quot;#基础渲染流程&quot; class=&quot;headerlink&quot; title=&quot;基础渲染流程&quot;&gt;&lt;/a&gt;基础渲染流程&lt;/h1&gt;&lt;h1 id=&quot;Shader&quot;&gt;&lt;a href=&quot;#Shader&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
    
      <category term="Renderer" scheme="https://crunchybiscuits.github.io/tags/Renderer/"/>
    
  </entry>
  
  <entry>
    <title>UV和像素</title>
    <link href="https://crunchybiscuits.github.io/2021/02/15/UV%E5%92%8C%E5%83%8F%E7%B4%A0/"/>
    <id>https://crunchybiscuits.github.io/2021/02/15/UV%E5%92%8C%E5%83%8F%E7%B4%A0/</id>
    <published>2021-02-15T13:23:07.000Z</published>
    <updated>2021-02-17T15:34:14.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UV介绍"><a href="#UV介绍" class="headerlink" title="UV介绍"></a>UV介绍</h1><p>每个模型，都是由一个个的面组成的，而UV纹理，我们可以通俗地看作是由这些所有的面构成的模型的“皮肤”，它的工作方式是将这些三维的“皮肤”二维化分布到一个正方形的画布上，然后通过绘制的贴图，将贴图的细节从正方形的画布投射到三维的空间上。</p><h2 id="在纹理贴图中"><a href="#在纹理贴图中" class="headerlink" title="在纹理贴图中"></a>在纹理贴图中</h2><p>对于纹理贴图而言，一张贴图的U和V坐标的数值范围都是0到1，而不管他的实际分辨率是多少，MAYA会自动把UV纹理坐标换算成贴图的象素坐标。</p><p>“UV”这里是指u,v纹理贴图坐标的简称(它和空间模型的X, Y, Z轴是类似的)，它定义了图片上每个点的位置的信息. 这些点与3D模型是相互联系的， 以决定表面纹理贴图的位置， UV就是将图像上每一个点精确对应到模型物体的表面， 在点与点之间的间隙位置由软件进行图像光滑插值处理， 这就是所谓的UV贴图</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;UV介绍&quot;&gt;&lt;a href=&quot;#UV介绍&quot; class=&quot;headerlink&quot; title=&quot;UV介绍&quot;&gt;&lt;/a&gt;UV介绍&lt;/h1&gt;&lt;p&gt;每个模型，都是由一个个的面组成的，而UV纹理，我们可以通俗地看作是由这些所有的面构成的模型的“皮肤”，它的工作方式是将这些三
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>渲染器的诞生(四)--MVP</title>
    <link href="https://crunchybiscuits.github.io/2021/02/15/MVP/"/>
    <id>https://crunchybiscuits.github.io/2021/02/15/MVP/</id>
    <published>2021-02-15T07:37:01.000Z</published>
    <updated>2021-02-17T03:54:58.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MODEL-VIEW-PROJECTION"><a href="#MODEL-VIEW-PROJECTION" class="headerlink" title="MODEL, VIEW, PROJECTION"></a>MODEL, VIEW, PROJECTION</h1><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><h2 id="Projection"><a href="#Projection" class="headerlink" title="Projection"></a>Projection</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MODEL-VIEW-PROJECTION&quot;&gt;&lt;a href=&quot;#MODEL-VIEW-PROJECTION&quot; class=&quot;headerlink&quot; title=&quot;MODEL, VIEW, PROJECTION&quot;&gt;&lt;/a&gt;MODEL, VIEW, PROJECTI
      
    
    </summary>
    
    
    
      <category term="Renderer" scheme="https://crunchybiscuits.github.io/tags/Renderer/"/>
    
  </entry>
  
  <entry>
    <title>渲染器的诞生(三)--深度缓冲</title>
    <link href="https://crunchybiscuits.github.io/2021/02/13/%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/"/>
    <id>https://crunchybiscuits.github.io/2021/02/13/%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/</id>
    <published>2021-02-13T04:21:06.000Z</published>
    <updated>2021-02-15T07:35:28.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度缓冲"><a href="#深度缓冲" class="headerlink" title="深度缓冲"></a>深度缓冲</h1><p>由于画家算法的缺陷，我们常常在3D渲染中碰到错位的情况，因此引入深度缓冲来解决这样的问题。通过深度缓冲来存放场景中点距离照相机的远近，以此来判断当前像素点应该渲染出的颜色。这样渲染器就可以顺序的去处理场景。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ul><li>遍历每一个三角形<ul><li>遍历三角形中的样本<ul><li>如果当前深度值小于之前的值</li><li>更新样本颜色</li><li>更新深度缓存</li><li>否则什么都不做</li></ul></li></ul></li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历包围盒</span></span><br><span class="line"><span class="keyword">for</span> (P.x=bboxmin.x; P.x&lt;=bboxmax.x; P.x++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (P.y=bboxmin.y; P.y&lt;=bboxmax.y; P.y++) &#123;</span><br><span class="line">        <span class="comment">// 通过重心坐标判断位置</span></span><br><span class="line">        Vec3f bc_screen  = barycentric(pts[<span class="number">0</span>], pts[<span class="number">1</span>], pts[<span class="number">2</span>], P);</span><br><span class="line">        <span class="comment">// 在三角形外就跳过</span></span><br><span class="line">        <span class="keyword">if</span> (bc_screen.x&lt;<span class="number">0</span> || bc_screen.y&lt;<span class="number">0</span> || bc_screen.z&lt;<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        P.z = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 获取z值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) P.z += pts[i][<span class="number">2</span>]*bc_screen[i];</span><br><span class="line">        <span class="comment">// 深度缓存更新</span></span><br><span class="line">        <span class="keyword">if</span> (zbuffer[<span class="keyword">int</span>(P.x+P.y*<span class="built_in">width</span>)]&lt;P.z) &#123;</span><br><span class="line">            zbuffer[<span class="keyword">int</span>(P.x+P.y*<span class="built_in">width</span>)] = P.z;</span><br><span class="line">            <span class="built_in">image</span>.<span class="built_in">set</span>(P.x, P.y, color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深度缓冲&quot;&gt;&lt;a href=&quot;#深度缓冲&quot; class=&quot;headerlink&quot; title=&quot;深度缓冲&quot;&gt;&lt;/a&gt;深度缓冲&lt;/h1&gt;&lt;p&gt;由于画家算法的缺陷，我们常常在3D渲染中碰到错位的情况，因此引入深度缓冲来解决这样的问题。通过深度缓冲来存放场景中点距离照相
      
    
    </summary>
    
    
    
      <category term="Renderer" scheme="https://crunchybiscuits.github.io/tags/Renderer/"/>
    
  </entry>
  
  <entry>
    <title>渲染器的诞生(二)--三角光栅</title>
    <link href="https://crunchybiscuits.github.io/2021/02/13/%E4%B8%89%E8%A7%92%E5%85%89%E6%A0%85%E5%8C%96%E5%92%8C%E8%83%8C%E9%9D%A2%E5%89%94%E9%99%A4/"/>
    <id>https://crunchybiscuits.github.io/2021/02/13/%E4%B8%89%E8%A7%92%E5%85%89%E6%A0%85%E5%8C%96%E5%92%8C%E8%83%8C%E9%9D%A2%E5%89%94%E9%99%A4/</id>
    <published>2021-02-13T04:20:51.000Z</published>
    <updated>2021-02-16T13:58:45.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三角光栅化"><a href="#三角光栅化" class="headerlink" title="三角光栅化"></a>三角光栅化</h1><p>通过之前的Bresenham画线算法，最简单的方式便是通过三组两两点的直线算法来实现画出三角形</p><p>在三角形之间通过平行的扫描线进行渲染</p><p><strong>一个好的光栅化算法需要做到以下几点</strong></p><ul><li>简单快速</li><li>不会受到输入的数据顺序的影响</li><li>如果两个三角形有公共点，那么这两个三角形之间重合的部分不能有断点之类出现</li></ul><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>光栅化的过程，扫描线算法line sweeping：</p><ol><li>将三角形的点根据y的值按照升序进行排列</li><li>将三角形分成平顶和平底两部分</li><li>扫描线进行渲染</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triangle</span><span class="params">(Vec2i t0, Vec2i t1, Vec2i t2, TGAImage&amp; <span class="built_in">image</span>, TGAColor color)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这不是三角形哈哈哈哈哈哈哈哈</span></span><br><span class="line">    <span class="keyword">if</span> (t0.y == t1.y &amp;&amp; t0.y == t2.y)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将三个点进行降序排序</span></span><br><span class="line">    <span class="keyword">if</span> (t0.y &gt; t1.y)<span class="built_in">std</span>::swap(t0, t1);</span><br><span class="line">    <span class="keyword">if</span> (t0.y &gt; t2.y)<span class="built_in">std</span>::swap(t0, t2);</span><br><span class="line">    <span class="keyword">if</span> (t1.y &gt; t2.y)<span class="built_in">std</span>::swap(t1, t2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总的高度</span></span><br><span class="line">    <span class="keyword">int</span> total_height = t2.y - t1.y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并进行渲染</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total_height; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断是否到第二部分，或者开始三角形就是平底的</span></span><br><span class="line">        <span class="keyword">bool</span> second_half = i &gt; (t1.y - t0.y) || t1.y==t0.y;</span><br><span class="line">        <span class="keyword">int</span> segment_height = second_half ? t2.y - t1.y : t1.y - t0.y;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> alpha = (<span class="keyword">float</span>)i / total_height;</span><br><span class="line">        <span class="comment">// 如果是在第二部分，应当减去第一段的值</span></span><br><span class="line">        <span class="keyword">float</span> beta = (<span class="keyword">float</span>)(i - (second_half ? t1.y - t0.y : <span class="number">0</span>)) / segment_height;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行插值</span></span><br><span class="line">        Vec2i A = t0 + (t2 - t0) * alpha;</span><br><span class="line">        Vec2i B = second_half ? t1 + (t2 - t1) * beta : t0 + (t1 - t0) * beta;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查A，B位置</span></span><br><span class="line">        <span class="keyword">if</span> (A.x &gt; B.x)<span class="built_in">std</span>::swap(A, B);</span><br><span class="line">        <span class="comment">// 扫描</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = A.x; j &lt;= B.x; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从t0开始</span></span><br><span class="line">            <span class="built_in">image</span>.<span class="built_in">set</span>(j, t0.y + i, color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="包围盒和重心坐标"><a href="#包围盒和重心坐标" class="headerlink" title="包围盒和重心坐标"></a>包围盒和重心坐标</h1><h2 id="重心坐标"><a href="#重心坐标" class="headerlink" title="重心坐标"></a>重心坐标</h2><p>在2D坐标系中，给定三角形ABC，存在一点p，有系数u,v使得</p><p>P = (1-u-v) * P1 + u * P2 + v * P3</p><p>通过连立方程组我们可以得到</p><ul><li>w1 = 1 - w2 - w3</li><li>Px = w1 * P1x + w2 * P2x + w3 * P3x</li><li>Py = w1 * P1y + w2 * P2y + w3 * P3y</li></ul><p>进行变换得到</p><ul><li>w1 = 1 - w2 - w3</li><li>Px - P3x = w1 * (P1x - P3x) + w2 * (P2x - P3x)</li><li>Py - P3y = w1 * (P1y - P3y) + w2 * (P2y - P3y)</li></ul><p>令C = P-P3, A = P1-P3, B = P2-P3， 可得</p><ul><li>Cx = w1 * Ax + w2 * Bx</li><li>Cy = w1* Ay + w2 * By</li><li>w3 = 1 - w1 - w2</li></ul><p>最后解出方程组可得，三个解是与对应的三角形面积成比例的，因此可以先用叉乘计算三角形面积，再求面积的比值</p><h2 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h2><ul><li>首先查找包围盒</li><li>遍历包围盒中的点<ul><li>判断点是否在三角形中</li><li>对三角形内的点进行光栅化</li></ul></li></ul><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec3f <span class="title">barycentric</span><span class="params">(Vec2i *pts, Vec2i p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 叉乘计算面积比值</span></span><br><span class="line">    Vec3f u = cross(Vec3f(pts[<span class="number">2</span>][<span class="number">0</span>] - pts[<span class="number">0</span>][<span class="number">0</span>], pts[<span class="number">1</span>][<span class="number">0</span>] - pts[<span class="number">0</span>][<span class="number">0</span>], pts[<span class="number">0</span>][<span class="number">0</span>] - P[<span class="number">0</span>]), Vec3f(pts[<span class="number">2</span>][<span class="number">1</span>] - pts[<span class="number">0</span>][<span class="number">1</span>], pts[<span class="number">1</span>][<span class="number">1</span>] - pts[<span class="number">0</span>][<span class="number">1</span>], pts[<span class="number">0</span>][<span class="number">1</span>] - P[<span class="number">1</span>]));</span><br><span class="line">    <span class="comment">// 如果不是三角形，那么直接返回一个不合法的值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(u[<span class="number">2</span>]) &lt; <span class="number">1</span>) <span class="keyword">return</span> Vec3f(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 除u.z是为了归一</span></span><br><span class="line">    <span class="keyword">return</span> Vec3f(<span class="number">1.f</span> - (u.x + u.y) / u.z, u.y / u.z, u.x / u.z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triangle</span><span class="params">(Vec2i *pts, TGAImage&amp; <span class="built_in">image</span>, TGAColor color)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置包围盒</span></span><br><span class="line">    <span class="function">Vec2i <span class="title">bboxmin</span><span class="params">(<span class="built_in">image</span>.get_width()<span class="number">-1</span>, <span class="built_in">image</span>.get_height()<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="function">Vec2i <span class="title">bboxmax</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Vec2i <span class="title">clamp</span><span class="params">(<span class="built_in">image</span>.get_width() <span class="number">-1</span>, <span class="built_in">image</span>.get_height()<span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            bboxmin[j] = <span class="built_in">std</span>::<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">std</span>::<span class="built_in">min</span>(bboxmin[j], pts[i][j]));</span><br><span class="line">            bboxmax[j] = <span class="built_in">std</span>::<span class="built_in">min</span>(clamp[j], <span class="built_in">std</span>::<span class="built_in">max</span>(bboxmax[j], pts[i][j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;三角光栅化&quot;&gt;&lt;a href=&quot;#三角光栅化&quot; class=&quot;headerlink&quot; title=&quot;三角光栅化&quot;&gt;&lt;/a&gt;三角光栅化&lt;/h1&gt;&lt;p&gt;通过之前的Bresenham画线算法，最简单的方式便是通过三组两两点的直线算法来实现画出三角形&lt;/p&gt;
&lt;p&gt;在三角
      
    
    </summary>
    
    
    
      <category term="Renderer" scheme="https://crunchybiscuits.github.io/tags/Renderer/"/>
    
  </entry>
  
  <entry>
    <title>渲染器的诞生(一)--Bresenham直线算法</title>
    <link href="https://crunchybiscuits.github.io/2021/02/12/Bresenham%E7%9B%B4%E7%BA%BF%E7%AE%97%E6%B3%95/"/>
    <id>https://crunchybiscuits.github.io/2021/02/12/Bresenham%E7%9B%B4%E7%BA%BF%E7%AE%97%E6%B3%95/</id>
    <published>2021-02-12T04:33:42.000Z</published>
    <updated>2021-02-14T04:34:04.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bresenham-直线算法"><a href="#Bresenham-直线算法" class="headerlink" title="Bresenham 直线算法"></a>Bresenham 直线算法</h1><p>来自tinyrenderer的第一课，目标是能够画出网格</p><p>常见的画线算法除了Bresenham算法，还有数值微分法(每次运算都需要一个浮点乘法和舍入运算)和中点画线法</p><h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><p>在屏幕上直线是由一个像素一个像素小块儿组成的因此没法像现实世界中在纸张上那样直接连线，只是由于像素小块在屏幕上足够多，而看起来像直线。Bresenham算法主要目的便是处理画线。</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p><strong>这里先默认斜率在0-1之间，直线指向第一象限</strong></p><ol><li>假设斜率<strong>k</strong>在0-1之间<ol><li>在x的变化上，每一次都是递增1</li><li>y要么保持不变要么递增1</li><li>我们通过一个参数 <strong>d</strong>，d的范围也在0-1之间，通过这个参数来确定y的变化。</li></ol></li><li>d的初始值为0，每一次变化相应的增加直线的斜率值，即 d=d+k。<ol><li>当d&gt;1的时候就前去1，保证d始终在0-1之间变换。</li><li>若d&gt;=0.5，那么与垂直网格的交点更加接近，则取当前像素右上方的像素(x+1, y+1)</li><li>若d&lt;0.5，那么取(x+1, y)</li></ol></li></ol><h3 id="误差项的优化"><a href="#误差项的优化" class="headerlink" title="误差项的优化"></a>误差项的优化</h3><ol><li>由于d在与0.5比较，因此假设 <strong>e</strong> = d-0.5，那么每次只需判定e&gt;=0即可</li><li>但是上述的计算需要用到小数和除法的计算，为了方便硬件计算假设 <strong>e’</strong>=2*e*dx</li><li>最终化简得到误差项 <strong>p</strong> = 2dy-dx</li></ol><h3 id="扩展到所有情况"><a href="#扩展到所有情况" class="headerlink" title="扩展到所有情况"></a>扩展到所有情况</h3><p>刚才只讨论了斜率在0-1，指向第一象限的情况，那么扩展到所有情况便有，斜率&gt;1和在不同象限</p><ol><li>对于斜率的变化，在同一象限中是关于y=x对称的，因此将代码中x和y对调位置，例如p=2dy-dx就变成p=2dx-dy</li><li>对于不同象限则调整符号，使其转移到第一象限进行计算。例如, 对于第二象限 dx &lt; 0, dy &gt; 0, 那么就取其关于y轴对称的点 (-x1, y1) (-x2, y2)应用Bresenham算法计算, 但是最后输出的点仍然是 (x1, y1) 而不是 (-x1, y1)</li></ol><p><strong>所有情况汇总：</strong></p><p><strong>若dx &gt; 0, dy &gt; 0, 0&lt; m &lt; 1:</strong></p><p>xi = x1, yi = y1</p><p>第一项: pi = 2dy -dx</p><p>若pi &lt; 0: pi = pi + 2dy, yi = yi</p><p>若pi &gt; 0: pi = pi + 2dy - 2dx, yi = yi + 1</p><p>xi = xi + 1</p><p>输出: (xi, yi)</p><p><strong>若dx &gt; 0, dy &gt; 0, m &gt; 1:</strong></p><p>xi = x1, yi = y1</p><p>第一项: pi = 2dx -dy</p><p>若pi &lt; 0: pi = pi + 2dx, xi = xi</p><p>若pi &gt; 0: pi = pi + 2dx - 2dy, xi = xi + 1</p><p>yi = yi + 1</p><p>输出: (xi, yi)</p><p><strong>若dx &gt; 0, dy &lt; 0, 0&lt; m &lt; 1:</strong></p><p>xi = x1, yi = -y1</p><p>第一项: pi = 2dy -dx</p><p>若pi &lt; 0: pi = pi + 2dy, yi = yi</p><p>若pi &gt; 0: pi = pi + 2dy - 2dx, yi = yi + 1</p><p>xi = xi + 1</p><p>输出: (xi, -yi)</p><p><strong>若dx &gt; 0, dy &lt; 0, m &gt; 1:</strong></p><p>xi = x1, yi = -y1</p><p>第一项: pi = 2dx -dy</p><p>若pi &lt; 0: pi = pi + 2dx, xi = xi</p><p>若pi &gt; 0: pi = pi + 2dx - 2dy, xi = xi + 1</p><p>yi = yi + 1</p><p>输出: (xi, yi)</p><p><strong>若dx &lt; 0, dy &gt; 0, 0&lt; m &lt; 1:</strong></p><p>xi = -x1, yi = y1</p><p>第一项: pi = 2dy -dx</p><p>若pi &lt; 0: pi = pi + 2dy, yi = yi</p><p>若pi &gt; 0: pi = pi + 2dy - 2dx, yi = yi + 1</p><p>xi = xi + 1</p><p>输出: (-xi, yi)</p><p><strong>若dx &lt; 0, dy &gt; 0, m &gt; 1:</strong></p><p>xi = -x1, yi = y1</p><p>第一项: pi = 2dx -dy</p><p>若pi &lt; 0: pi = pi + 2dx, xi = xi</p><p>若pi &gt; 0: pi = pi + 2dx - 2dy, xi = xi + 1</p><p>yi = yi + 1</p><p>输出: (-xi, yi)</p><p><strong>若dx &lt; 0, dy &lt; 0, 0&lt; m &lt; 1:</strong></p><p>xi = -x1, yi = -y1</p><p>第一项: pi = 2dy -dx</p><p>若pi &lt; 0: pi = pi + 2dy, yi = yi</p><p>若pi &gt; 0: pi = pi + 2dy - 2dx, yi = yi + 1</p><p>xi = xi + 1</p><p>输出: (-xi, -yi)</p><p><strong>若dx &lt; 0, dy &lt; 0, m &gt; 1:</strong></p><p>xi = -x1, yi = -y1</p><p>第一项: pi = 2dx -dy</p><p>若pi &lt; 0: pi = pi + 2dx, xi = xi</p><p>若pi &gt; 0: pi = pi + 2dx - 2dy, xi = xi + 1</p><p>yi = yi + 1</p><p>输出: (-xi, -yi)</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">line</span><span class="params">(Vec2i p0, Vec2i p1, TGAImage&amp; <span class="built_in">image</span>, TGAColor color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> steep = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 判断斜率&gt;1还是在0到1之间</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(p0.x - p1.x) &lt; <span class="built_in">std</span>::<span class="built_in">abs</span>(p0.y - p1.y))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(p0.x, p0.y);</span><br><span class="line">        <span class="built_in">std</span>::swap(p1.x, p1.y);</span><br><span class="line">        steep = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p0.x &gt; p1.x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(p0.x, p1.x);</span><br><span class="line">        <span class="built_in">std</span>::swap(p0.y, p1.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dx = p1.x - p0.x;</span><br><span class="line">    <span class="keyword">int</span> dy = p1.y - p0.y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化后的误差项</span></span><br><span class="line">    <span class="comment">// 将误差项变成e*2*dx</span></span><br><span class="line">    <span class="keyword">float</span> derror = <span class="built_in">std</span>::<span class="built_in">abs</span>(dy)*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">float</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> y = p0.y;</span><br><span class="line">    <span class="comment">// 优化判断的计算</span></span><br><span class="line">    <span class="keyword">if</span> (steep)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = p0.x; x &lt;= p1.x; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 斜率&gt;1结果需交换x和y</span></span><br><span class="line">            <span class="built_in">image</span>.<span class="built_in">set</span>(y, x, color);</span><br><span class="line">            error += derror;</span><br><span class="line">            <span class="keyword">if</span> (error &gt; dx)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 根据上升还是下降对y进行取值</span></span><br><span class="line">                y += (p1.y &gt; p0.y ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">                error -= dx * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = p0.x; x &lt;= p1.x; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">image</span>.<span class="built_in">set</span>(x, y, color);</span><br><span class="line">            error += derror;</span><br><span class="line">            <span class="keyword">if</span> (error &gt; dx)</span><br><span class="line">            &#123;</span><br><span class="line">                y += (p1.y &gt; p0.y ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">                error -= dx*<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Bresenham-直线算法&quot;&gt;&lt;a href=&quot;#Bresenham-直线算法&quot; class=&quot;headerlink&quot; title=&quot;Bresenham 直线算法&quot;&gt;&lt;/a&gt;Bresenham 直线算法&lt;/h1&gt;&lt;p&gt;来自tinyrenderer的第一课，目标是
      
    
    </summary>
    
    
    
      <category term="Renderer" scheme="https://crunchybiscuits.github.io/tags/Renderer/"/>
    
  </entry>
  
  <entry>
    <title>GAMES101Assignment4</title>
    <link href="https://crunchybiscuits.github.io/2020/12/21/GAMES101Assignment4/"/>
    <id>https://crunchybiscuits.github.io/2020/12/21/GAMES101Assignment4/</id>
    <published>2020-12-21T01:03:19.000Z</published>
    <updated>2020-12-22T04:12:22.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GAMES101-Assignment4-对应Lecture10-11"><a href="#GAMES101-Assignment4-对应Lecture10-11" class="headerlink" title="GAMES101 Assignment4 (对应Lecture10-11)"></a>GAMES101 Assignment4 (对应Lecture10-11)</h1><p>课程作业框架来自<a href="http://games-cn.org/forums/topic/allhw/">GAMES</a></p><h2 id="基础部分："><a href="#基础部分：" class="headerlink" title="基础部分："></a>基础部分：</h2><p>目标要求：需要实现de Casteljau 算法来绘制由4 个控制点表示的Bézier 曲线</p><p><strong>main.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    贝塞尔递归</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function">cv::Point2f <span class="title">recursive_bezier</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Point2f&gt; &amp;control_points, <span class="keyword">float</span> t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Implement de Casteljau&#x27;s algorithm</span></span><br><span class="line">    <span class="keyword">int</span> control_points_num = control_points.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (control_points_num == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">cv::Point2f <span class="title">pix_center_point</span><span class="params">(<span class="number">0.5</span>,<span class="number">0.5</span>)</span></span>;</span><br><span class="line">        pix_center_point += (cv::Point2f) control_points[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> pix_center_point;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cv::Point2d left_bezier_point, right_bezier_point;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Point2f&gt; <span class="title">left_control_points</span><span class="params">(&amp;(control_points[<span class="number">0</span>]), &amp;(control_points[control_points_num - <span class="number">1</span>]))</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Point2f&gt; <span class="title">right_control_points</span><span class="params">(&amp;(control_points[<span class="number">1</span>]), &amp;(control_points[control_points_num]))</span></span>;</span><br><span class="line">        left_bezier_point = recursive_bezier(left_control_points, t);</span><br><span class="line">        right_bezier_point = recursive_bezier(right_control_points, t);</span><br><span class="line">        <span class="keyword">return</span> left_bezier_point * (<span class="number">1</span>-t) + right_bezier_point*t;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bezier</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Point2f&gt; &amp;control_points, cv::Mat &amp;window)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Iterate through all t = 0 to t = 1 with small steps, and call de Casteljau&#x27;s </span></span><br><span class="line">    <span class="comment">// recursive Bezier algorithm.</span></span><br><span class="line">    <span class="keyword">static</span> cv::Point2f <span class="built_in">point</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> t = <span class="number">0.0</span>; t &lt;= <span class="number">1.0</span>; t+=<span class="number">0.005</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">point</span> = recursive_bezier(control_points, t);</span><br><span class="line">        window.at&lt;cv::Vec3b&gt;(<span class="built_in">point</span>.y, <span class="built_in">point</span>.x)[<span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GAMES101-Assignment4-对应Lecture10-11&quot;&gt;&lt;a href=&quot;#GAMES101-Assignment4-对应Lecture10-11&quot; class=&quot;headerlink&quot; title=&quot;GAMES101 Assignment4 (
      
    
    </summary>
    
    
    
      <category term="GAMES101" scheme="https://crunchybiscuits.github.io/tags/GAMES101/"/>
    
  </entry>
  
  <entry>
    <title>目前进度</title>
    <link href="https://crunchybiscuits.github.io/2020/12/21/%E7%9B%AE%E5%89%8D%E8%BF%9B%E5%BA%A6/"/>
    <id>https://crunchybiscuits.github.io/2020/12/21/%E7%9B%AE%E5%89%8D%E8%BF%9B%E5%BA%A6/</id>
    <published>2020-12-21T00:42:38.000Z</published>
    <updated>2021-02-13T04:25:49.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="技能进展"><a href="#技能进展" class="headerlink" title="技能进展"></a>技能进展</h1><h2 id="CV"><a href="#CV" class="headerlink" title="CV"></a>CV</h2><ul><li><input disabled="" type="checkbox"> keras文档阅读</li><li><input checked="" disabled="" type="checkbox"> keras基础使用  </li></ul><h2 id="图形学"><a href="#图形学" class="headerlink" title="图形学"></a>图形学</h2><ul><li><input checked="" disabled="" type="checkbox"> GAMES101 课程看完</li><li><input disabled="" type="checkbox"> tinyRender</li><li><input disabled="" type="checkbox"> GAMES101 笔记<ul><li>目前进度 0/22</li></ul></li><li><input disabled="" type="checkbox"> GAMES101 Assignment<ul><li>目前进度 4/8</li></ul></li><li><input disabled="" type="checkbox"> GAMES101 大作业</li><li><input disabled="" type="checkbox"> OpenGL 入门</li><li><input disabled="" type="checkbox"> OpenGL 实操</li></ul><h2 id="Unity基础"><a href="#Unity基础" class="headerlink" title="Unity基础"></a>Unity基础</h2><ul><li><input disabled="" type="checkbox"> Unity3D基础操作入门</li><li><input checked="" disabled="" type="checkbox"> 《Unity3d shader入门精要》第一遍</li><li><input disabled="" type="checkbox"> 入门精要认真实现</li><li><input disabled="" type="checkbox"> k大的课</li><li><input disabled="" type="checkbox"> C++底层</li></ul><h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><ul><li>计算机网络</li><li>操作系统</li></ul><h2 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;技能进展&quot;&gt;&lt;a href=&quot;#技能进展&quot; class=&quot;headerlink&quot; title=&quot;技能进展&quot;&gt;&lt;/a&gt;技能进展&lt;/h1&gt;&lt;h2 id=&quot;CV&quot;&gt;&lt;a href=&quot;#CV&quot; class=&quot;headerlink&quot; title=&quot;CV&quot;&gt;&lt;/a&gt;CV&lt;/h
      
    
    </summary>
    
    
    
      <category term="杂" scheme="https://crunchybiscuits.github.io/tags/%E6%9D%82/"/>
    
  </entry>
  
  <entry>
    <title>GAMES101Assignment3</title>
    <link href="https://crunchybiscuits.github.io/2020/12/20/GAMES101Assignment3/"/>
    <id>https://crunchybiscuits.github.io/2020/12/20/GAMES101Assignment3/</id>
    <published>2020-12-20T02:10:45.000Z</published>
    <updated>2020-12-20T10:33:53.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GAMES101-Assignment3-对应Lecture7-9"><a href="#GAMES101-Assignment3-对应Lecture7-9" class="headerlink" title="GAMES101 Assignment3 (对应Lecture7-9)"></a>GAMES101 Assignment3 (对应Lecture7-9)</h1><p>课程作业框架来自<a href="http://games-cn.org/forums/topic/allhw/">GAMES</a></p><h2 id="基础部分："><a href="#基础部分：" class="headerlink" title="基础部分："></a>基础部分：</h2><p>目标要求：实现与作业2 类似的插值算法，实现法向量、颜色、纹理颜色的插值。</p><p><strong>Rasterizer.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 在三角形内检测函数</span></span><br><span class="line"><span class="comment">* parameters:</span></span><br><span class="line"><span class="comment">*        point:x,y</span></span><br><span class="line"><span class="comment">*        triangle:_v</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">insideTriangle</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// TODO : Implement this function to check if the point (x, y) is inside the triangle represented by _v[0], _v[1], _v[2]</span></span><br><span class="line">    <span class="comment">// float xp = x, yp = y;</span></span><br><span class="line">    <span class="comment">// float xa = _v[0].x(), ya = _v[0].y();</span></span><br><span class="line">    <span class="comment">// float xb = _v[1].x(), yb = _v[1].y();</span></span><br><span class="line">    <span class="comment">// float xc = _v[2].x(), yc = _v[2].y();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// float gamma = ((xb-xa)*(yp-ya)-(xp-xa)*(yb-ya))/((xb-xa)*(yc-ya)-(xc-xa)*(yb-ya));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// float beta = (xp-xa-gamma*(xc-xa))/(xb-xa);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// float alpha = 1.0f - gamma - beta;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// return alpha&gt;0 &amp;&amp; alpha&lt;1; </span></span><br><span class="line"></span><br><span class="line">    <span class="function">Vector3f <span class="title">P</span><span class="params">(x,y,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ((_v[<span class="number">0</span>]-_v[<span class="number">1</span>]).cross(P-_v[<span class="number">1</span>]).z()&lt;<span class="number">0</span>&amp;&amp;</span><br><span class="line">            (_v[<span class="number">2</span>]-_v[<span class="number">0</span>]).cross(P-_v[<span class="number">0</span>]).z()&lt;<span class="number">0</span>&amp;&amp;</span><br><span class="line">            (_v[<span class="number">1</span>]-_v[<span class="number">2</span>]).cross(P-_v[<span class="number">2</span>]).z()&lt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Screen space rasterization</span></span><br><span class="line"><span class="comment">//此版本为使用MSAA版本，如不使用直接使用insideTriangle函数同时判断z-buffer即可</span></span><br><span class="line"><span class="keyword">void</span> rst::rasterizer::rasterize_triangle(<span class="keyword">const</span> Triangle&amp; t) &#123;</span><br><span class="line">    <span class="keyword">auto</span> v = t.toVector4();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// TODO : Find out the bounding box of current triangle.</span></span><br><span class="line">    <span class="comment">// iterate through the pixel and find if the current pixel is inside the triangle</span></span><br><span class="line">    <span class="keyword">int</span> left_bound = <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">0</span>].x(), <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">1</span>].x(), v[<span class="number">2</span>].x()));</span><br><span class="line">    <span class="keyword">int</span> right_bound = <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">0</span>].x(), <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">1</span>].x(), v[<span class="number">2</span>].x()));</span><br><span class="line">    <span class="keyword">int</span> bottom_bound = <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">0</span>].y(), <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">1</span>].y(), v[<span class="number">2</span>].y()));</span><br><span class="line">    <span class="keyword">int</span> up_bound = <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">0</span>].y(), <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">1</span>].y(), v[<span class="number">2</span>].y()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If so, use the following code to get the interpolated z value.</span></span><br><span class="line">    <span class="comment">//auto[alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);</span></span><br><span class="line">    <span class="comment">//float w_reciprocal = 1.0/(alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());</span></span><br><span class="line">    <span class="comment">//float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();</span></span><br><span class="line">    <span class="comment">//z_interpolated *= w_reciprocal;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO : set the current pixel (use the set_pixel function) to the color of the triangle (use getColor function) if it should be painted.</span></span><br><span class="line">    </span><br><span class="line">    Eigen::Vector3f p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = left_bound;x&lt;=right_bound;x++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = bottom_bound; y &lt;= up_bound; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用MSAA</span></span><br><span class="line">            <span class="keyword">float</span> percent = insideTrianglePercent(x,y,t.v,<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">if</span> (percent&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">//Depth interpolated</span></span><br><span class="line">            <span class="keyword">auto</span>[alpha, beta, gamma] = computeBarycentric2D(i+<span class="number">0.5</span>, j+<span class="number">0.5</span>, t.v);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> Z = <span class="number">1.0</span> / (alpha / v[<span class="number">0</span>].w() + beta / v[<span class="number">1</span>].w() + gamma / v[<span class="number">2</span>].w());</span><br><span class="line">            <span class="keyword">float</span> zp = alpha * v[<span class="number">0</span>].z() / v[<span class="number">0</span>].w() + beta * v[<span class="number">1</span>].z() / v[<span class="number">1</span>].w() + gamma * v[<span class="number">2</span>].z() / v[<span class="number">2</span>].w();</span><br><span class="line">            zp*=Z;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(zp &lt; depth_buf[get_index(i,j)])</span><br><span class="line">            &#123;</span><br><span class="line">                depth_buf[get_index(i,j)] = zp;</span><br><span class="line">                <span class="keyword">auto</span> interpolated_color = interpolate(alpha, beta, gamma, t.color[<span class="number">0</span>], t.color[<span class="number">1</span>], t.color[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> interpolated_normal = interpolate(alpha, beta, gamma,t.normal[<span class="number">0</span>],t.normal[<span class="number">1</span>],t.normal[<span class="number">2</span>],<span class="number">1</span>).normalized();</span><br><span class="line">                <span class="keyword">auto</span> interpolated_texcoords = interpolate(alpha, beta, gamma,t.tex_coords[<span class="number">0</span>],t.tex_coords[<span class="number">1</span>],t.tex_coords[<span class="number">2</span>],<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> interpolated_shadingcoords = interpolate(alpha, beta, gamma,view_pos[<span class="number">0</span>],view_pos[<span class="number">1</span>],view_pos[<span class="number">2</span>],<span class="number">1</span>);</span><br><span class="line">                <span class="function">fragment_shader_payload <span class="title">payload</span><span class="params">(interpolated_color,interpolated_normal,interpolated_texcoords,texture ? &amp;*texture : <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">                payload.view_pos = interpolated_shadingcoords;</span><br><span class="line">                <span class="keyword">auto</span> pixel_color = fragment_shader(payload);</span><br><span class="line">                set_pixel(Eigen::Vector2i(i,j),pixel_color);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GAMES101-Assignment3-对应Lecture7-9&quot;&gt;&lt;a href=&quot;#GAMES101-Assignment3-对应Lecture7-9&quot; class=&quot;headerlink&quot; title=&quot;GAMES101 Assignment3 (对应Le
      
    
    </summary>
    
    
    
      <category term="GAMES101" scheme="https://crunchybiscuits.github.io/tags/GAMES101/"/>
    
  </entry>
  
  <entry>
    <title>GAMES101Assignment2</title>
    <link href="https://crunchybiscuits.github.io/2020/12/18/GAMES101Assignment2/"/>
    <id>https://crunchybiscuits.github.io/2020/12/18/GAMES101Assignment2/</id>
    <published>2020-12-18T01:59:39.000Z</published>
    <updated>2020-12-20T02:09:37.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GAMES101-Assignment2-对应Lecture5-6"><a href="#GAMES101-Assignment2-对应Lecture5-6" class="headerlink" title="GAMES101 Assignment2 (对应Lecture5-6)"></a>GAMES101 Assignment2 (对应Lecture5-6)</h1><p>课程作业框架来自<a href="http://games-cn.org/forums/topic/allhw/">GAMES</a></p><h2 id="基础部分："><a href="#基础部分：" class="headerlink" title="基础部分："></a>基础部分：</h2><p>目标要求：正确实现三角形得栅格化算法，测试点是否在三角形内，正确实现z-buffer算法</p><p><strong>Rasterizer.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 在三角形内检测函数</span></span><br><span class="line"><span class="comment">* parameters:</span></span><br><span class="line"><span class="comment">*        point:x,y</span></span><br><span class="line"><span class="comment">*        triangle:_v</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">insideTriangle</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// TODO : Implement this function to check if the point (x, y) is inside the triangle represented by _v[0], _v[1], _v[2]</span></span><br><span class="line">    <span class="comment">// float xp = x, yp = y;</span></span><br><span class="line">    <span class="comment">// float xa = _v[0].x(), ya = _v[0].y();</span></span><br><span class="line">    <span class="comment">// float xb = _v[1].x(), yb = _v[1].y();</span></span><br><span class="line">    <span class="comment">// float xc = _v[2].x(), yc = _v[2].y();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// float gamma = ((xb-xa)*(yp-ya)-(xp-xa)*(yb-ya))/((xb-xa)*(yc-ya)-(xc-xa)*(yb-ya));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// float beta = (xp-xa-gamma*(xc-xa))/(xb-xa);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// float alpha = 1.0f - gamma - beta;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// return alpha&gt;0 &amp;&amp; alpha&lt;1; </span></span><br><span class="line"></span><br><span class="line">    <span class="function">Vector3f <span class="title">P</span><span class="params">(x,y,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ((_v[<span class="number">0</span>]-_v[<span class="number">1</span>]).cross(P-_v[<span class="number">1</span>]).z()&lt;<span class="number">0</span>&amp;&amp;</span><br><span class="line">            (_v[<span class="number">2</span>]-_v[<span class="number">0</span>]).cross(P-_v[<span class="number">0</span>]).z()&lt;<span class="number">0</span>&amp;&amp;</span><br><span class="line">            (_v[<span class="number">1</span>]-_v[<span class="number">2</span>]).cross(P-_v[<span class="number">2</span>]).z()&lt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Screen space rasterization</span></span><br><span class="line"><span class="comment">//此版本为使用MSAA版本，如不使用直接使用insideTriangle函数同时判断z-buffer即可</span></span><br><span class="line"><span class="keyword">void</span> rst::rasterizer::rasterize_triangle(<span class="keyword">const</span> Triangle&amp; t) &#123;</span><br><span class="line">    <span class="keyword">auto</span> v = t.toVector4();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// TODO : Find out the bounding box of current triangle.</span></span><br><span class="line">    <span class="comment">// iterate through the pixel and find if the current pixel is inside the triangle</span></span><br><span class="line">    <span class="keyword">int</span> left_bound = <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">0</span>].x(), <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">1</span>].x(), v[<span class="number">2</span>].x()));</span><br><span class="line">    <span class="keyword">int</span> right_bound = <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">0</span>].x(), <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">1</span>].x(), v[<span class="number">2</span>].x()));</span><br><span class="line">    <span class="keyword">int</span> bottom_bound = <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">0</span>].y(), <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">1</span>].y(), v[<span class="number">2</span>].y()));</span><br><span class="line">    <span class="keyword">int</span> up_bound = <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">0</span>].y(), <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">1</span>].y(), v[<span class="number">2</span>].y()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If so, use the following code to get the interpolated z value.</span></span><br><span class="line">    <span class="comment">//auto[alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);</span></span><br><span class="line">    <span class="comment">//float w_reciprocal = 1.0/(alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());</span></span><br><span class="line">    <span class="comment">//float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();</span></span><br><span class="line">    <span class="comment">//z_interpolated *= w_reciprocal;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO : set the current pixel (use the set_pixel function) to the color of the triangle (use getColor function) if it should be painted.</span></span><br><span class="line">    </span><br><span class="line">    Eigen::Vector3f p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = left_bound;x&lt;=right_bound;x++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = bottom_bound; y &lt;= up_bound; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用MSAA</span></span><br><span class="line">            <span class="keyword">float</span> percent = insideTrianglePercent(x,y,t.v,<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">if</span> (percent&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span>[alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);</span><br><span class="line">                <span class="keyword">float</span> w_reciprocal = <span class="number">1.0</span>/(alpha / v[<span class="number">0</span>].w() + beta / v[<span class="number">1</span>].w() + gamma / v[<span class="number">2</span>].w());</span><br><span class="line">                <span class="keyword">float</span> z_interpolated = alpha * v[<span class="number">0</span>].z() / v[<span class="number">0</span>].w() + beta * v[<span class="number">1</span>].z() / v[<span class="number">1</span>].w() + gamma * v[<span class="number">2</span>].z() / v[<span class="number">2</span>].w();</span><br><span class="line">                z_interpolated *= w_reciprocal;</span><br><span class="line"></span><br><span class="line">                p.x() = x;</span><br><span class="line">                p.y() = y;</span><br><span class="line">                <span class="keyword">if</span>(z_interpolated &lt; depth_buf[get_index(x,y)])&#123;</span><br><span class="line">                    set_pixel(p,t.getColor(),percent);</span><br><span class="line">                    depth_buf[get_index(x,y)] = z_interpolated;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提高部分："><a href="#提高部分：" class="headerlink" title="提高部分："></a>提高部分：</h2><p>目标要求：实现super-sampling处理反走样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 指定每个像素使用多少个采样点</span></span><br><span class="line"><span class="comment">* parameters:</span></span><br><span class="line"><span class="comment">*    place: x,y</span></span><br><span class="line"><span class="comment">*    vector: _v</span></span><br><span class="line"><span class="comment">*    density: num of sampling</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">insideTrianglePercent</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">const</span> Vector3f* _v, <span class="keyword">int</span> density)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> percent = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> <span class="built_in">step</span> = <span class="built_in">sqrt</span>(density);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算每个采样点的位置参数</span></span><br><span class="line">    <span class="keyword">float</span> fragment_spacing = <span class="number">1.0</span>/<span class="built_in">step</span>;</span><br><span class="line">    <span class="keyword">float</span> margin = fragment_spacing/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">float</span> weight = <span class="number">1.0</span>/density;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">step</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">step</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            percent += insideTriangle(x+margin+fragment_spacing*i,</span><br><span class="line">                        y+margin+fragment_spacing*j,_v)*weight;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> percent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GAMES101-Assignment2-对应Lecture5-6&quot;&gt;&lt;a href=&quot;#GAMES101-Assignment2-对应Lecture5-6&quot; class=&quot;headerlink&quot; title=&quot;GAMES101 Assignment2 (对应Le
      
    
    </summary>
    
    
    
      <category term="GAMES101" scheme="https://crunchybiscuits.github.io/tags/GAMES101/"/>
    
  </entry>
  
  <entry>
    <title>GAMES101 Assignment1</title>
    <link href="https://crunchybiscuits.github.io/2020/12/11/GAMES101Assignment1/"/>
    <id>https://crunchybiscuits.github.io/2020/12/11/GAMES101Assignment1/</id>
    <published>2020-12-11T02:25:28.000Z</published>
    <updated>2020-12-18T15:19:48.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GAMES101-Assignment1-对应Lecture3-4"><a href="#GAMES101-Assignment1-对应Lecture3-4" class="headerlink" title="GAMES101 Assignment1 (对应Lecture3-4)"></a>GAMES101 Assignment1 (对应Lecture3-4)</h1><p>课程作业框架来自<a href="http://games-cn.org/forums/topic/allhw/">GAMES</a></p><h2 id="基础部分："><a href="#基础部分：" class="headerlink" title="基础部分："></a>基础部分：</h2><p>目标要求：需要完成一个旋转矩阵和一个透视投影矩阵，根据给定的三维坐标在屏幕上绘制相应的三角形。</p><p><strong>main.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 绕Z轴旋转矩阵</span></span><br><span class="line"><span class="comment">*    return model</span></span><br><span class="line"><span class="comment">*    parameters:</span></span><br><span class="line"><span class="comment">*        rotation_angle:旋转角度</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function">Eigen::Matrix4f <span class="title">get_model_matrix</span><span class="params">(<span class="keyword">float</span> rotation_angle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Eigen::Matrix4f model = Eigen::Matrix4f::Identity();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Implement this function</span></span><br><span class="line">    <span class="comment">// Create the model matrix for rotating the triangle around the Z axis.</span></span><br><span class="line">    <span class="comment">// Then return it.</span></span><br><span class="line">    <span class="comment">// 框架提供的转为弧度制函数</span></span><br><span class="line">    <span class="keyword">float</span> angle = radian(rotation_angle);</span><br><span class="line">    <span class="keyword">float</span> cos_angle = <span class="built_in">cos</span>(angle);</span><br><span class="line">    <span class="keyword">float</span> sin_angle = <span class="built_in">sin</span>(angle); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 旋转矩阵</span></span><br><span class="line">    Eigen::Matrix4f rotation_matrix;</span><br><span class="line">    rotation_matrix&lt;&lt;cos_angle,-sin_angle,<span class="number">0</span>,<span class="number">0</span>,sin_angle,cos_angle,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>;</span><br><span class="line">    model = rotation_matrix * model;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  透视投影矩阵</span></span><br><span class="line"><span class="comment">*    return Eigen::Matrix4f projection</span></span><br><span class="line"><span class="comment">*    parameters</span></span><br><span class="line"><span class="comment">*        eye_fov: 垂直可视度</span></span><br><span class="line"><span class="comment">*        aspect_ratio: width/height</span></span><br><span class="line"><span class="comment">*        zNear&gt;0, zFar&gt;0</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function">Eigen::Matrix4f <span class="title">get_projection_matrix</span><span class="params">(<span class="keyword">float</span> eye_fov, <span class="keyword">float</span> aspect_ratio,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">float</span> zNear, <span class="keyword">float</span> zFar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Students will implement this function</span></span><br><span class="line">    <span class="comment">// 默认单位矩阵</span></span><br><span class="line">    Eigen::Matrix4f projection = Eigen::Matrix4f::Identity();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Implement this function</span></span><br><span class="line">    <span class="comment">// Create the projection matrix for the given parameters.</span></span><br><span class="line">    <span class="comment">// Then return it.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> half_height = <span class="built_in">tan</span>(eye_fov/<span class="number">2</span>*MY_PI/<span class="number">180</span>)*zNear;</span><br><span class="line">    <span class="keyword">float</span> half_width = aspect_ratio*half_height;</span><br><span class="line">    <span class="comment">// 透视范围顶部</span></span><br><span class="line">    <span class="keyword">float</span> t = half_height;</span><br><span class="line">    <span class="comment">// 透视范围右侧</span></span><br><span class="line">    <span class="keyword">float</span> r = half_width;</span><br><span class="line">    <span class="comment">// 透视范围底部</span></span><br><span class="line">    <span class="keyword">float</span> b = -half_height;</span><br><span class="line">    <span class="comment">// 透视范围左侧</span></span><br><span class="line">    <span class="keyword">float</span> l = -half_width;</span><br><span class="line">    <span class="comment">// 近端, 因为是z轴负方向</span></span><br><span class="line">    <span class="keyword">float</span> n = -zNear;</span><br><span class="line">    <span class="comment">// 远端</span></span><br><span class="line">    <span class="keyword">float</span> f = -zFar;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 变换透视投影的方式是将透视投影转变成正交投影</span></span><br><span class="line">    Eigen::Matrix4f S,T,M;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 缩放成canonical</span></span><br><span class="line">    S&lt;&lt;</span><br><span class="line">    <span class="number">2</span>/(r-l),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">2</span>/(t-b),<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>/(n-f),<span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正交投影的平移矩阵，平移到原点</span></span><br><span class="line">    T&lt;&lt;</span><br><span class="line">    <span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,-(l+r)/<span class="number">2</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-(b+t)/<span class="number">2</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-(n+f)/<span class="number">2</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 透视投影转正交投影</span></span><br><span class="line">    M&lt;&lt;</span><br><span class="line">    zNear,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,zNear,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,zNear+zFar,-zFar*zNear,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    projection = S * T * M * projection;</span><br><span class="line">    <span class="keyword">return</span> projection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提高部分："><a href="#提高部分：" class="headerlink" title="提高部分："></a>提高部分：</h2><p>目标要求：在main.cpp实现一个函数完成绕任意过原点轴的旋转变换矩阵</p><p>绕任意轴旋转函数(<strong>罗德里格斯公式</strong>)</p><p>绕n轴旋转α角度</p><p><strong>R(n,α) = cos(α) * I + (1 - cos(α)) * n * n_transpose + sin(α) * N；其中I为单位矩阵，N为n的反对称阵</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">*绕axis轴旋转rotation_angle</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function">Eigen::Matrix4f <span class="title">get_rotation</span><span class="params">(Vector3f axis, <span class="keyword">float</span> rotation_angle)</span></span>&#123;</span><br><span class="line">    Eigen::Matrix4f model = Eigen::Matrix4f::Identity();</span><br><span class="line">    <span class="keyword">float</span> angle = radian(rotation_angle);</span><br><span class="line">    </span><br><span class="line">    Eigen::Matrix3f I = Eigen::Matrix3f::Identity();</span><br><span class="line">    <span class="comment">// n的反对称阵</span></span><br><span class="line">    Eigen::Matrix3f N;</span><br><span class="line">    N&lt;&lt;</span><br><span class="line">         <span class="number">0</span>, -axis.z(), axis.y(),</span><br><span class="line">        axis.z(), <span class="number">0</span>, -axis.x(),</span><br><span class="line">        -axis.y(), axis.x(), <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 罗德里格斯</span></span><br><span class="line">    Eigen::Matrix3f rotation_matrix = <span class="built_in">cos</span>(angle) * I + (<span class="number">1</span>-<span class="built_in">cos</span>(angle)) * axis * axis.transpose() + <span class="built_in">sin</span>(angle) * N;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将3*3变成4*4</span></span><br><span class="line">    model.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>,<span class="number">0</span>) = rotation_matrix;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> model.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里main.cpp的main函数中两个位置的set_model切换为使用get_rotation函数，并自己设定axis</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GAMES101-Assignment1-对应Lecture3-4&quot;&gt;&lt;a href=&quot;#GAMES101-Assignment1-对应Lecture3-4&quot; class=&quot;headerlink&quot; title=&quot;GAMES101 Assignment1 (对应Le
      
    
    </summary>
    
    
    
      <category term="GAMES101" scheme="https://crunchybiscuits.github.io/tags/GAMES101/"/>
    
  </entry>
  
  <entry>
    <title>shader入门-(线性代数)</title>
    <link href="https://crunchybiscuits.github.io/2020/09/19/shader%E5%85%A5%E9%97%A8-(%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0)/"/>
    <id>https://crunchybiscuits.github.io/2020/09/19/shader%E5%85%A5%E9%97%A8-(%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0)/</id>
    <published>2020-09-19T01:36:59.000Z</published>
    <updated>2020-12-17T04:07:48.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shader基础数学"><a href="#Shader基础数学" class="headerlink" title="Shader基础数学"></a>Shader基础数学</h1><p>仅用作个人的常用提示，不会有全部详细介绍，资料来自《Unity Shader入门精要》</p><h1 id="笛卡尔坐标系"><a href="#笛卡尔坐标系" class="headerlink" title="笛卡尔坐标系"></a>笛卡尔坐标系</h1><h3 id="笛卡尔坐标系-1"><a href="#笛卡尔坐标系-1" class="headerlink" title="笛卡尔坐标系"></a>笛卡尔坐标系</h3><ul><li><p>构成</p><ul><li><p>原点</p></li><li><p>N条过原点，相互垂直的坐标轴，主要看是几维</p></li></ul></li></ul><p><strong>OpenGL和DirectX使用的笛卡尔坐标系不同</strong></p><p>坐标轴又称作，<strong>基矢量</strong></p><p>长度为1，的基矢量 — <strong>标准正交基</strong></p><p>四维空间 — <strong>齐次坐标系</strong></p><hr><h2 id="左-右手坐标系"><a href="#左-右手坐标系" class="headerlink" title="左/右手坐标系"></a>左/右手坐标系</h2><p> 三维的笛卡尔坐标系并不都是等价的，如果有相同<strong>旋向性</strong>，就可以通过旋转方法来让两个坐标系重合，但是如果旋向性不同，就不能重合。</p><p>在Unity中</p><ul><li><strong>模型空间</strong>和<strong>世界空间</strong>使用了<strong>左手坐标系</strong></li><li><strong>观察空间</strong>使用了<strong>右手坐标系</strong></li></ul><hr><h1 id="点和矢量"><a href="#点和矢量" class="headerlink" title="点和矢量"></a>点和矢量</h1><p>点 – 空间中的一个位置</p><p>矢量/向量 – 包含<strong>模</strong>和<strong>方向</strong>的有向线段， 通常用来表示相对于某个点的偏移，只要模和方向不变，放哪儿都一样</p><h2 id="矢量运算"><a href="#矢量运算" class="headerlink" title="矢量运算"></a>矢量运算</h2><h3 id="点积-—-结果是标量"><a href="#点积-—-结果是标量" class="headerlink" title="点积 — 结果是标量"></a>点积 — 结果是标量</h3><p><strong>a</strong> · <strong>b</strong> = (ax,ay,az) · (bx,by,bz) = axbx + ayby + azbz </p><p><strong>a</strong> · <strong>b</strong> = |<strong>a</strong>||<strong>b</strong>|cosθ </p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul><li><p><strong>a</strong> · <strong>b</strong> = <strong>b</strong> · <strong>a</strong></p></li><li><p>k<strong>a</strong> · <strong>b</strong> = <strong>a</strong> · k<strong>b</strong> </p></li><li><p><strong>a</strong> · (<strong>b</strong> + <strong>c</strong>) = <strong>a</strong> · <strong>b</strong> + <strong>a</strong> · <strong>c</strong>  </p></li><li><p><strong>a</strong> · <strong>a</strong> = |<strong>a</strong>|^2</p></li><li><p>几何意义 — 投影</p></li></ul><h3 id="叉积-—-结果是矢量"><a href="#叉积-—-结果是矢量" class="headerlink" title="叉积 — 结果是矢量"></a>叉积 — 结果是矢量</h3><p><strong>a</strong> X <strong>b</strong> = (ax,ay,az) X (bx,by,bz) = (aybz - azby, azbx - axbz, axby - aybx)</p><p><strong>a</strong> X <strong>b</strong> = |<strong>a</strong>||<strong>b</strong>|sinθ </p><h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><ul><li><strong>a</strong> X <strong>b</strong> ！= <strong>b</strong> X <strong>a</strong></li><li><strong>a</strong> X <strong>b</strong> = - (<strong>b</strong> X <strong>a</strong>)</li></ul><p><strong>a</strong> X <strong>b</strong> 方向的确认，先判断是左手还是右手坐标系，接着</p><hr><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p><strong>对角元素</strong> – 行号和列号相同的元素</p><p><strong>转置矩阵</strong> – r X c 变成 c X r   </p><p>行列式不为0，既是可逆</p><p><strong>正交矩阵</strong> – 矩阵和它转置矩阵的乘积是单位矩阵</p><ul><li>矩阵的每一行，即c1、c2 和c3 是单位矢量，因为只有这样它们与自己的点积才能是1；</li><li>矩阵的每一行，即c1、c2 和c3 之间互相垂直，因为只有这样它们之间的点积才能是0。</li><li>上述两条结论对矩阵的每一列同样适用，因为如果M是正交矩阵的话，MT 也会是正交矩阵。</li></ul><h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><p>线性 – 缩放，旋转，错切，镜像，正交投影</p><p>三维到四维的变化</p><ul><li><p>点 — 添加 1</p></li><li><p>矢量 — 添加 0</p></li></ul><h1 id="基础变换矩阵分解"><a href="#基础变换矩阵分解" class="headerlink" title="基础变换矩阵分解"></a>基础变换矩阵分解</h1><p>一个基础变换矩阵可以分解成4部分</p><p><img src= "/img/loading.gif" data-lazy-src="/img/shader1.jpg" alt=""></p><p>左上角矩阵<strong>M</strong>用于表示旋转和缩放，<strong>t</strong>用来表示平移，<strong>0</strong>表示零矩阵，右下角元素就是标量1</p><p>Unity中旋转顺序是ZXY</p><p>绕坐标系E 下的z 轴旋转z，绕坐标系E 下的y 轴旋转y，绕坐标系E 下的x 轴旋转x，即进行一次旋转时不一起旋转当前坐标系。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Shader基础数学&quot;&gt;&lt;a href=&quot;#Shader基础数学&quot; class=&quot;headerlink&quot; title=&quot;Shader基础数学&quot;&gt;&lt;/a&gt;Shader基础数学&lt;/h1&gt;&lt;p&gt;仅用作个人的常用提示，不会有全部详细介绍，资料来自《Unity Shader
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>链表练习中未注意的点</title>
    <link href="https://crunchybiscuits.github.io/2020/08/19/%E9%93%BE%E8%A1%A8%E7%BB%83%E4%B9%A0%E4%B8%AD%E6%9C%AA%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/"/>
    <id>https://crunchybiscuits.github.io/2020/08/19/%E9%93%BE%E8%A1%A8%E7%BB%83%E4%B9%A0%E4%B8%AD%E6%9C%AA%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/</id>
    <published>2020-08-19T04:19:31.000Z</published>
    <updated>2020-08-19T02:28:50.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="特定深度节点链表"><a href="#特定深度节点链表" class="headerlink" title="特定深度节点链表"></a>特定深度节点链表</h1><p>题目取自《程序员面试金典》4.3</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>类似广度优先遍历，通过遍历每一层，并逐层添加相应节点</p><h3 id="错误来源"><a href="#错误来源" class="headerlink" title="错误来源"></a>错误来源</h3><p>没有正确的处理链表头节点的位置，因为力扣题目里没有直接使用LinkedList类，而是使用了最基本的节点，所以需要使用一个指针对头节点进行保存，另一个指针进行添加操作。</p><p>错误示范</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode[] <span class="title">addLists</span>(<span class="params">ListNode[] listOfLevel, <span class="keyword">int</span> index, TreeNode tree</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tree == <span class="literal">null</span>) <span class="keyword">return</span> listOfLevel;</span><br><span class="line">        ListNode temp = listOfLevel[index];</span><br><span class="line">        <span class="keyword">while</span> (temp!= <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = <span class="keyword">new</span> ListNode(tree.val);</span><br><span class="line">        temp = temp.next;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> listOfLevel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a>正确答案</h3><p>先通过c#，list类对每一层进行节点的创建，设置计数器对每一层的节点数量进行控制，最后再创建答案的数组。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode[] <span class="title">ListOfDepth</span>(<span class="params">TreeNode tree</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    List&lt;ListNode&gt; listOfLevels = <span class="keyword">new</span> List&lt;ListNode&gt;();</span><br><span class="line">    <span class="keyword">int</span> curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> Queue&lt;TreeNode&gt;();</span><br><span class="line">    queue.Enqueue(tree);</span><br><span class="line">    ListNode node = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode find = node;</span><br><span class="line">    <span class="keyword">while</span> (queue.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode temp = queue.Dequeue();</span><br><span class="line">        node.next = <span class="keyword">new</span> ListNode(temp.val);</span><br><span class="line">        node = node.next;</span><br><span class="line">        curr--;</span><br><span class="line">        <span class="keyword">if</span> (temp.left != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            queue.Enqueue(temp.left);</span><br><span class="line">            next++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp.right != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            queue.Enqueue(temp.right);</span><br><span class="line">            next++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curr == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            curr = next;</span><br><span class="line">            next = <span class="number">0</span>;</span><br><span class="line">            listOfLevels.Add(find.next);</span><br><span class="line">            node = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            find = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> listOfLevels.ToArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;特定深度节点链表&quot;&gt;&lt;a href=&quot;#特定深度节点链表&quot; class=&quot;headerlink&quot; title=&quot;特定深度节点链表&quot;&gt;&lt;/a&gt;特定深度节点链表&lt;/h1&gt;&lt;p&gt;题目取自《程序员面试金典》4.3&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot;
      
    
    </summary>
    
    
    
      <category term="Linked List" scheme="https://crunchybiscuits.github.io/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList介绍</title>
    <link href="https://crunchybiscuits.github.io/2020/08/10/LinkedList%E4%BB%8B%E7%BB%8D/"/>
    <id>https://crunchybiscuits.github.io/2020/08/10/LinkedList%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-08-10T14:50:16.000Z</published>
    <updated>2020-08-10T14:43:52.239Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linked-List-介绍"><a href="#Linked-List-介绍" class="headerlink" title="Linked List 介绍"></a>Linked List 介绍</h1><p>资料来源《程序员面试金典》第九章</p><p>链表是由一些列节点(node)组成的数据结构，每个节点拥有指向下一个节点的指针(双向链表中，每一个节点同时拥有指向上一个节点和下一个节点的指针)。</p><p>单链表：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/linkedlist2.png" alt="单链表"></p><p>双链表：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/linkedlist1.png" alt="双链表"></p><p>链表的好处是可以在常数的时间添加和删除元素，在特定的情况下特别有用。和数组不同的是，链表无法在常数时间复杂度内访问链表的一个特定索引，如果想要访问第N个元素，就需要迭代访问N次。</p><h2 id="Node数据结构"><a href="#Node数据结构" class="headerlink" title="Node数据结构"></a>Node数据结构</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> T Data &#123; <span class="keyword">set</span>; <span class="keyword">get</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> Node&lt;T&gt; Next &#123; <span class="keyword">set</span>; <span class="keyword">get</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span>(<span class="params">T val</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Data = val;</span><br><span class="line">        <span class="keyword">this</span>.Next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Data = <span class="keyword">default</span>(T);</span><br><span class="line">        <span class="keyword">this</span>.Next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedList数据结构"><a href="#LinkedList数据结构" class="headerlink" title="LinkedList数据结构"></a>LinkedList数据结构</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">T</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> Node&lt;T&gt; header &#123; <span class="keyword">set</span>; <span class="keyword">get</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.header = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Linked-List-习题"><a href="#Linked-List-习题" class="headerlink" title="Linked List 习题"></a>Linked List 习题</h1><h3 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h3><p>《程序员面试金典》第九章2.4</p><p>编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后(如下所示)。分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: head &#x3D; 3-&gt;5-&gt;8-&gt;5-&gt;10-&gt;2-&gt;1, x &#x3D; 5</span><br><span class="line">输出: 3-&gt;1-&gt;2-&gt;10-&gt;5-&gt;5-&gt;8</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用头插法，将碰到的小于x的节点直接插入到链表头的前面</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">Partition</span>(<span class="params">ListNode head, <span class="keyword">int</span> x</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        ListNode shadow = head;</span><br><span class="line">        <span class="keyword">while</span> (shadow.next!= <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (shadow.next.val &lt; x)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode temp = shadow.next;</span><br><span class="line">                shadow.next = temp.next;</span><br><span class="line">                temp.next = head;</span><br><span class="line">                head = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                shadow = shadow.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h3><p>《程序员面试金典》第九章2.8</p><p>给定一个链表，如果它是有环链表，实现一个算法返回环路的开头节点。<br>有环链表的定义：在链表中某个节点的next元素指向在它前面出现过的节点，则表明该链表存在环路。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：tail connects to node index 1</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">输出：tail connects to node index 0</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">输出：no cycle</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/linkedlist3.jpg" alt="环路检测"></p><p>使用“快行指针”进行求解，假设一个慢指针一次走一步，一个快指针一次走两步，如果链表有环，那么快指针和慢指针肯定会相遇。</p><ul><li>x: 链表起点</li><li>y: 环的起点</li><li>A: 链表起点到环的起点的长度</li><li>B: 环的起点到两个指针相遇的位置的长度</li></ul><p>到相遇点为止，慢指针走过了距离 s1 = A + B, 快指针走过了 s2 = A + B + N * (环路长度)， 也就是说快指针走了N圈和慢指针相遇了。又因为快指针一次走两步，慢指针一次走一步，所以快指针走过的距离s2是慢指针走过的距离s1的两倍：2*s1 = s2，得到 2( A + B ) = A + B + N * (环路长度)。我们需要求 y 的位置，也就是计算A的长度。简化得到 A = N * (环路长度) - B</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">DetectCycle</span>(<span class="params">ListNode head</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 找到相遇点</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next!=<span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span>(slow == fast)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slow != fast) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="comment">// A = N * (环路长度) - B，可以理解为一个指针从起点开始走，另一个指针走了N圈减去B的</span></span><br><span class="line">    <span class="comment">// 长度，因为这里慢指针已经停在了相遇点，既已经从一圈里减去了B</span></span><br><span class="line">    <span class="keyword">while</span> (slow != fast)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linked-List-介绍&quot;&gt;&lt;a href=&quot;#Linked-List-介绍&quot; class=&quot;headerlink&quot; title=&quot;Linked List 介绍&quot;&gt;&lt;/a&gt;Linked List 介绍&lt;/h1&gt;&lt;p&gt;资料来源《程序员面试金典》第九章&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
    
      <category term="Linked List" scheme="https://crunchybiscuits.github.io/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>字符串和数组练习</title>
    <link href="https://crunchybiscuits.github.io/2020/08/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E7%BB%84%E7%BB%83%E4%B9%A0/"/>
    <id>https://crunchybiscuits.github.io/2020/08/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E7%BB%84%E7%BB%83%E4%B9%A0/</id>
    <published>2020-08-02T05:52:13.000Z</published>
    <updated>2020-08-02T04:00:51.217Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode思路总结-C"><a href="#LeetCode思路总结-C" class="headerlink" title="LeetCode思路总结(C#)"></a>LeetCode思路总结(C#)</h2><p>题目来自<a href="https://leetcode-cn.com/problemset/lcci/">LeetCode</a>，以及《程序员面试金典》第九章1.1-1.9</p><h2 id="例题1-1"><a href="#例题1-1" class="headerlink" title="例题1.1"></a>例题1.1</h2><p>实现一个算法，确定一个字符串 <code>s</code> 的所有字符是否全都不同。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;leetcode&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s&#x3D;&quot;abc&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>0 &lt;= len(s) &lt;=100</li><li>如果不适用额外数据结构更好</li></ul><h3 id="思路1："><a href="#思路1：" class="headerlink" title="思路1："></a>思路1：</h3><p>使用额外数据结构，通常情况下题目里是使用ASCII码表示，如果编码不是ASCII这个思路将行不通。</p><p>ASCII码一共有128个，我们可以声明一个数组，将ASCII码的编号作为数组下标来检查字符是否重复，比如’a’可以用Array[97]表示，‘A’可以用Array[65]表示</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsUnique</span>(<span class="params"><span class="keyword">string</span> astr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] char_num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;astr.Length;i++)&#123;</span><br><span class="line">        char_num[astr[i]]++;</span><br><span class="line">        <span class="keyword">if</span>(char_num[astr[i]]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路2："><a href="#思路2：" class="headerlink" title="思路2："></a>思路2：</h3><p>不适用额外的数据结构，遍历字符串，每到一个字符的时候，检查剩余字符是否和当前字符相同。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsUnique</span>(<span class="params"><span class="keyword">string</span> astr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; astr.Length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt;astr.Length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(astr[i] == astr[j])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题1-3"><a href="#例题1-3" class="headerlink" title="例题1.3"></a>例题1.3</h2><p>URL化。编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。）</p><p>示例1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;Mr John Smith    &quot;, 13</span><br><span class="line">输出：&quot;Mr%20John%20Smith&quot;</span><br></pre></td></tr></table></figure><p>示例2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;               &quot;, 5</span><br><span class="line">输出：&quot;%20%20%20%20%20&quot;</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>字符串长度在[0, 500000]范围内。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先计算空格数量，再通过已知的字符串实际长度计算出URL化之后的字符串长度，设定一个计数器用于记录字符在新的字符串的实际位置</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">ReplaceSpaces</span>(<span class="params"><span class="keyword">string</span> S, <span class="keyword">int</span> length</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> space_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            space_count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] temp = <span class="keyword">new</span> <span class="keyword">char</span>[length + space_count*<span class="number">2</span>];</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[index++] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            temp[index++] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            temp[index++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp[index++] = S[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">string</span>(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题1-8"><a href="#例题1-8" class="headerlink" title="例题1.8"></a>例题1.8</h2><p>编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [1,1,1]</span><br><span class="line">]</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  [0,1,2,0],</span><br><span class="line">  [3,4,5,2],</span><br><span class="line">  [1,3,1,5]</span><br><span class="line">]</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [0,0,0,0],</span><br><span class="line">  [0,4,5,0],</span><br><span class="line">  [0,3,1,0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>最开始的时候，通过直接遍历找到0便置0，很快便把整个数组的所有数全部置0了，很明显这么做是错的，需要将得到的0分开记录，再根据记录将原有数组的行和列置0。</p><p>通过创建y(行)和x(列)的记录，根据这两个记录进行清零</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetZeroes</span>(<span class="params"><span class="keyword">int</span>[][] matrix</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">bool</span>[] y = <span class="keyword">new</span> <span class="keyword">bool</span>[matrix.Length];</span><br><span class="line">            <span class="keyword">bool</span>[] x = <span class="keyword">new</span> <span class="keyword">bool</span>[matrix[<span class="number">0</span>].Length];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; y.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x.Length; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        y[i] = <span class="literal">true</span>;</span><br><span class="line">                        x[j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; y.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (y[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x.Length; j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt; x.Length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (x[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; y.Length; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="例题-1-9"><a href="#例题-1-9" class="headerlink" title="例题 1.9"></a>例题 1.9</h2><p>字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。</p><p>示例1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 &#x3D; &quot;waterbottle&quot;, s2 &#x3D; &quot;erbottlewat&quot;</span><br><span class="line">输出：True</span><br></pre></td></tr></table></figure><p>示例2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 &#x3D; &quot;aa&quot;, s2 &#x3D; &quot;aba&quot;</span><br><span class="line">输出：False</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>字符串长度在[0, 100000]范围内。</li></ul><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>有点脑筋急转弯的意思，通过观察可以得到不管是s1还是s2，如果将s1和它本身进行拼接，必定包含s2将示例1的输入进行分解，我们可以看到waterbottle可以分成wat和erbottle两部分，s1=wat + erbottle，s2 = erbottle + wat。如果我们将s1和它本身进行拼接那么 s1 + s1 = wat + erbottle + wat + erbottle，可以看到s1 + s1 = wat + （erbottle + wat） + erbottle 里面是包含s2的，通过拼接就可以得出结果。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsFlipedString</span>(<span class="params"><span class="keyword">string</span> s1, <span class="keyword">string</span> s2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.Length != s2.Length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty(s1) &amp;&amp; <span class="keyword">string</span>.IsNullOrEmpty(s2))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">string</span> doubleS2 = s2 + s2;</span><br><span class="line">    <span class="keyword">if</span> (doubleS2.Contains(s1))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;LeetCode思路总结-C&quot;&gt;&lt;a href=&quot;#LeetCode思路总结-C&quot; class=&quot;headerlink&quot; title=&quot;LeetCode思路总结(C#)&quot;&gt;&lt;/a&gt;LeetCode思路总结(C#)&lt;/h2&gt;&lt;p&gt;题目来自&lt;a href=&quot;https
      
    
    </summary>
    
    
    
      <category term="Array and String" scheme="https://crunchybiscuits.github.io/tags/Array-and-String/"/>
    
  </entry>
  
  <entry>
    <title>BigO练习</title>
    <link href="https://crunchybiscuits.github.io/2020/07/24/BigO%E7%BB%83%E4%B9%A0/"/>
    <id>https://crunchybiscuits.github.io/2020/07/24/BigO%E7%BB%83%E4%B9%A0/</id>
    <published>2020-07-24T14:41:49.000Z</published>
    <updated>2020-07-24T12:41:49.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Big-O-练习"><a href="#Big-O-练习" class="headerlink" title="Big O 练习"></a>Big O 练习</h1><h2 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h2><p>题目来自《程序员面试金典》第六章例9</p><p>这段代码将平衡二叉搜索树的所有节点值相加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum(node.left) + node.value + sum(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法一：</p><p>由之前的基础介绍可知，通常情况下递归的时间复杂度为O(分支数^递归深度)。</p><p>二叉搜索树的高度约等于log2(N), N为节点数，分支为2，因此可得时间复杂度约为O(2^log2(N)）。</p><p>由2^P = Q 可得，P = log2(Q)。令P = 2^log2(N)，可得log2(P) = log2(N)，所以P = N，因此时间复杂度简化为O(N)</p><p>方法二：</p><p>因为需要所有节点值相加，所以需要遍历N个节点，因此式O(N)</p><h2 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h2><p>斐波那契数列的优化，取自《程序员面试金典》例14，例15</p><p>以下代码打印从0到n的斐波那契数列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allFib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        System.out.println(i + <span class="string">&quot;: &quot;</span> + fib(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个陷阱，在看到fib有两支递归调用的时候，能够想到时间复杂度约等于O(2^N)，在外层使用N次循环，那么时间复杂度是O(N * 2^N)，其实并不。</p><p>在每一次调用fib的时候，都是2^N的形式</p><p>那么从1到N，fib函数的运行应该时间是2^1 + 2^2 + ··· + 2^N，这个式子约等于2^(N+1)，也就是说时间复杂度仍然为O(2^N)</p><hr><p>以下通过在allFib函数添加一个数组来保存被计算过的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allFib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            System.out.println(i + <span class="string">&quot;: &quot;</span> +fib(i, memo));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] memo)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (memo[n] &gt; <span class="number">0</span>) <span class="keyword">return</span> memo[n];</span><br><span class="line"></span><br><span class="line">        memo[n] = fib(n - <span class="number">1</span>, memo) + fib(n - <span class="number">2</span>, memo);</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>算法的运行将会如下</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fib(0) -&gt;return 0</span><br><span class="line">fib(1)-&gt;return 1</span><br><span class="line">fib(2)</span><br><span class="line">fib(1)-&gt;return 1</span><br><span class="line">fib(0)-&gt;return 0</span><br><span class="line">store 1at memo[2]</span><br><span class="line">fib(3)</span><br><span class="line">fib(2)-&gt;lookup memo[2]-&gt;return 1</span><br><span class="line">fib(1)-&gt;return 1</span><br><span class="line">store 2at memo[3]</span><br><span class="line">fib(4)</span><br><span class="line">fib(3)-&gt;lookup memo[3]-&gt;return 2</span><br><span class="line">fib(2)-&gt;lookup memo[2]-&gt;return 1</span><br><span class="line">store 3at memo[4]</span><br><span class="line">fib(5)</span><br><span class="line">fib(4)-&gt;lookup memo[4]-&gt;return 3</span><br><span class="line">fib(3)-&gt;lookup memo[3]-&gt;return 2</span><br><span class="line">store 5at memo[5]</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，每次递归其实是直接从数组中取出之前的值，将不会进行更深层次的调用，也就是说这个过程只是进行了N次常数时间的操作，因此时间复杂度是O(N)。</p><h2 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h2><p> 取自《程序员面试金典》第六章附加题(11)</p><p>该段代码打印所有长度为<strong>K</strong>的字符串，字符串要求有序。代码先生成长度为K的字符串，再检测是否有序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numChars = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSortedStrings</span><span class="params">(<span class="keyword">int</span> remaining)</span> </span>&#123;</span><br><span class="line">    printSortedStrings(remaining, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSortedStrings</span><span class="params">(<span class="keyword">int</span> remaining, String prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (remaining == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isInOrder(prefix)) &#123;</span><br><span class="line">            System.out.println(prefix);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numChars; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = ithLetter(i);</span><br><span class="line">            printSortedStrings(remaining - <span class="number">1</span>, prefix + c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isInOrder</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = ithLetter(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">int</span> curr = ithLetter(s.charAt(i));</span><br><span class="line">        <span class="keyword">if</span> (prev &gt; curr) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">ithLetter</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>) (((<span class="keyword">int</span>) <span class="string">&#x27;a&#x27;</span>) + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的主要时间增加来自以下两段代码：</p><p>第一段是printSortedStrings中的循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numChars; i++) &#123;</span><br><span class="line">    <span class="keyword">char</span> c = ithLetter(i);</span><br><span class="line">    printSortedStrings(remaining - <span class="number">1</span>, prefix + c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是一个单只的递归调用，在长度为<strong>k</strong>的情形下，每一位都有26 (numChars = 26, 在开头有定义)中可能，因此是c^k的全排列，时间复杂度为O(c^k)</p><p>第二段是isInOrder中的循环用于检测字符串是否有序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isInOrder</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = ithLetter(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">int</span> curr = ithLetter(s.charAt(i));</span><br><span class="line">        <span class="keyword">if</span> (prev &gt; curr) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串长度为<strong>k</strong>，因此每一次检测都需要O(k)的时间</p><p>因此总时间为每一次检测字符串有序的时间乘以生成的总字符串个数，时间复杂度为O(k*c^k)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Big-O-练习&quot;&gt;&lt;a href=&quot;#Big-O-练习&quot; class=&quot;headerlink&quot; title=&quot;Big O 练习&quot;&gt;&lt;/a&gt;Big O 练习&lt;/h1&gt;&lt;h2 id=&quot;例一&quot;&gt;&lt;a href=&quot;#例一&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
    
      <category term="BigO" scheme="https://crunchybiscuits.github.io/tags/BigO/"/>
    
  </entry>
  
  <entry>
    <title>BigO基础介绍02</title>
    <link href="https://crunchybiscuits.github.io/2020/07/23/BigO%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D02/"/>
    <id>https://crunchybiscuits.github.io/2020/07/23/BigO%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D02/</id>
    <published>2020-07-23T10:12:45.000Z</published>
    <updated>2020-07-23T08:19:44.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Big-O-基础介绍-二"><a href="#Big-O-基础介绍-二" class="headerlink" title="Big O 基础介绍(二)"></a>Big O 基础介绍(二)</h1><p>此文参考《程序员面试金典》(第六版)第六章。</p><h2 id="多项式算法的加和乘"><a href="#多项式算法的加和乘" class="headerlink" title="多项式算法的加和乘"></a>多项式算法的加和乘</h2><p>算法中常见的分步形式如下:</p><p><strong>O( A + B )</strong> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a : arrA)&#123;</span><br><span class="line">    print(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> b : arrB)&#123;</span><br><span class="line">    print(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>O( A * B )</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a : arrA)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> b : arrB)&#123;</span><br><span class="line">        print(a + <span class="string">&quot;,&quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个例子，先遍历A数组，再遍历B数组，所以总数量是O( A + B )。</p><p>第二个例子，对A数组的每个元素都遍历B数组，所以总数量是O( A * B )。</p><ul><li>”先做这个，再做那个”的形式，就是加</li><li>“对这个的每个做那个”的形式，就是乘</li></ul><h2 id="分摊时间"><a href="#分摊时间" class="headerlink" title="分摊时间"></a>分摊时间</h2><p>在计算时间复杂度的时候常常会碰到最坏情况偶尔会出现，一旦发生会消耗很多资源，但是发生之后很长一段时间不会发生，因此需要兼顾正常情况和最坏情况，将时间进行”分摊“。</p><p>例如Java中<code>ArrayList</code>能够灵活的改变大小，能够随着你的插入进行扩容。</p><p><code>ArrayList</code>容量达到限制的时候会创建一个双倍容量的数组，将元素复制到新的数组里面。</p><p>那么描述<code>ArrayList</code>的插入时间，当数组没有满的时候，插入就是O(1)。</p><p>当数组满了，如果数组大小为N，那么需要扩容到2N，并把旧的值复制过去，那么插入就需要O(N)。</p><p>那么”分摊时间“该怎么计算？</p><p>假设需要插入N个元素，<code>ArrayList</code>数组的大小为2的幂数，<strong>当插入一个元素便扩容两倍</strong>。当元素是N的时候，以1，2，4，8，16，32……，N的数组大小成倍的扩容。每次操作需要复制1，2，4，8，16，……，N个元素。</p><p>那么消耗便是1 + 2 + 4 + 8 + 16 + ··· + N的和，从右往左计算便是 N + N/2 + N/4 + N/8 + ··· + 1的和，这个和约等于2N。</p><p>因此，N次插入需要的时间便是O(2N)， 即每次插入的分摊时间为O(1)。</p><h2 id="Log-N-运行时间"><a href="#Log-N-运行时间" class="headerlink" title="Log N 运行时间"></a>Log N 运行时间</h2><p>以二分查找为例。如果一个排序数组的长度为N，目标值为x。首先比较x和中值的大小，如果等于就直接返回，如果x小于便搜索数组中值左边的部分，如果x大于中值便搜索右边的部分。</p><p>开始的时候有N个元素，搜索一次后便是N/2，接着是N/4，直到找到目标或者需要搜索的元素变成1。</p><p>假设有N个元素，总的运行时间便是从N到1一共搜索了多少次。</p><p>如果开始有32个元素</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">N = 32</span><br><span class="line">N = 16 除以2</span><br><span class="line">N = 8  除以2</span><br><span class="line">N = 4  除以2</span><br><span class="line">N = 2  除以2</span><br><span class="line">N = 1  除以2</span><br></pre></td></tr></table></figure><p>从32到1，需要5次</p><p>如果从1开始看，从1到32则需要2^5</p><p>因此得到2^k = N，k = log2(N)</p><p>所以得到运行时间O(logN)</p><p>平衡二叉搜索树中也有同样的情况，每次搜索便将规模减半，最坏情况为平衡二叉搜索树的高度，也是O(logN)。</p><h2 id="递归运行时间"><a href="#递归运行时间" class="headerlink" title="递归运行时间"></a>递归运行时间</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f(n - <span class="number">1</span>) + f(n - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过模拟执行来显示运行时间，如果我们调用f(4)，那么会调用f(3)两次，每个f(3)又会调用f(2)两次，每个f(2)又会调用f(1)两次。如下图显示的节点展开。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/bigo4.jpg" alt="递归节点显示"></p><p>图中一共展开了多少节点？</p><table><thead><tr><th>层</th><th>节点数</th></tr></thead><tbody><tr><td>0</td><td>1</td></tr><tr><td>1</td><td>2 * 上一层节点数 = 2 * 1 = 2 = 2^1</td></tr><tr><td>2</td><td>2 * 上一层节点数 = 2 * 2 = 4 = 2^2</td></tr><tr><td>3</td><td>2 * 上一层节点数 = 2 * 4 = 8 = 2^3</td></tr></tbody></table><p>所以展开是2^0 + 2^1 + 2^2 + 2^3  =  2^4 -1 </p><p>扩展到N则是2^0 + 2^1 + 2^2 + 2^3 + ··· + 2^N = 2^(N+1) - 1</p><p>因此时间复杂度为O(2^(N+1) - 1)舍弃掉常数项为O(2^N)</p><p>常见递归中复杂度通常为，O(分支数^递归深度)，偶尔也有特殊情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Big-O-基础介绍-二&quot;&gt;&lt;a href=&quot;#Big-O-基础介绍-二&quot; class=&quot;headerlink&quot; title=&quot;Big O 基础介绍(二)&quot;&gt;&lt;/a&gt;Big O 基础介绍(二)&lt;/h1&gt;&lt;p&gt;此文参考《程序员面试金典》(第六版)第六章。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
    
      <category term="BigO" scheme="https://crunchybiscuits.github.io/tags/BigO/"/>
    
  </entry>
  
  <entry>
    <title>BigO基础介绍01</title>
    <link href="https://crunchybiscuits.github.io/2020/07/23/BigO%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D01/"/>
    <id>https://crunchybiscuits.github.io/2020/07/23/BigO%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D01/</id>
    <published>2020-07-23T02:52:53.000Z</published>
    <updated>2020-07-23T00:59:36.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Big-O-基础介绍-一"><a href="#Big-O-基础介绍-一" class="headerlink" title="Big O 基础介绍(一)"></a>Big O 基础介绍(一)</h1><p>此文参考《程序员面试金典》(第六版)第六章</p><p>大O符号在算法中用于描述算法效率。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度(渐近运行时间)，也称为大O时间</p><p>举例：</p><p>假设有一个可以无限装下盒子的容器X，N个盒子，一个人P，地点A和B，从A到B运送时间相同。</p><p>方法一：P一次只能从A到B运送一个盒子</p><p>方法二：P也可以选择直接将盒子都装进X再从A到B运送容器X</p><p>使用方法一，随着盒子数目的增加，所消耗的时间也将线性增加，可以表示为O(N)</p><p>使用方法二，无论盒子怎么增加X都能装下，因此运送时间是固定的常量，可表示为O(1)</p><p>时间复杂度也能有很多的变量，比如给一个长X，宽Y，高Z的泳池注水，那么可以表示为O(XYZ)</p><h2 id="O、θ-和Ω"><a href="#O、θ-和Ω" class="headerlink" title="O、θ 和Ω"></a>O、<em>θ</em> 和<em>Ω</em></h2><p>学术界描述运行时间有三种，Big O、Big θ (theta) 和 Big <em>Ω</em> (omega)</p><ul><li>Big O：用于描述运行时间的上界，假设一个算法可以描述为O(N)，那么也可以描述为O(N^2)。类似于，假设一个人可以活到130岁，那么年龄X&lt;=130，也可以说年龄X&lt;=1000，因为130是肯定小于1000的，这里的130就是上界。</li><li>Big <em>Ω</em> (omega)：用于描述运行时间的下界</li><li>Big θ (theta)：用于描述运行时间的确界，如果一个算法为 θ(N)，那么它既是O(N)，也是Ω(N)</li></ul><p>在工业界中直接用O(N)表示确界。</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>空间复杂度为算法占用的内存数量或者空间大小</p><p>如果要创建大小为N的数组那么需要的空间为O(N)。如果是n <strong>x</strong> n的数组，需要的空间为O(N^2)。</p><p>在递归里栈的空间也要算在内。下列sum函数运行时间为O(N)，空间也为O(N)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n + sum(n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈的调用过程如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="number">4</span>)</span><br><span class="line"> -&gt;sum(<span class="number">3</span>)</span><br><span class="line">   -&gt;sum(<span class="number">2</span>)</span><br><span class="line">     -&gt;sum(<span class="number">1</span>)</span><br><span class="line">       -&gt;sum(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这里的递归调用都会添加到调用栈里并占用实际内存。</p><p>但是并不是n次调用都会占用O(N)的空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pairSumSequence</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        sum += pairSum(i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pairSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pairSum方法调用n次，但是调用并不像递归那样同时发生，所以仅仅需要O(1)的空间。</p><h2 id="删除常量"><a href="#删除常量" class="headerlink" title="删除常量"></a>删除常量</h2><p>在特定时候O(N)可能比O(1)还快。例如下图</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/bigo1.jpg" alt="O(N)、O(1)比较, 取自《程序员面试金典》"></p><p>时间复杂度描述的仅仅是算法时间的增长趋势，因此常量不计算在运行时间中。</p><p>例如O(2N)实际上是O(N)，不少人会认为代码中两个非嵌套的循环就是O(2N)这样描述更精确，其实并不。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x : array)&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; min) min = x;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; max) max = x;</span><br><span class="line">&#125;</span><br><span class="line">#************************************</span><br><span class="line"><span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x : array)&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; min) min = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x : array)&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; max) max = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两段代码，第一段一个for循环，第二段两个for循环，但是第一个for循环里有两行，这个要怎么考虑呢？如果真的要详细计算时间复杂度，需要考虑汇编层次，乘法比加法多了多少指令，还要考虑编译器怎么优化等细节，太多太多了。这会让O的计算变得复杂。<strong>我们只需要知道一点，O(N)并不总是比O(N^2)快。</strong></p><h2 id="丢弃不重要的项"><a href="#丢弃不重要的项" class="headerlink" title="丢弃不重要的项"></a>丢弃不重要的项</h2><p>由O(2N)会舍弃常量变成O(N)可知，O(2N^2)会舍弃常量变成O(N^2)，那么O(N^2 + N)该怎么处理？</p><p>由O(2N^2)会舍弃常量变成O(N^2)可知，O(2N^2)可以表示为O(N^2 + N^2)，这里直接舍弃掉了一个N^2。因为 N &lt; N^2 所以O(N^2 + N)也会变成O(N^2)。<img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/bigo2.jpg" alt="例子"></p><p>特殊情况依旧存在，有的时候需要用和的形式表示运行时间。例如，O(B^2) + A 就已经是最简化的形式了。</p><p>下图是常见几个时间复杂度的增长速率。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/bigo3.jpg" alt="增长速率"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Big-O-基础介绍-一&quot;&gt;&lt;a href=&quot;#Big-O-基础介绍-一&quot; class=&quot;headerlink&quot; title=&quot;Big O 基础介绍(一)&quot;&gt;&lt;/a&gt;Big O 基础介绍(一)&lt;/h1&gt;&lt;p&gt;此文参考《程序员面试金典》(第六版)第六章&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
    
      <category term="BigO" scheme="https://crunchybiscuits.github.io/tags/BigO/"/>
    
  </entry>
  
</feed>
