<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZY-Zhang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://crunchybiscuits.github.io/"/>
  <updated>2021-05-07T01:20:53.784Z</updated>
  <id>https://crunchybiscuits.github.io/</id>
  
  <author>
    <name>ZY-Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Thinfilm研究</title>
    <link href="https://crunchybiscuits.github.io/2021/05/06/Thinfilm%E7%A0%94%E7%A9%B6/"/>
    <id>https://crunchybiscuits.github.io/2021/05/06/Thinfilm%E7%A0%94%E7%A9%B6/</id>
    <published>2021-05-06T13:40:06.000Z</published>
    <updated>2021-05-07T01:20:53.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="薄膜干涉尝试记录"><a href="#薄膜干涉尝试记录" class="headerlink" title="薄膜干涉尝试记录"></a>薄膜干涉尝试记录</h1><p>实习需要用到薄膜干涉的效果，看到《王者荣耀》里，婉儿的皮肤，尝试用仅有的一点知识去模仿下(待继续优化)</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/thin_film02.png" alt=""></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>康康目前我能做什么</p><ol><li>在旋转模型的时候颜色会根据光照和视线的变换发生变化，因此需要注意法线和视线 — 菲涅尔现象，法线和光线对效果产生的影响。</li><li>基础的光照模型 — 反射相关</li></ol><h2 id="贴图"><a href="#贴图" class="headerlink" title="贴图"></a>贴图</h2><p>贴图有两张，一张是通过在ps里ramp得到的</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/thin_film03.png" alt=""></p><p>一张来自<a href="https://www.zhihu.com/question/34259470">中国科普博览</a></p><h2 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h2><p>在最简单的材质球上实现的时候，先看NdotV的变换，中间为1，边缘为0与NdotV相符</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/thin_film05.png" alt=""></p><p>接着添加一个贴图并通过NdotV进行采样，这个时候什么角度看都是一样的</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/thin_film06.png" alt=""></p><p>接着加入光的影响，可以看到有根据希望的方向进行变化，既会收到光的影响也会收到视线的影响(背光面会有分界)</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/thin_film07.png" alt=""></p><p>想到之前做过matcap的一个效果，首先尝试通过菲涅尔直接对贴图采样观察效果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">half NdotV = dot(normal_dir, view_dir * _Tile);</span><br><span class="line">half fresnel = <span class="number">1.0</span> - NdotV;</span><br><span class="line">half2 uv_thinfilm = half2(fresnel, <span class="number">0.5</span>);</span><br><span class="line">half4 matcap_color = tex2D(_ThinfilmTex, uv_thinfilm);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/thinfilm5.gif" alt=""></p><p>可以看到效果的变化很单一也并没有实现对应的要求，因此尝试根据薄膜干涉原理来达到效果，根据<a href="https://baijiahao.baidu.com/s?id=1687788042959363447&wfr=spider&for=pc">Thepoly</a>大佬这篇文章，思路主要是通过NdotV对灰度的影响进行变化，但是大佬在纹理采样的时候仍然用的是正常的uv值，因此做出来的效果并不是我的目标，因为我希望纹理能够根据视线和光线产生变化。为此进行如下的修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NdotV</span></span><br><span class="line">half NdotV =  dot(normal_dir, view_dir * _Tile);</span><br><span class="line"><span class="comment">// 蓝色</span></span><br><span class="line">half3 Mask01 = saturate(<span class="built_in">acos</span>(NdotV)*<span class="number">2</span>/UNITY_PI * half3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line"><span class="comment">// 蓝色和白色叉乘得到绿色，这里是为了拿到绿色通道 --- 可以手动计算下看结果，有saturate所以-1会修正</span></span><br><span class="line"><span class="comment">// --- 绿色和白色叉乘得到红色</span></span><br><span class="line"><span class="comment">// --- 红色和白色叉乘得到蓝色</span></span><br><span class="line">half3 CrossColor = cross (half3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>) , half3(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line"><span class="comment">// 绿色和红色</span></span><br><span class="line">half3 Mask02 = saturate (<span class="built_in">asin</span>(NdotV)*<span class="number">2</span>/UNITY_PI * CrossColor);</span><br><span class="line"><span class="comment">// 得到红，绿，蓝三色通道</span></span><br><span class="line">half3 AddMask = Mask01 + Mask02;</span><br><span class="line"><span class="comment">// 转灰度</span></span><br><span class="line">half Rgb2Gray = saturate(<span class="number">0.2989</span> * AddMask.r + <span class="number">0.587</span> * AddMask.g + <span class="number">0.114</span> * AddMask.b);</span><br><span class="line"><span class="comment">// 这里是修改的地方</span></span><br><span class="line">half4 col = tex2D(_BubbleTex, half2(NdotV,NdotL));</span><br></pre></td></tr></table></figure><p>把shader加到之前记录的实验模型里得到效果如下，感觉更近了一步</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/thinfilm2.gif" alt=""></p><p>接着可以看到，颜色只是很单纯的白色，需要加入衣服本身的颜色信息，所以通过灰度对原本衣服的颜色和薄膜干涉的颜色进行了插值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">half3 thin_film = lerp(col, base_color, Rgb2Gray);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/thinfilm3.gif" alt=""></p><p>目前的计算仍然是有些问题（但是感觉效果再调整一下可以用），灰度计算上通过cos直接对NdotV的值直接进行计算，按照<a href="https://zhuanlan.zhihu.com/p/47575695">天源</a>大佬的文章，需要加入弧度对薄膜干涉进行映射，因此做了如下两处的修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改前</span></span><br><span class="line">half3 Mask01 = saturate(<span class="built_in">cos</span>(NdotV) * half3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">...</span><br><span class="line">half3 Mask02 = saturate (<span class="built_in">sin</span>(NdotV) * CrossColor);</span><br><span class="line"><span class="comment">// 修改后</span></span><br><span class="line">half3 Mask01 = saturate(<span class="built_in">acos</span>(NdotV)*<span class="number">2</span>/UNITY_PI * half3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">...</span><br><span class="line">half3 Mask02 = saturate (<span class="built_in">asin</span>(NdotV)*<span class="number">2</span>/UNITY_PI * CrossColor);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/thinfilm4.gif" alt=""></p><p>最后换一套白色的贴图可以看到，发现对比度有点高</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/thin_film_00.png" alt=""></p><p>通过替换直接的叠加方式，换成one minus</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">half3 soft_thin_film = thin_film + base_color * (<span class="number">1</span>-thin_film);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/thin_film_01.png" alt=""></p><p>在婉儿的衣服上能够看到比较光滑的质感，因此通过matcap添加玻璃材质进行模拟, 这里把ramp贴图左右对调了一下，可惜衣服其他材质不太像</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">half3 normal_viewspace = mul(UNITY_MATRIX_V, float4(normal_dir, <span class="number">0.0</span>)).xyz;</span><br><span class="line">half2 uv_matcap = (normal_viewspace.xy + float2(<span class="number">1.0</span>, <span class="number">1.0</span>)) * <span class="number">0.5</span>;</span><br><span class="line">half4 matcap_color = tex2D(_MatcapBase, uv_matcap) * _MatIntensity;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/thinfilm6.gif" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://baijiahao.baidu.com/s?id=1687788042959363447&wfr=spider&for=pc">Thepoly</a></p><p><a href="https://zhuanlan.zhihu.com/p/47575695">天源</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;薄膜干涉尝试记录&quot;&gt;&lt;a href=&quot;#薄膜干涉尝试记录&quot; class=&quot;headerlink&quot; title=&quot;薄膜干涉尝试记录&quot;&gt;&lt;/a&gt;薄膜干涉尝试记录&lt;/h1&gt;&lt;p&gt;实习需要用到薄膜干涉的效果，看到《王者荣耀》里，婉儿的皮肤，尝试用仅有的一点知识去模仿下(待
      
    
    </summary>
    
    
    
      <category term="shader" scheme="https://crunchybiscuits.github.io/tags/shader/"/>
    
  </entry>
  
  <entry>
    <title>人物渲染效果记录-仅效果</title>
    <link href="https://crunchybiscuits.github.io/2021/05/06/%E4%BA%BA%E7%89%A9%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C%E8%AE%B0%E5%BD%95-%E4%BB%85%E6%95%88%E6%9E%9C/"/>
    <id>https://crunchybiscuits.github.io/2021/05/06/%E4%BA%BA%E7%89%A9%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C%E8%AE%B0%E5%BD%95-%E4%BB%85%E6%95%88%E6%9E%9C/</id>
    <published>2021-05-06T13:39:52.000Z</published>
    <updated>2021-05-06T13:41:54.655Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间重感冒真的起不来，主要复习一下之前所学的内容并且结合到角色，分成了直接光和间接光两个部分，记录下整个流程在视觉上的一些变化，并且将该模型用作后面的实验</p><h2 id="直接光"><a href="#直接光" class="headerlink" title="直接光"></a>直接光</h2><p>最开始模型加上贴图的样子</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/character_out00.gif" alt=""></p><p>为模型添加漫反射</p><p>效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/character_out01.gif" alt=""></p><p>为模型添加高光,阴影和法线信息后</p><p>效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/character_out02.gif" alt=""></p><h2 id="间接光"><a href="#间接光" class="headerlink" title="间接光"></a>间接光</h2><p>通过SH模拟环境光的漫反射</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/character_out03.gif" alt=""></p><p>通过IBL模拟环境光镜面反射</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/character_out04.gif" alt=""></p><p>最后添加上背景效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/character_out.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间重感冒真的起不来，主要复习一下之前所学的内容并且结合到角色，分成了直接光和间接光两个部分，记录下整个流程在视觉上的一些变化，并且将该模型用作后面的实验&lt;/p&gt;
&lt;h2 id=&quot;直接光&quot;&gt;&lt;a href=&quot;#直接光&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
    
      <category term="shader" scheme="https://crunchybiscuits.github.io/tags/shader/"/>
    
  </entry>
  
  <entry>
    <title>简易各向异性</title>
    <link href="https://crunchybiscuits.github.io/2021/04/26/%E7%AE%80%E6%98%93%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7/"/>
    <id>https://crunchybiscuits.github.io/2021/04/26/%E7%AE%80%E6%98%93%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7/</id>
    <published>2021-04-26T13:59:40.000Z</published>
    <updated>2021-04-26T14:00:44.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="各向异性高光"><a href="#各向异性高光" class="headerlink" title="各向异性高光"></a>各向异性高光</h1><p>主要参考来自ATI Research Inc的《Hair Rendering and Shading》</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>各向异性表现：光打到物体表面会在不同的表面发散</p><p>可以分为两部分处理：</p><ul><li>发光方向的处理</li><li>拉丝感的处理</li></ul><h3 id="发光方向"><a href="#发光方向" class="headerlink" title="发光方向"></a>发光方向</h3><p>使用kajiya-kay模型，不再使用法线和半程向量dot(N,H)去计算高光，而是使用每根头发对应的tangent值和半程向量的sin值去计算：sin(T,H) = sqrt(1-dot(T,H) * dot(T,H))</p><p>H越接近横截面，越亮，sin的特性也是如此(越接近横截面的时候值越大)，因此用sin表示</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/kk_02.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 半程向量</span></span><br><span class="line">half3 half_dir = normalize(light_dir + view_dir);</span><br><span class="line"><span class="comment">// 计算TH点积，这里binormal的原因是unity中切线方向是u方向因此需要副法线</span></span><br><span class="line">half TdotH = dot(binormal_dir, half_dir);</span><br><span class="line"><span class="comment">// 计算Sin</span></span><br><span class="line">half SinTH = <span class="built_in">sqrt</span>(<span class="number">1</span>-TdotH * TdotH);</span><br><span class="line"><span class="comment">// 高光</span></span><br><span class="line">half3 spec = <span class="built_in">pow</span>(max(<span class="number">0.0</span>, SinTH),_Shineness) </span><br><span class="line">                    * _LightColor0.xyz * _SpecIntensity;</span><br></pre></td></tr></table></figure><h3 id="拉丝感"><a href="#拉丝感" class="headerlink" title="拉丝感"></a>拉丝感</h3><p>通过shift texture实现分为两个部分</p><ul><li>shift texture</li><li>noise texture</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/kk_03.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采样噪声图来获取拉丝感</span></span><br><span class="line">half uv_shift = i.uv * _ShiftMap_ST.xy + _ShiftMap_ST.zw;</span><br><span class="line">half shiftNoise = tex2D(_ShiftMap, uv_shift).r;</span><br><span class="line"><span class="comment">// 为噪声添加强度</span></span><br><span class="line">shiftNoise = shiftNoise * _NoiseIntensity;</span><br><span class="line"><span class="comment">// 为副切线添加偏移(控制高光的位置)</span></span><br><span class="line">half3 b_offset = normal_dir * (_ShiftOffset + shiftNoise);</span><br><span class="line"><span class="comment">// 获取更新后的副法线</span></span><br><span class="line">binormal_dir = normalize(binormal_dir + b_offset);</span><br></pre></td></tr></table></figure><h2 id="金属"><a href="#金属" class="headerlink" title="金属"></a>金属</h2><p>金属的拉丝感需要通过贴图进行整理，思路类似凹凸贴图的使用，从贴图获取切线以及副切线的信息，对原本的副切线进行修改</p><p>颜色设置如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/kk_05.png" alt=""></p><p>PS中制作的贴图如下：</p><ol><li>r通道存储横向渐变</li><li>g通道存储纵向渐变</li><li>b通道存储拉丝的噪声</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/kk_06.png" alt=""></p><p>通过采样制作的贴图对binormal进行修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取贴图数据</span></span><br><span class="line">half3 noise_data = tex2D(_FlowMap, i.uv).rgb;</span><br><span class="line"><span class="comment">// 获取噪声数据</span></span><br><span class="line">half shiftNoise = noise_data.b * <span class="number">2.0</span> - <span class="number">1.0</span>;</span><br><span class="line"><span class="comment">// 获取切线以及副切线方向修改信息</span></span><br><span class="line">half2 noise_dir= noise_data.rg * <span class="number">2.0</span> - <span class="number">1.0</span>;</span><br><span class="line"><span class="comment">// 修改副切线</span></span><br><span class="line">binormal_dir = normalize(tangent_dir * noise_dir.x + binormal_dir * noise_dir.y);</span><br></pre></td></tr></table></figure><p>修改后效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/kk_04.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;各向异性高光&quot;&gt;&lt;a href=&quot;#各向异性高光&quot; class=&quot;headerlink&quot; title=&quot;各向异性高光&quot;&gt;&lt;/a&gt;各向异性高光&lt;/h1&gt;&lt;p&gt;主要参考来自ATI Research Inc的《Hair Rendering and Shading》&lt;/p
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>Dithering</title>
    <link href="https://crunchybiscuits.github.io/2021/04/25/Dithering/"/>
    <id>https://crunchybiscuits.github.io/2021/04/25/Dithering/</id>
    <published>2021-04-25T14:13:47.000Z</published>
    <updated>2021-04-25T14:17:48.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dither效果（更新中）"><a href="#Dither效果（更新中）" class="headerlink" title="Dither效果（更新中）"></a>Dither效果（更新中）</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>本质上是通过uv的偏移对dither矩阵采样，通过采样值和你想比较的那个值进行对比，判定条件和效果可以自己设定</p><p>dither矩阵是通过这样的方式递归推导的</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">half4 <span class="title">frag</span> <span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        half4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">        half pattern_threshold = tex2D(_PatternTex, i.uv * </span><br><span class="line">_ScreenParams/<span class="number">4</span>).r;</span><br><span class="line">        <span class="comment">// stepper实现阶跃，效果类似if/else，col.r &lt; pattern_threshold返回0,否则返回1</span></span><br><span class="line">        half stepper = step(pattern_threshold, col.r);</span><br><span class="line">        <span class="comment">// 加入角度变化，使得效果柔和</span></span><br><span class="line">        stepper = lerp(<span class="number">0</span>,<span class="number">1</span>,stepper - col + _AngleCos);</span><br><span class="line">        clip(stepper);</span><br><span class="line">        <span class="keyword">return</span> col;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/dither.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Dither效果（更新中）&quot;&gt;&lt;a href=&quot;#Dither效果（更新中）&quot; class=&quot;headerlink&quot; title=&quot;Dither效果（更新中）&quot;&gt;&lt;/a&gt;Dither效果（更新中）&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; cla
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>Billboarding</title>
    <link href="https://crunchybiscuits.github.io/2021/04/25/Billboarding/"/>
    <id>https://crunchybiscuits.github.io/2021/04/25/Billboarding/</id>
    <published>2021-04-25T13:23:56.000Z</published>
    <updated>2021-04-25T14:16:44.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Billboarding"><a href="#Billboarding" class="headerlink" title="Billboarding"></a>Billboarding</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Billboarding通常会根据需求来旋转一个被纹理着色的多边形，本质上是构建一个旋转矩阵，通常是基于法线或者基于向上的方向，还需要设定锚点来确定多边形在空间中的位置。</p><p>难点在于法线和向上的方向常常不是垂直的，需要构建的矩阵由法线方向(normal)，向上的方向(up)和向右的方向(right)组成</p><blockquote><ol><li>right = normal x up</li><li>up’ = normal x right</li></ol></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/billboarding_00.jpg" alt=""></p><p>如图，通过视线作为一个轴，获取设定好的向上方向之后，获取向右的方向，因为向上的向量恒定不变，因此叉乘出来的向右向量由视线决定，在更新了向右向量之后再反过来影响向上的向量。(图片来自shader入门精要)</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>参考《Unity Shader入门精要》</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">        v2f o;</span><br><span class="line">        <span class="comment">// 设置模型空间中原点</span></span><br><span class="line">        float3 center = float3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 模型空间中的视线</span></span><br><span class="line">        half3 view_model = mul(unity_WorldToObject, float4(_WorldSpaceCameraPos, <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 确定法线</span></span><br><span class="line">        half3 normal_dir = view_model - center;</span><br><span class="line">        <span class="comment">// 加上法线和向上向量权重</span></span><br><span class="line">        normal_dir.y = normal_dir.y * _VerticalBillboarding;</span><br><span class="line">        normal_dir = normalize(normal_dir);</span><br><span class="line">        <span class="comment">// 如果法线已经是向上的了，那么up就设置为向右, 防止叉乘中的平行</span></span><br><span class="line">        half3 up_dir = <span class="built_in">abs</span>(normal_dir.y)&gt;<span class="number">0.999</span>?half3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>):half3(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 构建向右和新的向上向量</span></span><br><span class="line">        half3 right_dir = normalize(cross(up_dir, normal_dir));</span><br><span class="line">        up_dir = normalize(cross(normal_dir, right_dir));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算偏移，重新得到新的顶点位置</span></span><br><span class="line">        half3 centerOffs = v.vertex.xyz - center;</span><br><span class="line">        float3 localPos = center + right_dir * centerOffs.x + up_dir * centerOffs.y + normal_dir * centerOffs.z;</span><br><span class="line">        o.pos = UnityObjectToClipPos(float4(localPos, <span class="number">1</span>));</span><br><span class="line">        o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span> <span class="params">(v2f i)</span> : SV_Target</span>&#123;</span><br><span class="line">    fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">    col.rgb = _Color.rgb * col.rgb;</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/billboarding_01.jpg" alt=""></p><p>图中是向上向量和视线向量分别来作为恒定轴时候的效果(图片来自shader入门精要)</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>如果单纯只是想实现一直朝向的效果，那么可以进行如下优化，因为本质上是通过构建旋转矩阵追踪视角变换的朝向，并将朝向的变换应用到物体上，那么反过来想，抵消掉物体朝向的变换也是可以的，因此通过mv矩阵的逆可以实现同样的保存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    <span class="comment">// 计算偏移，重新得到新的顶点位置</span></span><br><span class="line">    float3 localPos = mul(UNITY_MATRIX_T_MV, v.vertex.xyz);</span><br><span class="line">    o.pos = UnityObjectToClipPos(float4(localPos, <span class="number">1</span>));</span><br><span class="line">    o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span> <span class="params">(v2f i)</span> : SV_Target</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">    col.rgb = _Color.rgb * col.rgb * _Intensity;</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/billboarding.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Billboarding&quot;&gt;&lt;a href=&quot;#Billboarding&quot; class=&quot;headerlink&quot; title=&quot;Billboarding&quot;&gt;&lt;/a&gt;Billboarding&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>GAMES202-作业1-part2</title>
    <link href="https://crunchybiscuits.github.io/2021/04/20/GAMES202-%E4%BD%9C%E4%B8%9A1-part2/"/>
    <id>https://crunchybiscuits.github.io/2021/04/20/GAMES202-%E4%BD%9C%E4%B8%9A1-part2/</id>
    <published>2021-04-20T13:48:18.000Z</published>
    <updated>2021-04-21T14:12:39.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GAMES202-作业1-part2"><a href="#GAMES202-作业1-part2" class="headerlink" title="GAMES202 作业1-part2"></a>GAMES202 作业1-part2</h1><p>应老师要求不会直接放上作业答案，会记录整体思路和核心代码</p><h2 id="PCF"><a href="#PCF" class="headerlink" title="PCF"></a>PCF</h2><p>主要步骤</p><ol><li>获取shadow map和对应的坐标</li><li>设置filter和随机采样的数目</li><li>使用泊松分布采样</li><li>判断每个采样点的shadow map值</li><li>进行累加求平均</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改了老师给的函数的签名，新增了一个参数，其实按照pdf的说明，加了这个参数才比较合理</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">PCF</span><span class="params">(sampler2D shadowMap, vec4 coords, <span class="keyword">float</span> filter_size)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// filter_size是根据图片大小来的，这里是1.0/2048.0，可以根据实际需求乘以2.0-10.0</span></span></span><br><span class="line"><span class="function"><span class="comment">// 随机采样的样本数目是通过glsl文件开头的NUM_SAMPLES进行修改的</span></span></span><br></pre></td></tr></table></figure><p>接着使用泊松分布</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泊松分布采样，采样输出的范围会很大很可能覆盖整张图</span></span><br><span class="line">poissonDiskSamples(coords.xy);</span><br></pre></td></tr></table></figure><p>然后通过每个对采样点进行判断累加结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; PCF_NUM_SAMPLES; i++)&#123;</span><br><span class="line">    <span class="comment">// 因为shadowmap和归一化之后的坐标都是在[0,1]之前，因此需要filter_size对泊松分布的输出进行       // 缩小，不然会出现全屏黑点的效果</span></span><br><span class="line">    vec2 temp = poissonDisk[i] * filter_size + coords.xy;</span><br><span class="line">    <span class="keyword">float</span> depth_decode = (unpack(texture2D(shadowMap, temp)));</span><br><span class="line">    <span class="keyword">if</span>(depth_decode&gt;coords.z - bias)</span><br><span class="line">        depth_sum += <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">          depth_sum += <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到效果如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/GAMES202hw1_03.png" alt=""></p><h2 id="PCSS"><a href="#PCSS" class="headerlink" title="PCSS"></a>PCSS</h2><p>PCSS主要步骤：</p><ol><li>blocker search<ol><li>进行泊松分布采样</li><li>和当前uv的深度进行对比、</li><li>判断是否有遮挡</li></ol></li><li>计算比值</li><li>通过PCF创建软阴影</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// blocker search核心的思路</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;NUM_SAMPLES; i ++)&#123;</span><br><span class="line">  vec2 simpleUV = uv +poissonDisk[i] * (zReceiver<span class="number">-0.01</span>)/zReceiver;</span><br><span class="line">  <span class="keyword">float</span> shadowMapDepth = unpack(texture2D(uShadowMap,simpleUV));</span><br><span class="line">  <span class="keyword">if</span>(zReceiver &gt; (shadowMapDepth+EPS))&#123;</span><br><span class="line">    average_depth += shadowMapDepth;</span><br><span class="line">    count +=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有遮挡，但是想让效果看着柔和些</span></span><br><span class="line"><span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0.3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">average_depth /= <span class="keyword">float</span>(count);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PCSS函数</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">PCSS</span><span class="params">(sampler2D shadowMap, vec4 coords)</span></span>&#123;</span><br><span class="line">  <span class="comment">// STEP 1: avgblocker depth</span></span><br><span class="line">  <span class="keyword">float</span> blocker_depth = findBlocker(shadowMap, coords.xy, coords.z);</span><br><span class="line">  <span class="comment">// STEP 2: penumbra size</span></span><br><span class="line">  <span class="keyword">float</span> penumbra = (coords.z-blocker_depth)*LIGHT_WIDTH/blocker_depth;</span><br><span class="line">  <span class="comment">// STEP 3: filtering</span></span><br><span class="line">  <span class="keyword">return</span> PCF(shadowMap, coords, <span class="number">1.0</span>/<span class="number">2048.0</span> * <span class="number">5.0</span>  * penumbra);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/GAMES202hw1_04.png" alt=""></p><h2 id="优化效果"><a href="#优化效果" class="headerlink" title="优化效果"></a>优化效果</h2><p>开始的时候PCF和PCSS效果如下，可以看得出特别糊</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/GAMES202hw1_07.png" alt=""></p><p>通过修改NUM_SAMPLES进行优化，从20调到了60</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/GAMES202hw1_08.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GAMES202-作业1-part2&quot;&gt;&lt;a href=&quot;#GAMES202-作业1-part2&quot; class=&quot;headerlink&quot; title=&quot;GAMES202 作业1-part2&quot;&gt;&lt;/a&gt;GAMES202 作业1-part2&lt;/h1&gt;&lt;p&gt;应老师要求不
      
    
    </summary>
    
    
    
      <category term="GAMES202" scheme="https://crunchybiscuits.github.io/tags/GAMES202/"/>
    
  </entry>
  
  <entry>
    <title>GAMES202-作业1-part1</title>
    <link href="https://crunchybiscuits.github.io/2021/04/12/GAMES202-%E4%BD%9C%E4%B8%9A1-part1/"/>
    <id>https://crunchybiscuits.github.io/2021/04/12/GAMES202-%E4%BD%9C%E4%B8%9A1-part1/</id>
    <published>2021-04-12T13:35:55.000Z</published>
    <updated>2021-04-21T13:04:34.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GAMES202-作业1-part1"><a href="#GAMES202-作业1-part1" class="headerlink" title="GAMES202 作业1-part1"></a>GAMES202 作业1-part1</h1><p>应老师要求不会直接放上作业答案，会记录整体思路</p><h2 id="Two-Pass-Shadowmap"><a href="#Two-Pass-Shadowmap" class="headerlink" title="Two Pass Shadowmap"></a>Two Pass Shadowmap</h2><p>主要实现硬阴影，在shadowmap作业中需要修改的地方有两个</p><h3 id="DirectionalLight-js中CalcLightMVP-函数"><a href="#DirectionalLight-js中CalcLightMVP-函数" class="headerlink" title="DirectionalLight.js中CalcLightMVP()函数"></a>DirectionalLight.js中CalcLightMVP()函数</h3><p>MVP函数的参数签名如下</p><p>CalcLightMVP(translate, scale){}</p><p>首先需要做的是根据translate和scale进行model transform</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要使用的两个函数</span></span><br><span class="line"><span class="comment">// scale中a表示变换完之后存储的地方,b表示原矩阵,c表示变换</span></span><br><span class="line">mat4.scale(a, b, c);</span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">mat4.scale(modelMatrix, modelMatrix, scale);</span><br><span class="line"><span class="comment">// translate同理</span></span><br><span class="line">mat4.translate(a, b, c);</span><br></pre></td></tr></table></figure><p>接着是view transform，这里是根据提供的lightPos，focalPoint和lightUp进行lookat矩阵的构造</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lookAt函数</span></span><br><span class="line"><span class="comment">// a - 存储结果</span></span><br><span class="line"><span class="comment">// b - light position</span></span><br><span class="line"><span class="comment">// c - focal point</span></span><br><span class="line"><span class="comment">// d - light up</span></span><br><span class="line">mat4.lookAt(a,b,c,d);</span><br></pre></td></tr></table></figure><p>最后是投影矩阵，根据作业提示推荐使用了正交投影</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 投影矩阵设置</span></span><br><span class="line"><span class="comment">// a - 存储结果</span></span><br><span class="line"><span class="comment">// l, r - 控制矩阵左右</span></span><br><span class="line"><span class="comment">// b, t - 控制上下</span></span><br><span class="line"><span class="comment">// n, f - 控制远近</span></span><br><span class="line">mat4.ortho(a,l,r,b,t,n,f);</span><br></pre></td></tr></table></figure><h3 id="phongFragment-glsl中useShadowMap-函数"><a href="#phongFragment-glsl中useShadowMap-函数" class="headerlink" title="phongFragment.glsl中useShadowMap()函数"></a>phongFragment.glsl中useShadowMap()函数</h3><p>首先通过shadowCoord获取坐标并通过texture2D()进行采样</p><p><code>vec4 depth_raw =texture2D(shadowMap,shadowCoord.xy);</code></p><p>接着通过unpack函数对depth进行decode</p><p><code>float depth_decode =unpack(depth_raw);</code></p><p>然后通过跟shadowCoord.z的值进行深度比较得到阴影</p><p><code>if(depth_decode &gt; shadowCoord.z)</code></p><p>在main中对坐标进行NDC操作并传入函数，得到结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">// NDC</span></span><br><span class="line">    vec3 projCoords = vPositionFromLight.xyz / vPositionFromLight.w;</span><br><span class="line">     <span class="comment">// 范围从[-1,1]转到[0,1]</span></span><br><span class="line">vec3 shadowCoord = projCoords * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">     visibility = useShadowMap(uShadowMap, vec4(shadowCoord, <span class="number">1.0</span>));</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/GAMES202hw1_00.png" alt=""></p><p>出现如下错误原因是model transform顺序设置问题，本来操作应该是先缩放，再旋转，最后平移。但是这里是先translate，再scale(原因是将光源当作相机生成深度图，但是变换的时候本来思路是从原点变换到光源位置，但是在view transform的思路是逆变换，因此需要反过来) — 这里可能理解有误，mark一下，因为和朋友直接手写变换矩阵的时候按照SRT的顺序是对的</p><p>修改后如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/GAMES202hw1_01.png" alt=""></p><p>另一个需要优化的地方是阴影周围的锯齿，通过添加bias的方法，可以让整个阴影更加平滑。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/GAMES202hw1_05.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">getBias</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 解决自遮挡问题 -- 主要由shadow map精度导致</span></span><br><span class="line">  <span class="comment">// 第一个pass在渲染shadow map的时候会将场景离散化，但是shadow map精度有限因此记录不会很准去，</span></span><br><span class="line">  <span class="comment">// 在第二个pass进行判断的时候，就可能会有多个fragment对应到shadow map的同一个位置</span></span><br><span class="line">  vec3 lightDir = normalize(uLightPos);</span><br><span class="line">  vec3 normal = normalize(vNormal);</span><br><span class="line">  <span class="keyword">float</span> bias = max( <span class="number">0.003</span> *(<span class="number">1.0</span> - dot(normal, lightDir)), <span class="number">0.0003</span>);</span><br><span class="line">  <span class="keyword">return</span>  bias;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/GAMES202hw1_06.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GAMES202-作业1-part1&quot;&gt;&lt;a href=&quot;#GAMES202-作业1-part1&quot; class=&quot;headerlink&quot; title=&quot;GAMES202 作业1-part1&quot;&gt;&lt;/a&gt;GAMES202 作业1-part1&lt;/h1&gt;&lt;p&gt;应老师要求不
      
    
    </summary>
    
    
    
      <category term="GAMES202" scheme="https://crunchybiscuits.github.io/tags/GAMES202/"/>
    
  </entry>
  
  <entry>
    <title>基础光照</title>
    <link href="https://crunchybiscuits.github.io/2021/04/09/%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/"/>
    <id>https://crunchybiscuits.github.io/2021/04/09/%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/</id>
    <published>2021-04-09T15:01:40.000Z</published>
    <updated>2021-04-09T15:47:28.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="色调映射"><a href="#色调映射" class="headerlink" title="色调映射"></a>色调映射</h2><p>使用Tone-mapping，将HDR转换到LDR，将亮度给还原</p><p>一般在后处理阶段处理，尽量别在片元里做</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Aces公式</span></span><br><span class="line"><span class="function">float3 <span class="title">ACESFilm</span><span class="params">(float3 x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a = <span class="number">2.51f</span>;</span><br><span class="line">    <span class="keyword">float</span> b = <span class="number">0.03f</span>;</span><br><span class="line">    <span class="keyword">float</span> c = <span class="number">2.43f</span>;</span><br><span class="line">    <span class="keyword">float</span> d = <span class="number">0.59f</span>;</span><br><span class="line">    <span class="keyword">float</span> e = <span class="number">0.14f</span>;</span><br><span class="line">    <span class="keyword">return</span> saturate((x*(a*x +b))/(x*(c*x+d)+e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以先将基础颜色转换到线性空间，在最后再将颜色转换到伽马空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">half4 frag(v2f i):SV_Target&#123;</span><br><span class="line">    &#x2F;&#x2F; 线性-&gt;γ</span><br><span class="line">    half4 base_color &#x3D; tex2D(_MainTex, i.uv);</span><br><span class="line">    base_color &#x3D; pow(base_color,2.2);</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; γ-&gt;线性</span><br><span class="line">    half3 tone_color &#x3D; ...;</span><br><span class="line">    half4 final_color &#x3D; half4(tone_color, 1.0);</span><br><span class="line">    final_color &#x3D; pow(final_color,1.0&#x2F;2.2);</span><br><span class="line">    return final_color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>unity官方获取全局环境光的方法UNITY_LIGHTMODEL_AMBIENT.rgb，记得要添固有色</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">half3 ambient_color = UNITY_LIGHTMODEL_AMBIENT.rgb * base_col.xyz;</span><br></pre></td></tr></table></figure><h2 id="视差偏移"><a href="#视差偏移" class="headerlink" title="视差偏移"></a>视差偏移</h2><p>法线贴图带来的效果在平面和视角接近平行的时候，效果特别差</p><p>原因是法线贴图只能模拟高模表面的法线结构，但是不能模仿高模的几何结构</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/offset_00.png" alt=""></p><p><strong>置换贴图</strong></p><p>通过高度图进行实现，这个消耗特别大，因此引用视差贴图。</p><h3 id="视差贴图"><a href="#视差贴图" class="headerlink" title="视差贴图"></a>视差贴图</h3><p>思想：将视线转换到uv下面，再对uv进行偏移</p><p>原理：利用深度图(深度图是高度图的反色)中的深度信息对视线进行偏移，只是预估值。将三维的视线转换到切线空间。</p><p>步骤</p><ol><li>获取高度图</li><li>计算视线方向在切线空间下的坐标</li><li>进行偏移</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 视差</span></span><br><span class="line">half height = tex2D(_ParallaxMap, i.uv);</span><br><span class="line">half3 view_dir = normalize(_WorldSpaceCameraPos.xyz - i.pos_world);</span><br><span class="line">half3 view_tangentspace = normalize(mul(TBN, view_dir));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.0-height是深度图</span></span><br><span class="line">half2 uv_parallax = i.uv - (<span class="number">1.0</span>-height) * view_tangentspace.xy * _Parallax * <span class="number">0.01f</span>;</span><br></pre></td></tr></table></figure><h3 id="陡峭视差映射"><a href="#陡峭视差映射" class="headerlink" title="陡峭视差映射"></a>陡峭视差映射</h3><p>多次执行偏移操作获得准确结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 视差</span></span><br><span class="line">half3 view_dir = normalize(_WorldSpaceCameraPos.xyz - i.pos_world);</span><br><span class="line">half3 view_tangentspace = normalize(mul(TBN, view_dir));</span><br><span class="line">half2 uv_parallax = i.uv;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">    half height = tex2D(_ParallaxMap, uv_parallax);</span><br><span class="line">    <span class="comment">// 1.0-height是深度图, view_tangentspace.xy/view_tangentspace.z是矫正边缘的一些效果</span></span><br><span class="line">    <span class="comment">// 一般只有2-3次</span></span><br><span class="line">    uv_parallax = uv_parallax - (<span class="number">0.5</span>-height) * (view_tangentspace.xy/view_tangentspace.z) * _Parallax * <span class="number">0.01f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/offset_out.gif" alt=""></p><h2 id="ShadowMap原理"><a href="#ShadowMap原理" class="headerlink" title="ShadowMap原理"></a>ShadowMap原理</h2><p>本质上是在光源方向放置一个摄像机并作出一张深度图</p><p>分类</p><ol><li>传统实时阴影</li><li>Unity屏幕空间shadow map</li><li>联级阴影 – Project -&gt; Graphics -&gt; Cascaded Shadows选项</li></ol><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a><strong>实现思路</strong></h3><ol><li>只计算实时阴影</li></ol><p>SHADOW_COORDS(3) – 在顶点输出的结构体里，参数是存储器编号(TEXCOORD后面的数字)</p><p>TRANSFER_SHADOW(o) – 在顶点shader里</p><p>SHADOW_ATTENUATION(i) – 在片源shader里</p><hr><ol start="2"><li>处理投影，并且判断光源类型，计算光照衰减，cookies</li></ol><p>LIGHTING_COORDS(3,4)</p><p>TRANSFER_VERTEX_TO_FRAGMENT(o)</p><p>LIGHT_ATTENUATION(i) – 片源shader</p><hr><ol start="3"><li>计算投影，处理实时投影和静态投影的混合，光照衰减范围，cookies</li></ol><p>SHADOW_COORDS(2)</p><p>TRANSFER_SHADOW(o, v.uv1)</p><p>UNITY_LIGHT_ATTENUATION(atten, i, s.posWorld)</p><hr><p>以上三个必须有ShadowCaster，也可以通过Fallback，自动补全</p><p>最后效果（多光源）</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/offset_out2.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;色调映射&quot;&gt;&lt;a href=&quot;#色调映射&quot; class=&quot;headerlink&quot; title=&quot;色调映射&quot;&gt;&lt;/a&gt;色调映射&lt;/h2&gt;&lt;p&gt;使用Tone-mapping，将HDR转换到LDR，将亮度给还原&lt;/p&gt;
&lt;p&gt;一般在后处理阶段处理，尽量别在片元里做&lt;/p
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>高级光照</title>
    <link href="https://crunchybiscuits.github.io/2021/04/09/%E9%AB%98%E7%BA%A7%E5%85%89%E7%85%A7/"/>
    <id>https://crunchybiscuits.github.io/2021/04/09/%E9%AB%98%E7%BA%A7%E5%85%89%E7%85%A7/</id>
    <published>2021-04-09T14:42:22.000Z</published>
    <updated>2021-04-09T15:38:25.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境贴图"><a href="#环境贴图" class="headerlink" title="环境贴图"></a>环境贴图</h2><p>cube map单纯采样</p><p>环境贴图可能是全景图，可能是十字形或者一字形</p><p>立方体贴图(只是引擎的一种格式)：使用原因，采样标准</p><p>局限性：只能根据方向采样，不能考虑起始点，可能会产生cubemap采样错误，因此不适合做平面模型反射，解决方法 – local reflection</p><blockquote><p>texCube(_Cubemap, reflect_dir);</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">half4 <span class="title">frag</span> <span class="params">(v2f i)</span> : SV_Target    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    half3 normal_dir = normalize(i.normal_world);</span><br><span class="line">    half3 view_dir = normalize(_WorldSpaceCameraPos.xyz - i.pos_world);</span><br><span class="line">    <span class="comment">// 注意这里的是half3，最开始写成half少了很多数据而且不好找错</span></span><br><span class="line">    <span class="comment">// half reflect_dir = reflect(-view_dir, normal_dir);</span></span><br><span class="line">    half3 reflect_dir = reflect(-view_dir, normal_dir);</span><br><span class="line">    half4 color_cubemap = texCUBE(_CubeMap, reflect_dir);         </span><br><span class="line">    <span class="keyword">return</span> color_cubemap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HDR压缩格式"><a href="#HDR压缩格式" class="headerlink" title="HDR压缩格式"></a>HDR压缩格式</h3><p>BC6H在手机上不支持</p><p>在shader中可以通过unity进行解码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">samplerCUBE _CubeMap;</span><br><span class="line">float4 _CubeMap_HDR;</span><br><span class="line"></span><br><span class="line">frag()&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    half4 cube = texCUBE(_CubeMap, reflect_dir);</span><br><span class="line">    <span class="comment">// 通过这一句确保移动端也能用</span></span><br><span class="line">    half3 cube_col = DecodeHDR(cube, _CubeMap_HDR);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="旋转环境贴图"><a href="#旋转环境贴图" class="headerlink" title="旋转环境贴图"></a>旋转环境贴图</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 围绕y轴进行旋转，本质是将反射向量在水平方向旋转</span></span><br><span class="line">half rad = _Rotate * UNITY_PI / <span class="number">180</span>;</span><br><span class="line">half2x2 m_rotate = half2x2(<span class="built_in">cos</span>(rad), -<span class="built_in">sin</span>(rad), <span class="built_in">sin</span>(rad), <span class="built_in">cos</span>(rad));</span><br><span class="line">half2 dir_rotate = mul(m_rotate, reflect_dir.xz);</span><br><span class="line">reflect_dir = half3(dir_rotate.x, reflect_dir.y, dir_rotate.y);</span><br></pre></td></tr></table></figure><h3 id="Reflection-Probe"><a href="#Reflection-Probe" class="headerlink" title="Reflection Probe"></a>Reflection Probe</h3><p>捕捉周围环境信息，存储到环境贴图里面，用于模拟间接镜面反射质感</p><p>如果需要在reflection probe中有物体，那么那个物体必须设置Reflection probe static</p><p>之后创建Reflection probe并点选bake，生成的文件会自动存储到unity工程里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用反射探针方法</span></span><br><span class="line">half4 env_color = UNITY_SAMPLE_TEXCUBE(unity_SpecCube0, reflect_dir);</span><br><span class="line">half3 env_hdr_color = DecodeHDR(env_color, unity_SpecCube0_HDR);</span><br></pre></td></tr></table></figure><h2 id="基于图像的光照-IBL"><a href="#基于图像的光照-IBL" class="headerlink" title="基于图像的光照(IBL)"></a>基于图像的光照(IBL)</h2><p>本质上是环境贴图，但是添加了照明信息（PBR中间接光的镜面反射），记得开三线性</p><ol><li>读取IBL图像</li><li>利用图像生成光照信息</li><li>将光照信息存储回贴图</li></ol><p>将HDR的Mapping中Convolution Type选择Specular</p><p><strong>采样IBL, 注意和环境贴图的不同</strong></p><blockquote><p>texCUBElod(_CubeMap, float4(reflect_dir, num));</p></blockquote><h4 id="粗糙度"><a href="#粗糙度" class="headerlink" title="粗糙度"></a>粗糙度</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">half roughness = tex2D(_RoughnessMap, i.uv);</span><br><span class="line">roughness = saturate(<span class="built_in">pow</span>(roughness, _RoughnessContrast) * _RoughnessBrightness);</span><br><span class="line">roughness = lerp(_RoughnessMin, _RoughnessMax, roughness);</span><br><span class="line">half mip_level = roughness * <span class="number">6.0</span>;</span><br><span class="line">half4 color_cubemap = texCUBElod(_CubeMap, float4(reflect_dir,mip_level));</span><br></pre></td></tr></table></figure><p><strong>IBL+reflection probe</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">half4 color = UNITY_SAMPLE_TEXCUBE_LOD(unity_SpecCube0, reflect_dir,mip_level);</span><br><span class="line">half3 env_color = DecodeHDR(color, unity_SpecCube0_HDR);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/ibl_out.png" alt=""></p><p><strong>IBL的漫反射</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">half4 color = texCUBElod(_CubeMap, float4(normal_dir,mip_level));</span><br><span class="line">half3 env_color = DecodeHDR(color, _CubeMap_HDR);</span><br></pre></td></tr></table></figure><h2 id="球谐光照"><a href="#球谐光照" class="headerlink" title="球谐光照"></a>球谐光照</h2><p>从图像提取出漫反射信息</p><p>内置方法 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">half3 env_color &#x3D; ShadeSH9(float4(normal_dir, 1.0));</span><br></pre></td></tr></table></figure><p>球谐会另开一篇跟GAMES202课程一起写</p><h3 id="Light-Probe"><a href="#Light-Probe" class="headerlink" title="Light Probe"></a>Light Probe</h3><p>预先收集环境和光源的漫反射信息，存储到点中，用于模拟间接漫反射</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;环境贴图&quot;&gt;&lt;a href=&quot;#环境贴图&quot; class=&quot;headerlink&quot; title=&quot;环境贴图&quot;&gt;&lt;/a&gt;环境贴图&lt;/h2&gt;&lt;p&gt;cube map单纯采样&lt;/p&gt;
&lt;p&gt;环境贴图可能是全景图，可能是十字形或者一字形&lt;/p&gt;
&lt;p&gt;立方体贴图(只是引擎的一
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>光照模型和法线贴图(悲惨调试经历)</title>
    <link href="https://crunchybiscuits.github.io/2021/04/08/%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE-%E6%82%B2%E6%83%A8%E8%B0%83%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    <id>https://crunchybiscuits.github.io/2021/04/08/%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE-%E6%82%B2%E6%83%A8%E8%B0%83%E8%AF%95%E7%BB%8F%E5%8E%86/</id>
    <published>2021-04-08T14:04:25.000Z</published>
    <updated>2021-04-09T15:52:42.422Z</updated>
    
    <content type="html"><![CDATA[<p>实习的悲惨事故，主要在两个细小得错误上花费了特别多的时间，两个都是出在宏定义的地方，先把这个东西高高挂起</p><p><strong>#pragma multi_compile_fwdadd</strong></p><p>写成了multi_comple_fwdadd，导致在写多光源部分找了很久没找到问题，一直以为是代码逻辑出错</p><h2 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h2><p>光照计算的思考方式</p><ol><li>光源</li><li>模型表面材质结构</li><li>观察方向</li></ol><h3 id="光源"><a href="#光源" class="headerlink" title="光源"></a>光源</h3><ol><li>光源类型<ol><li>聚光灯和点光有衰减</li><li>光源方向</li><li>光源颜色</li></ol></li><li>灯光数据传递方式—RenderPath<ol><li>Forward 前向渲染<ol><li>Unity内置渲染管线Built-in</li><li>Unity URP渲染管线<ol><li>光照方面，能够在单个pass处理多个灯光</li></ol></li></ol></li><li>Deferred 延迟渲染：以灯光为单位进行渲染，因为使用了MRT<ol><li>UE4默认路径</li><li>Unity UDRP渲染管线</li></ol></li></ol></li></ol><h3 id="RenderPath"><a href="#RenderPath" class="headerlink" title="RenderPath"></a>RenderPath</h3><p>决定了shader是以怎样的一个规则去计算灯光的</p><ul><li><p>前向渲染：unity内置的渲染管线， unity URP渲染管线</p></li><li><p>延迟渲染：UE4默认渲染路径， Unity HDRP渲染管线</p></li></ul><h4 id="前向渲染：物体被重复叠加绘制多次（实时灯光的数量）"><a href="#前向渲染：物体被重复叠加绘制多次（实时灯光的数量）" class="headerlink" title="前向渲染：物体被重复叠加绘制多次（实时灯光的数量）"></a>前向渲染：物体被重复叠加绘制多次（实时灯光的数量）</h4><p>forwardadd函数</p><p>前向渲染的消耗问题，引擎edit -&gt; project setting -&gt; quality -&gt; pixel light count，不调整会出现粗糙灯光</p><p>超过了light count的灯光，就会被当作顶点光源，只能在顶点shader里进行计算</p><p>需要shader里面写两个pass：</p><ol><li>forward base：主方向光，也处理超出数量的顶点灯光</li><li>forward pass：结果通过 blend one one的方式进行叠加</li></ol><h4 id="延迟渲染："><a href="#延迟渲染：" class="headerlink" title="延迟渲染："></a>延迟渲染：</h4><p>主要两个阶段</p><ol><li>RenderDeferred gbuffer<br>这里使用了MRT — Multi Render Target<br>RT0 diffuse<br>RT1 金属度<br>RT2 法线数据<br>Depth 深度</li><li>RenderDeferred lighting<br>以灯光为单位对场景进行渲染，因为把需要的信息已经提前渲染好了 </li></ol><p><strong>延迟渲染对多光源友好，有一定使用瓶颈，占用带宽高，普通机型可能受不了，前向渲染就很轻量化</strong></p><p><strong>怎么判断是否是主方向光 — 光的亮度最大那个</strong></p><h3 id="模型表面材质结构"><a href="#模型表面材质结构" class="headerlink" title="模型表面材质结构"></a>模型表面材质结构</h3><ol><li>顶点法线</li><li>法线贴图</li><li>光滑度</li><li>PBR理论框架</li></ol><h3 id="多光源的实现"><a href="#多光源的实现" class="headerlink" title="多光源的实现"></a>多光源的实现</h3><p>通过forwardadd pass实现</p><p>第二个pass修改地方</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tags&#123;<span class="string">&quot;LightMode&quot;</span>=<span class="string">&quot;ForwardAdd&quot;</span>&#125;</span><br><span class="line">Blend One One</span><br><span class="line">#pragma multi_compile_fwdadd</span><br><span class="line">#include <span class="string">&quot;AutoLight.cginc&quot;</span></span><br></pre></td></tr></table></figure><p><strong>衰减的计算</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(DIRECTIONAL)</span></span><br><span class="line"><span class="comment">// 平行光</span></span><br><span class="line">half3 light_dir = _WorldSpaceLightPos0.xyz;</span><br><span class="line">half attuenation = <span class="number">1.0</span></span><br><span class="line">#elif defined(POINT)</span><br><span class="line"><span class="comment">// 点光</span></span><br><span class="line">half3 light_dir = normalize(_WorldSpaceLightPos0.xyz - i.pos_world);</span><br><span class="line"><span class="comment">// 衰减范围计算</span></span><br><span class="line">half distance = length(_WorldSpaceLightPos0.xyz - i.pos_world);</span><br><span class="line">half range = <span class="number">1.0</span> / unity_WorldToLight[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">half attuenation = saturate((range - distance)/range);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h2><p>思路：</p><ol><li><p>切线是在模型导入的时候确定的，根据UV中U方向走向定义的</p></li><li><p>再通过法线和切线cross得到副切线，就构成了切线空间</p></li></ol><p><strong>在shader中关键点在tangent.w分量的处理，主要是用来处理不同平台法线反转的问题</strong></p><p>压缩格式问题：PC上DXT/BC对法线贴图压缩，这样通道信息就会变更，只剩红色通道和alpha通道(所以红色不一定是错的)</p><p>在shader还需要解码操作，因为法线贴图范围是[0,1]，但是法线数据需要[-1,1]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vert(appdata v)&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    o.normal_dir = normalize(mul(float4(v.normal, <span class="number">0.0</span>),unity_WorldToObject).xyz);</span><br><span class="line">    o.pos_world = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">    o.tangent_dir = normalize(mul(unity_ObjectToWorld, float4(v.tangent.xyz,<span class="number">0.0</span>)).xyz);</span><br><span class="line">    o.binormal_dir = normalize(cross(o.normal_dir, o.tangent_dir)) * v.tangent.w;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">frag(v2f i):SV_TARGET&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    half4 normalmap = tex2D(_NormalMap, i.uv);</span><br><span class="line">    half3 normal_data = UnpackNormal(normalmap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// normalmap</span></span><br><span class="line">    half3 normal_dir =  normalize(i.normal_dir);</span><br><span class="line">    half3 tangent_dir = normalize(i.tangent_dir);</span><br><span class="line">    half3 binormal_dir = normalize(i.binormal_dir);</span><br><span class="line"></span><br><span class="line">    normal_dir = normalize(tangent_dir * normal_data.x + binormal_dir * normal_data.y + normal_dir * normal_data.z);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="blinn-phong"><a href="#blinn-phong" class="headerlink" title="blinn-phong"></a>blinn-phong</h3><p>在phong上进行了优化，使用了半程向量</p><p>半程向量是光照和视线方向的中间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">half3 half_dir = normalize(light_dir + view_dir);</span><br><span class="line">half NdotH = dot(normalize_dir, half_dir);</span><br></pre></td></tr></table></figure><p>显示器的输出结果是在0-1的，但是shader的返回值可以很大，因此会有过曝</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实习的悲惨事故，主要在两个细小得错误上花费了特别多的时间，两个都是出在宏定义的地方，先把这个东西高高挂起&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#pragma multi_compile_fwdadd&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;写成了multi_comple_fwdadd，导
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>GAMES202-Lecture3笔记</title>
    <link href="https://crunchybiscuits.github.io/2021/04/06/GAMES202-Lecture3%E7%AC%94%E8%AE%B0/"/>
    <id>https://crunchybiscuits.github.io/2021/04/06/GAMES202-Lecture3%E7%AC%94%E8%AE%B0/</id>
    <published>2021-04-06T12:22:06.000Z</published>
    <updated>2021-04-20T13:32:19.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GAMES202-Lecture3"><a href="#GAMES202-Lecture3" class="headerlink" title="GAMES202-Lecture3"></a>GAMES202-Lecture3</h1><p>实时阴影</p><h2 id="Shadow-Mapping"><a href="#Shadow-Mapping" class="headerlink" title="Shadow Mapping"></a>Shadow Mapping</h2><p>特点：</p><ol><li>2个Pass的算法<ol><li>light pass生成shadow map</li><li>camera pass使用shadow map</li></ol></li><li>是图像空间的算法，当shadow map已经生成，那么就不需要实际的场景中的物体，直接使用shadow map就可以计算阴影</li><li>坏处：<ol><li>自遮挡现象</li><li>走样的问题</li></ol></li></ol><p>过程：</p><ul><li>pass1: 从光源方向渲染，只需要一个深度的信息</li><li>pass2: 从相机方向开始渲染</li><li>和光源方向的开始比较，如果点和相机方向的相同，那么就是能被光找到，如果不行那么就是在阴影中，用z值还是实际距离都行，但是要保持一致。</li></ul><h3 id="自遮挡问题"><a href="#自遮挡问题" class="headerlink" title="自遮挡问题"></a>自遮挡问题</h3><p>shadow map记录的是不连续的，因此会出现阴影和物体断开的现象，可以通过添加一个bias来减少自遮挡问题 — 当光源和平面夹角越大，那么bias越大(会导致阴影的断开)，bias的大小也会影响阴影的质量</p><p>second-depth shadow mapping:</p><ol><li>不仅存最小深度，还存次小的深度，之后用这两个深度取一个中间值</li><li>但是工业界不用</li></ol><h3 id="走样问题"><a href="#走样问题" class="headerlink" title="走样问题"></a>走样问题</h3><p>渲染的时候分辨率不够大</p><h2 id="shadow-mapping背后数学原理"><a href="#shadow-mapping背后数学原理" class="headerlink" title="shadow mapping背后数学原理"></a>shadow mapping背后数学原理</h2><p><strong>在实时渲染中关心近似相等，将不等式当作约等式使用</strong><br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/202-lecture3-00.jpg" alt=""></p><ol><li>约等式是把乘积的积分拆成了积分的乘积(数学意义上是不精确的)</li><li>分母是归一化的常数</li><li>什么时候是准确的(两个有一个就行)？<ol><li>当g的积分范围特别小的时候</li><li>g在足够光滑的时候</li></ol></li></ol><p>约等式用法：<br>将渲染方程拆成了，shading和visibility两部分<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/202-lecture3-01.jpg" alt=""></p><ol><li>g积分范围小的情形: 对于点光源和方向光源就特别精确</li><li>smooth的情形: 当光源是正常的面光源，shading point是diffuse的情况下 — 51min</li></ol><h2 id="Percentage-Closer-Soft-Shadows（PCSS）–-55min"><a href="#Percentage-Closer-Soft-Shadows（PCSS）–-55min" class="headerlink" title="Percentage Closer Soft Shadows（PCSS）– 55min"></a>Percentage Closer Soft Shadows（PCSS）– 55min</h2><p>使用理由，从硬阴影到软阴影，因为日常生活中，绝大多数情况是面光源</p><h3 id="Percentage-Closer-Filtering-PCF"><a href="#Percentage-Closer-Filtering-PCF" class="headerlink" title="Percentage Closer Filtering(PCF)"></a>Percentage Closer Filtering(PCF)</h3><ol><li>主要用来做anti-aliasing的，本质上是求平均 – 类似卷积(在那个点找一圈像素)，<strong>在做阴影判断的时候使用Filtering</strong>。</li><li>但是开销很大，从检查一次变成7*7或者9*9</li><li>主要步骤<ol><li>获取shadow map和对应的坐标</li><li>设置filter和随机采样的数目</li><li>判断每个采样点的shadow map值</li><li>进行累加求平均</li></ol></li></ol><h3 id="PCSS-–-70min"><a href="#PCSS-–-70min" class="headerlink" title="PCSS – 70min"></a>PCSS – 70min</h3><ol><li>PCF的使用 — 使用PCF将filter size调大，硬阴影就会变soft</li><li>阴影接受物到阴影投射物的远近程度(blocker distance)，决定阴影的软硬，因此不同位置，不同的filter size<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/202-lecture3-02.jpg" alt=""></li><li>如何确定filter size – 74min<ol><li>对一个shading point来说要看有多少像素能挡住它的，这些像素的平均值就是average blocker depth</li><li>如何决定blocker search的范围 — 77min<ol><li>离光源的距离</li><li>光源大小<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/202-lecture3-03.jpg" alt=""></li></ol></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GAMES202-Lecture3&quot;&gt;&lt;a href=&quot;#GAMES202-Lecture3&quot; class=&quot;headerlink&quot; title=&quot;GAMES202-Lecture3&quot;&gt;&lt;/a&gt;GAMES202-Lecture3&lt;/h1&gt;&lt;p&gt;实时阴影&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
    
      <category term="GAMES202" scheme="https://crunchybiscuits.github.io/tags/GAMES202/"/>
    
  </entry>
  
  <entry>
    <title>模糊算法</title>
    <link href="https://crunchybiscuits.github.io/2021/04/05/%E6%A8%A1%E7%B3%8A%E7%AE%97%E6%B3%95/"/>
    <id>https://crunchybiscuits.github.io/2021/04/05/%E6%A8%A1%E7%B3%8A%E7%AE%97%E6%B3%95/</id>
    <published>2021-04-05T04:27:00.000Z</published>
    <updated>2021-04-05T10:13:47.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模糊算法"><a href="#模糊算法" class="headerlink" title="模糊算法"></a>模糊算法</h1><p>大部分模糊算法参考在<a href="https://zhuanlan.zhihu.com/p/125744132">这里</a></p><h2 id="均值模糊"><a href="#均值模糊" class="headerlink" title="均值模糊"></a>均值模糊</h2><p>原理：通过卷积核对周围的像素进行平均，所有权重都是一样的</p><figure class="highlight plain"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这个是内置变量，x &#x3D; 1&#x2F;width, y &#x3D; 1&#x2F;height, z &#x3D; width, w &#x3D; height</span><br><span class="line">&#x2F;&#x2F; 这样x，y就能代表偏移值</span><br><span class="line">float4 _MainTex_TexelSize;</span><br></pre></td></tr></table></figure><p>2 * 2均值模糊，其他模糊以此类推</p><figure class="highlight plain"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 2*2 均值模糊</span><br><span class="line">half4 d &#x3D; _MainTex_TexelSize.xyxy * half4(-1,-1,1,1) * _BlurOffset;</span><br><span class="line">half4 s&#x3D; 0;</span><br><span class="line">s +&#x3D; tex2D(_MainTex, i.uv + d.zw);</span><br><span class="line">s +&#x3D; tex2D(_MainTex, i.uv + d.zx);</span><br><span class="line">s +&#x3D; tex2D(_MainTex, i.uv + d.xz);</span><br><span class="line">s +&#x3D; tex2D(_MainTex, i.uv + d.xy);</span><br><span class="line">s *&#x3D; 0.25;</span><br></pre></td></tr></table></figure><p>可通过在C#脚本中可以提高迭代次数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Graphics.Blit(source, rt1, material);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;_Interation;i++)&#123;</span><br><span class="line">    Graphics.Blit(rt1,rt2,material);</span><br><span class="line">       Graphics.Blit(rt2,rt1,material);</span><br><span class="line">   &#125;</span><br><span class="line">       </span><br><span class="line">   Graphics.Blit(rt1, destination, material);</span><br></pre></td></tr></table></figure><h2 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h2><p>原理：同均值模糊，但是权重从中心往边缘呈高斯分布</p><p>优化后的高斯模糊 —&gt; 直接使用5<em>5高斯核会很浪费，转换成两次1\</em>5的操作，一次横向，一次纵向</p><p>因为已经有权重所以不用最后再除了</p><figure class="highlight plain"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 水平方向</span><br><span class="line">    half4 frag_HorizontalBlur (v2f_img i) : SV_Target&#123;</span><br><span class="line">        half4 d &#x3D; _BlurOffset.xyxy * half4(-1,-1,1,1);</span><br><span class="line">        half2 uv1 &#x3D; i.uv + _BlurOffset*half2(1,0)*-2.0;</span><br><span class="line">        half2 uv2 &#x3D; i.uv + _BlurOffset*half2(1,0)*-1.0;</span><br><span class="line">        half2 uv3 &#x3D; i.uv;</span><br><span class="line">        half2 uv4 &#x3D; i.uv + _BlurOffset*half2(1,0);</span><br><span class="line">        half2 uv5 &#x3D; i.uv + _BlurOffset*half2(1,0)*2.0;</span><br><span class="line"></span><br><span class="line">        half4 s&#x3D; 0;</span><br><span class="line">        s +&#x3D; tex2D(_MainTex, uv1) * 0.05;</span><br><span class="line">        s +&#x3D; tex2D(_MainTex, uv2) * 0.25;</span><br><span class="line">        s +&#x3D; tex2D(_MainTex, uv3) * 0.4;</span><br><span class="line">        s +&#x3D; tex2D(_MainTex, uv4) * 0.25;</span><br><span class="line">        s +&#x3D; tex2D(_MainTex, uv5) * 0.05;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="双重模糊"><a href="#双重模糊" class="headerlink" title="双重模糊"></a>双重模糊</h2><p>先降采样，再升采样</p><p>shader层面不用修改</p><p>C#中在迭代过程中降低和增加图片大小</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 降采样</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;_Interation;i++)&#123;</span><br><span class="line">    <span class="comment">// 水平方向</span></span><br><span class="line">    RenderTexture.ReleaseTemporary(rt2);</span><br><span class="line">    width /= <span class="number">2</span>;</span><br><span class="line">    height /= <span class="number">2</span>;</span><br><span class="line">    rt2 = RenderTexture.GetTemporary(width,height);</span><br><span class="line">    Graphics.Blit(rt1,rt2,material,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 垂直方向</span></span><br><span class="line">    RenderTexture.ReleaseTemporary(rt1);</span><br><span class="line">    width /= <span class="number">2</span>;</span><br><span class="line">    height /= <span class="number">2</span>;</span><br><span class="line">    rt1 = RenderTexture.GetTemporary(width,height);</span><br><span class="line">    Graphics.Blit(rt2,rt1,material,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 升采样 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;_Interation;i++)&#123;</span><br><span class="line">    <span class="comment">// 水平方向</span></span><br><span class="line">    RenderTexture.ReleaseTemporary(rt2);</span><br><span class="line">    width *= <span class="number">2</span>;</span><br><span class="line">    height *= <span class="number">2</span>;</span><br><span class="line">    rt2 = RenderTexture.GetTemporary(width,height);</span><br><span class="line">    Graphics.Blit(rt1,rt2,material,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 垂直方向</span></span><br><span class="line">    RenderTexture.ReleaseTemporary(rt1);</span><br><span class="line">    width *= <span class="number">2</span>;</span><br><span class="line">    height *= <span class="number">2</span>;</span><br><span class="line">    rt1 = RenderTexture.GetTemporary(width,height);</span><br><span class="line">    Graphics.Blit(rt2,rt1,material,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;模糊算法&quot;&gt;&lt;a href=&quot;#模糊算法&quot; class=&quot;headerlink&quot; title=&quot;模糊算法&quot;&gt;&lt;/a&gt;模糊算法&lt;/h1&gt;&lt;p&gt;大部分模糊算法参考在&lt;a href=&quot;https://zhuanlan.zhihu.com/p/125744132&quot;&gt;这里&lt;
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>后处理逻辑</title>
    <link href="https://crunchybiscuits.github.io/2021/04/04/%E5%90%8E%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91/"/>
    <id>https://crunchybiscuits.github.io/2021/04/04/%E5%90%8E%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91/</id>
    <published>2021-04-04T12:27:21.000Z</published>
    <updated>2021-04-09T15:51:54.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="后处理逻辑"><a href="#后处理逻辑" class="headerlink" title="后处理逻辑"></a>后处理逻辑</h1><p>原理：根据屏幕的大小设置一个正方形的面片，重新渲染这个面片，调用shader，之后对帧缓冲区图像进行自定义的处理。</p><p>OnRenderImage()的on一定要大写！一定要大写！查错查了可久</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExecuteInEditMode函数让脚本在编辑阶段可运行</span></span><br><span class="line">[<span class="meta">ExecuteInEditMode()</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ImageEffectTest</span>: <span class="title">MonoBehaviour</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Material material;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 是否使用当前后处理的判断逻辑</span></span><br><span class="line">        <span class="keyword">if</span>(material == <span class="literal">null</span> || SystemInfo.supportsImageEffects == <span class="literal">false</span></span><br><span class="line">            || material.shader == <span class="literal">null</span> || material.shader.isSupported == <span class="literal">false</span>)&#123;</span><br><span class="line">            enabled = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只能挂在摄像机上</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture source, RenderTexture destination</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 第四个参数表示是哪个pass</span></span><br><span class="line">        Graphics.Blit(source, destination, material, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算屏幕空间坐标"><a href="#计算屏幕空间坐标" class="headerlink" title="计算屏幕空间坐标"></a>计算屏幕空间坐标</h2><h3 id="起因和原理"><a href="#起因和原理" class="headerlink" title="起因和原理"></a>起因和原理</h3><p><strong>起因</strong>：因为希望图片在屏幕尺寸变换的时候，跟着一起变换</p><p><strong>原理</strong>：NDC坐标归一化的时候将图片展到和设备坐标相同的位置</p><p><strong>注意：写后处理逻辑的shader的时候一定设置，Cull Off， ZWrite Off，ZTest Always</strong></p><figure class="highlight plain"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 透视除法,这一步操作不能在顶点阶段做，提前做了screen_uv就不是线性的值了</span><br><span class="line">half2 screen_uv &#x3D; i.screen_pos.xy &#x2F; (i.screen_pos.w + 0.000001);</span><br><span class="line">&#x2F;&#x2F; 映射到0-1</span><br><span class="line">screen_uv &#x3D; (screen_uv + 1.0) * 0.5;</span><br></pre></td></tr></table></figure><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><p><strong>直接使用上述方法可能会遇到屏幕上下反转的问题，原因是平台坐标不同起始点导致</strong></p><p>使用_ProjectionParams.x处理屏幕翻转问题 — 主要是不同平台的处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.screen_pos.y &#x3D; o.screen_pos.y * _ProjectionParams.x;</span><br></pre></td></tr></table></figure><h3 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h3><ol><li>ComputeScreenPos(clip_pos) 处理屏幕翻转以及缩放 _ProjectionParams.x</li><li>ComputeGrabScreenPos(clip_pos) 处理Grab图像的翻转UNITY_UV_STARTS_AT_TOP</li><li><strong>可以使用vert_img顶点函数和v2f_img结构体来方便编写</strong></li></ol><h2 id="ColorAdjustment"><a href="#ColorAdjustment" class="headerlink" title="ColorAdjustment"></a>ColorAdjustment</h2><h3 id="色相-饱和度-对比度-亮度"><a href="#色相-饱和度-对比度-亮度" class="headerlink" title="色相/饱和度/对比度/亮度"></a>色相/饱和度/对比度/亮度</h3><p><strong>亮度</strong>：</p><figure class="highlight plain"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">half4 col &#x3D; tex2D(_MainTex, i.uv);</span><br><span class="line">half3 finalcol &#x3D; col.rgb * _Brightness;</span><br></pre></td></tr></table></figure><p><strong>饱和度</strong>：</p><p><strong>饱和度分为两种，线性空间和伽马空间，计算后再通过lerp插值得到饱和度</strong></p><figure class="highlight plain"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 伽马空间</span><br><span class="line">dot(col, float3(0.22,0.707,0.071));</span><br><span class="line">&#x2F;&#x2F; 线性空间</span><br><span class="line">dot(col, float3(0.0396, 0.458, 0.0061));</span><br></pre></td></tr></table></figure><p><strong>对比度</strong>：</p><p>和计算饱和度很相似，和(0.5,0.5,0.5)作插值</p><p><strong>色相</strong>：</p><p>调整色相先rgb-&gt;hsv，对r分量进行操作之后再hsv-&gt;rgb, 函数取自unity</p><h3 id="晕影-暗角"><a href="#晕影-暗角" class="headerlink" title="晕影/暗角"></a>晕影/暗角</h3><p>原理：中心距离周围点的距离，越远越暗</p><p>思路：计算中心点到周围距离长度的绝对值</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/post_out.gif" alt=""></p><h2 id="碎屏效果及对应处理"><a href="#碎屏效果及对应处理" class="headerlink" title="碎屏效果及对应处理"></a>碎屏效果及对应处理</h2><ol><li><p>在unity材质面板中设置wrap mode</p></li><li><p>根据屏幕宽高比例进行设置，shader对应使用_ScreenParams.x和_ScreenParams.y</p></li></ol><h3 id="法线图Noise修正"><a href="#法线图Noise修正" class="headerlink" title="法线图Noise修正"></a>法线图Noise修正</h3><p>出现原因：法线贴图中有噪点</p><p>修改方法：ps中修改贴图</p><h3 id="UV边缘扭曲限制"><a href="#UV边缘扭曲限制" class="headerlink" title="UV边缘扭曲限制"></a>UV边缘扭曲限制</h3><figure class="highlight plain"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">half2 d &#x3D; 1.0 - smoothstep(0.9,1,abs(i.uv * 2.0 -1.0));</span><br><span class="line">half vfactor &#x3D; d.x * d.y;</span><br><span class="line"></span><br><span class="line">half2 uv_distort &#x3D; i.uv + glass_normal.xy * _Distort * vfactor;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;后处理逻辑&quot;&gt;&lt;a href=&quot;#后处理逻辑&quot; class=&quot;headerlink&quot; title=&quot;后处理逻辑&quot;&gt;&lt;/a&gt;后处理逻辑&lt;/h1&gt;&lt;p&gt;原理：根据屏幕的大小设置一个正方形的面片，重新渲染这个面片，调用shader，之后对帧缓冲区图像进行自定义的处理。&lt;
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>次世代锤子模型制作过程（更新中）</title>
    <link href="https://crunchybiscuits.github.io/2021/03/25/%E6%AC%A1%E4%B8%96%E4%BB%A3%E9%94%A4%E5%AD%90%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8B/"/>
    <id>https://crunchybiscuits.github.io/2021/03/25/%E6%AC%A1%E4%B8%96%E4%BB%A3%E9%94%A4%E5%AD%90%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8B/</id>
    <published>2021-03-25T12:24:47.000Z</published>
    <updated>2021-03-28T18:09:58.997Z</updated>
    
    <content type="html"><![CDATA[<h1 id="制作过程"><a href="#制作过程" class="headerlink" title="制作过程"></a>制作过程</h1><p>主要使用工具3dmax，zbrush，substance painter</p><h2 id="3dmax"><a href="#3dmax" class="headerlink" title="3dmax"></a>3dmax</h2><p>目标锤子如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/hammer1.jpg" alt=""></p><p>首先在3dmax中建模</p><p>其中用到的操作，切角（锤子两边突起，需要做些裂缝的时候显得比较精致），镜像(做一半就行)</p><p>最开始，效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/hammer2.jpg" alt=""></p><h2 id="zbrush"><a href="#zbrush" class="headerlink" title="zbrush"></a>zbrush</h2><h2 id="substance-painter"><a href="#substance-painter" class="headerlink" title="substance painter"></a>substance painter</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;制作过程&quot;&gt;&lt;a href=&quot;#制作过程&quot; class=&quot;headerlink&quot; title=&quot;制作过程&quot;&gt;&lt;/a&gt;制作过程&lt;/h1&gt;&lt;p&gt;主要使用工具3dmax，zbrush，substance painter&lt;/p&gt;
&lt;h2 id=&quot;3dmax&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
    
      <category term="modelling" scheme="https://crunchybiscuits.github.io/tags/modelling/"/>
    
  </entry>
  
  <entry>
    <title>玉石模拟shader制作流程</title>
    <link href="https://crunchybiscuits.github.io/2021/03/25/%E7%8E%89%E7%9F%B3%E5%85%89%E7%85%A7%E6%A8%A1%E6%8B%9Fshader%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
    <id>https://crunchybiscuits.github.io/2021/03/25/%E7%8E%89%E7%9F%B3%E5%85%89%E7%85%A7%E6%A8%A1%E6%8B%9Fshader%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/</id>
    <published>2021-03-25T12:21:55.000Z</published>
    <updated>2021-04-09T15:22:58.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="玉石材质模拟"><a href="#玉石材质模拟" class="headerlink" title="玉石材质模拟"></a>玉石材质模拟</h1><p>整体效果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/dragon_out2.gif" alt=""></p><h2 id="玉石光线"><a href="#玉石光线" class="headerlink" title="玉石光线"></a>玉石光线</h2><p>主要是光线穿透感的算法</p><p>首先导入模型，初始状态如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/dragon_one.jpg" alt=""></p><p>接着实现漫反射的效果：</p><p>首先打开光照需要添加LightMode，包含AutoLight.cginc文件, 添加#pragma multi_compile_fwdbase</p><p>漫反射计算是通过法线和光线的点积</p><p>实现之后结果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/dragon_two.jpg" alt=""></p><p>接下来实现透射光的效果</p><p>透射光主要是希望从背面打过来的光线能够透过一部分，而漫反射是照亮整个受光的部分</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/dragon_three.jpg" alt=""></p><p>透射光的原理是通过相机观察方向跟光线照射的夹角，如果这两个方向接近平行，那么就有那样的效果</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/dragon_four.jpg" alt=""></p><p>因此首先获取View和light的点积</p><figure class="highlight plain"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float VdotL &#x3D; dot(view_dir, -light_dir);</span><br><span class="line">&#x2F;&#x2F; diffuse</span><br><span class="line">float3 NdotL &#x3D; max(0.0, dot(normal_dir, light_dir));</span><br><span class="line">float3 diffuse &#x3D; VdotL * _LightColor0.xyz;</span><br><span class="line">return float4(diffuse,0.0);</span><br></pre></td></tr></table></figure><p>效果如下，视角不同，透射感觉不同：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/dragon_five.jpg" alt=""></p><p>但是看到的都是纯色的太平，因此先通过pow缩小范围，再提高对比度</p><p>效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/dragon_six.jpg" alt=""></p><p>接下来加入光线照射到模型之后<strong>在模型的内部产生一些折射的现象</strong>，具体做法就是光线向量加上法线向量，法线向量可以加上一个权重值，这样可以简单模拟折射</p><figure class="highlight plain"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">float3 back_dir &#x3D; -normalize(light_dir + normal_dir * _Distort);</span><br><span class="line"></span><br><span class="line">float VdotL &#x3D; dot(view_dir, back_dir);</span><br><span class="line">float backlight_term &#x3D; max(0.0, pow(VdotL, 5.0));</span><br><span class="line"></span><br><span class="line">float3 diffuse &#x3D; backlight_term * _LightColor0.xyz;</span><br><span class="line">           </span><br><span class="line">return float4(diffuse,0.0);</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/dragon_seven.jpg" alt=""></p><p>接着加入对比度和亮度，加强这种效果</p><p>效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/dragon_eight.jpg" alt=""></p><p>之后添加点光的效果，通过添加一个pass，将pass的Tags修改成{“LightMode”=”ForwardAdd”}，混合模式设定为one one，#pragma multi_compile_fwdadd</p><p>效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/dragon_nine.jpg" alt=""></p><p>现在为模型添加厚度的区分，因为有的区域厚不容易被照亮，有的区域薄容易被照亮。通过substance painter对模型进行操作</p><p>在软件中打开模型，显示如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/dragon_ten.jpg" alt=""></p><p>之后设置烘焙，在里面只勾选厚度，并将这个选项调到最大之后导出</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/dragon_eleven.jpg" alt=""></p><p>接下来在shader中读取厚度图，两个pass都需要</p><figure class="highlight plain"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 读取厚度, 因为厚度图是越透的地方越黑，所以用1减去</span><br><span class="line">float thickness &#x3D; 1.0 - tex2D(_ThicknessMap, i.uv).r;</span><br><span class="line"></span><br><span class="line">float3 diffuse &#x3D; backlight_term * _LightColor0.xyz * thickness;</span><br></pre></td></tr></table></figure><p>只输出厚度图的效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/dragon_twelve.jpg" alt=""></p><p>叠加在一起效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/dragon_thirteen.jpg" alt=""></p><h2 id="光滑质感模拟"><a href="#光滑质感模拟" class="headerlink" title="光滑质感模拟"></a>光滑质感模拟</h2><p>首先添加Cube map</p><p>单纯输出效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/dragon_fourteen.jpg" alt=""></p><p>接着加入旋转效果用于调整光泽</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 光泽反射</span><br><span class="line">float3 reflect_dir &#x3D; reflect(-view_dir, normal_dir);</span><br><span class="line">&#x2F;&#x2F; 计算弧度</span><br><span class="line">float theta &#x3D; _EnvRotate * UNITY_PI&#x2F;180.0;</span><br><span class="line">float2x2 rotMatrix &#x3D; float2x2(cos(theta),-sin(theta),</span><br><span class="line">                                               sin(theta),cos(theta));</span><br><span class="line">float2 dir_rotate &#x3D; mul(rotMatrix, reflect_dir.xz);</span><br><span class="line">reflect_dir &#x3D; float3(dir_rotate.x, reflect_dir.y, dir_rotate.y);</span><br><span class="line">float4 hdr_color &#x3D; texCUBE(_CubeMap, reflect_dir);</span><br><span class="line">float3 env_color &#x3D; DecodeHDR(hdr_color, _CubeMap_HDR);</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/dragon_out1.gif" alt=""></p><p>接着加入菲涅尔，边缘区域反射强一些，中心区域弱一些，本质是NdotV</p><p>和光线投射结合效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/dragon_fifteen.jpg" alt=""></p><p>接着添加漫反射光，这里没有材质贴图，因此用纯色代替基础色并通过添加一个颜色来提亮整个模型</p><p>接下来是网传的trick，添加一个类似的天光，之后打开forwardAdd pass</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float sky_light &#x3D; (dot(normal_dir, float3(0,1,0)) + 1.0) * 0.5;</span><br><span class="line">float3 sky_light_color &#x3D; sky_light * diffuse_color;</span><br><span class="line">float3 final_diffuse &#x3D; diffuselight + sky_light_color * _Opacity + _AddColor.xyz;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/dragon_seventeen.jpg" alt=""></p><p>之后添加对不同光源的处理得到最终结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取光的方向和scene中看到的实际相反</span><br><span class="line">float3 light_dir &#x3D; normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line">float3 light_dir_ohters &#x3D; normalize(_WorldSpaceLightPos0.xyz - i.pos_world);</span><br><span class="line">               &#x2F;&#x2F; w分量区分光源</span><br><span class="line">light_dir &#x3D; lerp(light_dir, light_dir_ohters, _WorldSpaceLightPos0.w);</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/dragon_out2.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;玉石材质模拟&quot;&gt;&lt;a href=&quot;#玉石材质模拟&quot; class=&quot;headerlink&quot; title=&quot;玉石材质模拟&quot;&gt;&lt;/a&gt;玉石材质模拟&lt;/h1&gt;&lt;p&gt;整体效果：&lt;/p&gt;
&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-lazy-sr
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>扫光、流光shader制作</title>
    <link href="https://crunchybiscuits.github.io/2021/03/24/%E6%89%AB%E5%85%89%E3%80%81%E6%B5%81%E5%85%89shader%E5%88%B6%E4%BD%9C/"/>
    <id>https://crunchybiscuits.github.io/2021/03/24/%E6%89%AB%E5%85%89%E3%80%81%E6%B5%81%E5%85%89shader%E5%88%B6%E4%BD%9C/</id>
    <published>2021-03-23T16:13:35.000Z</published>
    <updated>2021-04-09T15:40:57.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="流光-边缘光shader制作过程"><a href="#流光-边缘光shader制作过程" class="headerlink" title="流光+边缘光shader制作过程"></a>流光+边缘光shader制作过程</h1><p>整个制作流程由边缘光+流光的效果组成</p><h2 id="整体效果展示"><a href="#整体效果展示" class="headerlink" title="整体效果展示"></a>整体效果展示</h2><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/zeko_out.gif" alt=""></p><h2 id="开始之前的处理"><a href="#开始之前的处理" class="headerlink" title="开始之前的处理"></a>开始之前的处理</h2><ol><li><p>首先创建空白Scene</p></li><li><p>创建新的material，在material的shader类型中选择skybox-&gt;Panoramic，选择深色颜色</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/sky.jpg" alt=""></p></li><li><p>在场景中添加一个plane，并放大至足够大</p></li><li><p>为plane添加一个material，并添加一张类似聚光的贴图，这里用了unity的TransparentOverlay</p></li><li><p>奖plane对应material的Specular和Highlights关掉，并将smoothness调到0</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/plane.jpg" alt=""></p></li><li><p>在lighting设置中打开雾效，并拾色plane和天空衔接位置的颜色</p></li><li><p>导入模型，并为模型添加相应的贴图</p></li></ol><p>初始效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/class2.jpg" alt=""></p><h1 id="边缘光"><a href="#边缘光" class="headerlink" title="边缘光"></a>边缘光</h1><p>首先创建一个Unlit Shader，代入模型中效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/start_zeko.jpg" alt=""></p><p>边缘光的主要原理是<strong>根据物体的法线与视线对应向量的点积</strong>进行变换</p><p>因此首先要在顶点shader中计算对应的法线信息并输出给片元shader</p><p>接着需要计算顶点位置并在片元shader中计算视线方向</p><p>下一步计算法线和视线方向的点积，并通过1相减，对结果可通过smoothstep函数进行调整</p><figure class="highlight plain"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i):SV_Target&#123;</span><br><span class="line">    half3 normal_world &#x3D; normalize(i.normal_world);</span><br><span class="line">    half3 view_dir &#x3D; normalize(_WorldSpaceCameraPos.xyz - i.pos);</span><br><span class="line">    &#x2F;&#x2F; saturate这里控制变量大小在0-1</span><br><span class="line">    half3 NdotV &#x3D; saturate(dot(normal_world, view_dir));</span><br><span class="line">    half3 fresnel &#x3D; 1.0 - NdotV;</span><br><span class="line">    &#x2F;&#x2F; 添加强度和饱和度</span><br><span class="line">    fresnel &#x3D; smoothstep(_RimMin,_RimMax, fresnel);</span><br><span class="line">    &#x2F;&#x2F; 输出尝试效果</span><br><span class="line">    return fresnel.xxxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/second_zeko.jpg" alt=""></p><p>接下来需要打开对应的半透明效果：</p><p>在Subshader中设置Tag, 在Pass中设置blend和zwrite</p><p>打开半透明效果后如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/third_zeko.jpg" alt=""></p><p>这里需要添加额外一个pass将物体中间的纹理去掉，只剩表面的边缘光</p><p>之后效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/forth_zeko.jpg" alt=""></p><p>接着为shader添加主贴图自发光相当于r通道一个效果，并添加颜色和alpha</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fixed4 emiss &#x3D; tex2D(_MainTex, i.uv).r;</span><br><span class="line">   emiss &#x3D; pow(emiss, 5.0);</span><br><span class="line">   half final_fresnel &#x3D; saturate(emiss + fresnel);</span><br><span class="line"></span><br><span class="line">      half3 final_rim_color &#x3D; lerp(_InnerColor.xyz, _RimColor.xyz * _RimIntensity, final_fresnel);</span><br><span class="line">   half final_rim_alpha &#x3D; final_fresnel;</span><br></pre></td></tr></table></figure><p>之后效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/fifth_zeko.jpg" alt=""></p><p>最后为贴图添加阴影使用fallback “diffuse”</p><p>效果如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/sixth_zeko.jpg" alt=""></p><h1 id="流光"><a href="#流光" class="headerlink" title="流光"></a>流光</h1><p>接着制作流光的效果，原理是通过采样世界空间下的坐标点来采样流光的贴图，本质上是uv随时间在一个轴上进行变换</p><figure class="highlight plain"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">float4 frag(v2f i):SV_Target&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    half2 uv_flow &#x3D; (i.pos_world.xy - i.pivot_world.xy) * _FLowTilling.xy;</span><br><span class="line">    uv_flow &#x3D; uv_flow +  _Time.y * _FlowSpeed.xy;</span><br><span class="line">    float4 flow_rgba &#x3D; tex2D(_FlowTex, uv_flow) * _FlowIntensity;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>单独流光效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/seventh_zeko.jpg" alt=""></p><h1 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h1><figure class="highlight plain"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float3 final_col &#x3D; flow_rgba.xyz + final_rim_color;</span><br><span class="line">float final_alpha &#x3D; saturate(flow_rgba.a + final_rim_alpha + _InnerAlpha);</span><br><span class="line"></span><br><span class="line">return float4(final_col,final_alpha);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;流光-边缘光shader制作过程&quot;&gt;&lt;a href=&quot;#流光-边缘光shader制作过程&quot; class=&quot;headerlink&quot; title=&quot;流光+边缘光shader制作过程&quot;&gt;&lt;/a&gt;流光+边缘光shader制作过程&lt;/h1&gt;&lt;p&gt;整个制作流程由边缘光+流光的
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>MatCap制作薄膜干涉效果</title>
    <link href="https://crunchybiscuits.github.io/2021/03/23/MatCap%E6%95%88%E6%9E%9C%E5%88%B6%E4%BD%9C/"/>
    <id>https://crunchybiscuits.github.io/2021/03/23/MatCap%E6%95%88%E6%9E%9C%E5%88%B6%E4%BD%9C/</id>
    <published>2021-03-23T01:22:55.000Z</published>
    <updated>2021-04-09T15:41:25.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MatCap效果制作"><a href="#MatCap效果制作" class="headerlink" title="MatCap效果制作"></a>MatCap效果制作</h1><h2 id="MatCap原理"><a href="#MatCap原理" class="headerlink" title="MatCap原理"></a>MatCap原理</h2><p>又叫material capture，将模型的法线数据跟着摄像机进行变化，之后将这个法线数据应用到纹理采样中，去采样贴图。效果是在贴图的圆形区域采样，能够将这个质感还原回去。缺点是只能跟着视角进行相应而且效果是变化的。</p><h2 id="制作流程"><a href="#制作流程" class="headerlink" title="制作流程"></a>制作流程</h2><p>首先导入模型，当前效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/matcap_1.jpg" alt=""></p><p>接着实现matcap的效果，matcap主要的实现方式将世界空间下的法线转换到相机空间，通过转换后的法线对uv进行采样</p><p>输出当前效果为：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/matcap_2.jpg" alt=""></p><p>接着添加模型材质本身颜色</p><p>当前效果为：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/matcap_3.jpg" alt=""></p><p>接下来添加渐变映射，ramp制作过程见最底部</p><figure class="highlight plain"><figcaption><span>shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">half3 view_dir &#x3D; normalize(_WorldSpaceCameraPos.xyz - i.pos_world);</span><br><span class="line">half NdotV &#x3D; saturate(dot(normal_world, view_dir));</span><br><span class="line">half fresnel &#x3D; 1.0 - NdotV;</span><br><span class="line">half2 uv_ramp &#x3D; half2(fresnel, 0.5);</span><br><span class="line">half4 ramp_color &#x3D; tex2D(_RampTex, uv_ramp);</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/matcap_4.jpg" alt=""></p><p>之后添加叠加的matcap</p><p>尝试添加法线贴图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;normal</span><br><span class="line">half4 normal_map &#x3D; tex2D(_Normal, i.uv);</span><br><span class="line">&#x2F;&#x2F; 解码</span><br><span class="line">half3 normal_data &#x3D; UnpackNormal(normal_map);</span><br><span class="line">half3 normal_dir &#x3D; normalize(i.normal_dir.xyz);</span><br><span class="line">half3 tangent_dir &#x3D; normalize(i.tangent_dir);</span><br><span class="line">half3 binormal_dir &#x3D; normalize(i.binormal_dir);</span><br><span class="line"></span><br><span class="line">normal_dir &#x3D; normalize(tangent_dir * normal_data.x + binormal_dir * normal_data.y + normal_dir * normal_data.z);</span><br><span class="line">&#x2F;&#x2F; spec</span><br><span class="line">half3 light_dir &#x3D; normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line">half3 reflect_dir &#x3D; reflect(-light_dir, normal_dir);</span><br><span class="line">half RdotV &#x3D; dot(reflect_dir, view_dir);</span><br><span class="line">half3 spec_color &#x3D; pow(max(0.0, RdotV), 2.0) * _LightColor0.xyz * 0.1;</span><br></pre></td></tr></table></figure><p><strong>LightColor0一定要定义！！！LightColor0一定要定义！！！LightColor0一定要定义！！！</strong></p><p>被坑惨</p><p>效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/matcap_6.jpg" alt=""></p><p>最终效果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/beetle.gif" alt=""></p><h2 id="Ramp贴图制作过程"><a href="#Ramp贴图制作过程" class="headerlink" title="Ramp贴图制作过程"></a>Ramp贴图制作过程</h2><p>打开ps，按下T使用渐变桶，在当前图层进行操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MatCap效果制作&quot;&gt;&lt;a href=&quot;#MatCap效果制作&quot; class=&quot;headerlink&quot; title=&quot;MatCap效果制作&quot;&gt;&lt;/a&gt;MatCap效果制作&lt;/h1&gt;&lt;h2 id=&quot;MatCap原理&quot;&gt;&lt;a href=&quot;#MatCap原理&quot; cla
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>基础shader记录</title>
    <link href="https://crunchybiscuits.github.io/2021/03/22/%E5%9F%BA%E7%A1%80shader%E8%AE%B0%E5%BD%95/"/>
    <id>https://crunchybiscuits.github.io/2021/03/22/%E5%9F%BA%E7%A1%80shader%E8%AE%B0%E5%BD%95/</id>
    <published>2021-03-22T12:35:48.000Z</published>
    <updated>2021-03-25T12:06:54.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础shader分析"><a href="#基础shader分析" class="headerlink" title="基础shader分析"></a>基础shader分析</h1><h3 id="常见的语义词："><a href="#常见的语义词：" class="headerlink" title="常见的语义词："></a>常见的语义词：</h3><ol><li>获取顶点 — float4 vertex : POSITION;</li><li>获取第一uv — float2 uv : TEXCOORD0;</li><li>获取发现 — float3 normal : NORMAL;</li><li>获取顶点色 — float4 color : COLOR；</li><li>获取切线 — float4 tan : TANGENT；</li></ol><h3 id="常用的数据类型对应"><a href="#常用的数据类型对应" class="headerlink" title="常用的数据类型对应"></a>常用的数据类型对应</h3><p>精度设置float – 32位，half – 16位， fixed – 8位</p><ol><li>float常用于坐标点 </li><li>half常用于UV和大部分向量</li><li>fixed常用于颜色</li></ol><h2 id="基础shader内容："><a href="#基础shader内容：" class="headerlink" title="基础shader内容："></a>基础shader内容：</h2><h3 id="获取位置坐标并输出"><a href="#获取位置坐标并输出" class="headerlink" title="获取位置坐标并输出"></a>获取位置坐标并输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1. 基础变换 -- 顶点着色器中将物体转换到裁剪空间</span><br><span class="line">v2f vert(appdata v)&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    &#x2F;&#x2F; 模型转换到世界空间</span><br><span class="line">    float4 pos_world &#x3D; mul(_Object2World, v.vertex);</span><br><span class="line">    &#x2F;&#x2F; 世界空间到相机空间</span><br><span class="line">    float4 pos_view &#x3D; mul(UNITY_MATRIX_V, pos_world);</span><br><span class="line">    &#x2F;&#x2F; 相机空间到裁剪空间</span><br><span class="line">    float4 pos_clip &#x3D; mul(UNITY_MATRIX_P, pow_view);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 以上变换可以用mvp代替</span><br><span class="line">    &#x2F;&#x2F; o.pos &#x3D; UnityObjectToClipPos(v.vertex);</span><br><span class="line">    </span><br><span class="line">    o.pos &#x3D; pos_clip;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. 输出颜色 -- 片元着色器获取顶点并输出</span><br><span class="line">float4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">    return float4(0.5,1.0,0.5,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的内容</strong><br>在声明的构造体appdata和v2f中的TEXCOORD0是有差别的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct appdata&#123;</span><br><span class="line">    &#x2F;&#x2F; 第一套uv</span><br><span class="line">    float2 uv : TEXCOORD0;</span><br><span class="line">    &#x2F;&#x2F; 第二套uv</span><br><span class="line">    float2 uv2 : TEXCOORD1; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f&#123;</span><br><span class="line">    &#x2F;&#x2F; 这里表示的是存储器、插值器</span><br><span class="line">    float2 uv : TEXCOORD0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="获取uv贴图并输出"><a href="#获取uv贴图并输出" class="headerlink" title="获取uv贴图并输出"></a>获取uv贴图并输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. 基础变换 -- 顶点着色器中将物体转换到裁剪空间,获取uv</span><br><span class="line">sampler2D _MainTex;</span><br><span class="line">&#x2F;&#x2F; 这个参数是跟贴图的tilling和offset链接</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">v2f vert(appdata v)&#123;</span><br><span class="line">    v2f o;</span><br><span class="line"></span><br><span class="line">    o.pos &#x3D; UnityObjectToClipPos(v.vertex);</span><br><span class="line">    &#x2F;&#x2F; o.uv &#x3D; v.uv;</span><br><span class="line">    o.uv &#x3D; v.uv * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. 输出颜色 -- 片元着色器获uv并输出</span><br><span class="line">float4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">    &#x2F;&#x2F;获取uv并输出 </span><br><span class="line">    float4 col &#x3D; tex2D(_MainTex, i.uv);</span><br><span class="line">    return col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="背面剔除"><a href="#背面剔除" class="headerlink" title="背面剔除"></a>背面剔除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Properties&#123;</span><br><span class="line">    [Enum(UnityEngine.Rendering.CullMode)]_CullMode(&quot;CullMode&quot;, float) &#x3D; 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubShader&#123;</span><br><span class="line">    Pass&#123;</span><br><span class="line">        Cull[_CullMode]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Alpha-Test"><a href="#Alpha-Test" class="headerlink" title="Alpha Test"></a>Alpha Test</h3><p>对clip()函数的使用：</p><p>大体思路：</p><ol><li>通过tex2D获取r通道</li><li>对gradient进行操作</li><li>输出gradient.xxxx</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">half4 frag(v2f i): SV_Target&#123;</span><br><span class="line">    half gradient &#x3D; tex2D(_MainTex, i.uv+_Time.y * _Speed.xy).r;</span><br><span class="line">    half noise &#x3D; tex2D(_NoiseTex, i.uv+_Time.y*_Speed.zw).r;</span><br><span class="line">    clip(gradient - noise - _Cutout);</span><br><span class="line">    return _MainColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="半透明混合"><a href="#半透明混合" class="headerlink" title="半透明混合"></a>半透明混合</h3><p>大体思路：</p><ol><li>在pass中打开Blend src dst</li><li>关掉Zwrite – Zwrite off</li><li>Subshader中Tags = {“Queue” = “Transparent”}</li></ol><p><strong>在贴图没有alpha通道的时候怎么做</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 尽量将颜色和alpha分开写，最后再组合</span><br><span class="line">half3 col &#x3D; _MainColor.xyz;</span><br><span class="line">&#x2F;&#x2F; 用贴图灰度值 * 颜色的alpha代替alpha</span><br><span class="line">half alpha &#x3D; tex2D(_MainTex, i.uv).r * _MainColor.a;</span><br><span class="line">return float4(col, alpha);</span><br></pre></td></tr></table></figure><h3 id="边缘光"><a href="#边缘光" class="headerlink" title="边缘光"></a>边缘光</h3><p><strong>实质，dot(n,v)</strong></p><ol><li>实现设置强度</li><li>实现设置对比度</li><li>预先写深度 — 通过提前写一个pass，并且在里面设置ColorMask 0将颜色信息的写入取消<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这里顶点着色器仅写了相关代码</span><br><span class="line">v2f vert(appdata v)&#123;</span><br><span class="line">    &#x2F;&#x2F; normal计算方式</span><br><span class="line">    o.normal_world &#x3D; normalize(mul(float4(v.normal,0.0), _Object2World).xyz);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 视线计算方式，相机位置减去点的位置</span><br><span class="line">    float3 pos_world &#x3D; mul(_Object2World, v.vertex).xyz;</span><br><span class="line">    float3 view_world &#x3D;     normalize(_WolrdSpaceCameraPos.xyz - pos_world);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 片元着色器中计算 N dot V</span><br><span class="line">half4 frag(v2f i):SV_Target&#123;</span><br><span class="line">    float3 normal_world &#x3D; normalize(i.normal_world);</span><br><span class="line">    float3 view_world &#x3D; normalize(i.view_world);</span><br><span class="line">    float NdotV &#x3D; saturate(dot(normal_world, view_world));</span><br><span class="line">    </span><br><span class="line">    float3 col &#x3D; _MainColor.xyz * _Emiss;</span><br><span class="line">    &#x2F;&#x2F; 对比度</span><br><span class="line">    float fresnel &#x3D; pow((1.0 - NdotV), _RimPower);</span><br><span class="line">    &#x2F;&#x2F; 强度</span><br><span class="line">    float alpha &#x3D; saturate(fresnel * _Emiss);</span><br><span class="line"></span><br><span class="line">    return float4(col, alpha);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如何设置强度</span><br><span class="line">float alpha &#x3D; (1.0 - NdotV) * _Emiss;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如何设置对比度</span><br><span class="line">float fresnel &#x3D; pow((1.0 - NdotV), _RimPower);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础shader分析&quot;&gt;&lt;a href=&quot;#基础shader分析&quot; class=&quot;headerlink&quot; title=&quot;基础shader分析&quot;&gt;&lt;/a&gt;基础shader分析&lt;/h1&gt;&lt;h3 id=&quot;常见的语义词：&quot;&gt;&lt;a href=&quot;#常见的语义词：&quot; class
      
    
    </summary>
    
    
    
      <category term="Shader" scheme="https://crunchybiscuits.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>GAMES202作业0</title>
    <link href="https://crunchybiscuits.github.io/2021/03/22/GAMES202%E4%BD%9C%E4%B8%9A0/"/>
    <id>https://crunchybiscuits.github.io/2021/03/22/GAMES202%E4%BD%9C%E4%B8%9A0/</id>
    <published>2021-03-21T16:25:10.000Z</published>
    <updated>2021-03-21T16:32:17.620Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GAMES202作业0"><a href="#GAMES202作业0" class="headerlink" title="GAMES202作业0"></a>GAMES202作业0</h1><p>本次作业主要为熟悉框架，通过框架实现blinn-phong，无特殊要求</p><p>大致步骤：</p><ol><li>使用GLSL编写对应vert和frag shader</li><li>将shader的字符串形式传递到javascript实现的PhongMaterial类中</li><li>在index.html中导入</li><li>将框架中原来使用的Material替换为编写好的PhongMaterial类</li></ol><h3 id="最初效果"><a href="#最初效果" class="headerlink" title="最初效果"></a>最初效果</h3><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/202assign0_1.jpg" alt="渲染方程"></p><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/202assign0_2.jpg" alt="渲染方程"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GAMES202作业0&quot;&gt;&lt;a href=&quot;#GAMES202作业0&quot; class=&quot;headerlink&quot; title=&quot;GAMES202作业0&quot;&gt;&lt;/a&gt;GAMES202作业0&lt;/h1&gt;&lt;p&gt;本次作业主要为熟悉框架，通过框架实现blinn-phong，无特殊要
      
    
    </summary>
    
    
    
      <category term="GAMES202" scheme="https://crunchybiscuits.github.io/tags/GAMES202/"/>
    
  </entry>
  
  <entry>
    <title>GAMES202-Lecture2笔记</title>
    <link href="https://crunchybiscuits.github.io/2021/03/20/GAMES202-Lecture2%E7%AC%94%E8%AE%B0/"/>
    <id>https://crunchybiscuits.github.io/2021/03/20/GAMES202-Lecture2%E7%AC%94%E8%AE%B0/</id>
    <published>2021-03-20T08:59:35.000Z</published>
    <updated>2021-03-21T16:28:21.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GAMES202第二课"><a href="#GAMES202第二课" class="headerlink" title="GAMES202第二课"></a>GAMES202第二课</h1><h2 id="基本渲染管线"><a href="#基本渲染管线" class="headerlink" title="基本渲染管线"></a>基本渲染管线</h2><ol><li>体在空间中的表示 – 点，点和点之间的连接关系</li></ol><ul><li>顶点处理    MVP</li><li>图元装配和光栅化</li><li>片元处理</li><li>输出合并</li></ul><ol start="2"><li><p>型（Blinn-Phong等等）在光线的弹射和阴影的表现上并不是很好（并不是100%真实，在全局和间接光照上处理的不好）</p><p>好处是GPU上跑很快</p></li><li><p>纹理映射和插值–重心坐标</p></li></ol><h2 id="OpenGL-GLSL"><a href="#OpenGL-GLSL" class="headerlink" title="OpenGL(GLSL)"></a>OpenGL(GLSL)</h2><h3 id="OpenGL介绍"><a href="#OpenGL介绍" class="headerlink" title="OpenGL介绍"></a>OpenGL介绍</h3><p>OpenGL是一个API的集合，是CPU运行的负责调用GPU工作任务的。</p><p>优势：</p><ul><li>语言无关</li><li>跨平台</li></ul><p>坏处：</p><ul><li>版本特别碎片化</li><li>C语言风格，不方便使用</li></ul><p><strong>在每个pass中进行的过程</strong></p><ol><li>放置物体和模型<ol><li>模型声明</li><li>模型摆放 – model transformation</li><li>VBO：GPU中的一块区域用于存储模型与.obj文件特别相似</li></ol></li><li>设置相机位置<ol><li>视口变换 – view transformation</li><li>在OpenGL中创建framebuffer</li></ol></li><li>设置画布<ol><li>这里OpenGL可以multiple render target</li><li>垂直同步，双重缓冲，三重缓冲，目的都是为了防止画面撕裂，撕裂原因是在帧缓冲中上一帧画面渲染到一般又渲染了下一帧</li></ol></li><li>画 – shading<ol><li>vertex<ol><li>对顶点进行插值</li></ol></li><li>图元装配光栅化</li><li>fragment<ol><li>片段着色</li><li>lighting</li></ol></li></ol></li><li>接着画，画多次 – multiple passes<ol><li>shadowmap的作法<ol><li>计算光源能看到什么</li><li>再通过camera来计算这些物体能不能被light看到，不能就是在阴影中</li></ol></li></ol></li></ol><p>Shader setup步骤</p><ol><li>创建shader</li><li>编译shader</li><li>将shader加载到程序中(attach program)</li><li>连接程序(link program)</li><li>使用程序(use program)</li></ol><h3 id="Vertex-Shader-顶点着色器"><a href="#Vertex-Shader-顶点着色器" class="headerlink" title="Vertex Shader(顶点着色器)"></a>Vertex Shader(顶点着色器)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// attribute这个只可能在vertex shader中出现，fragment shader中没有</span></span><br><span class="line"><span class="comment">// 顶点位置</span></span><br><span class="line">attribute vec3 aVertexPosition;</span><br><span class="line"><span class="comment">// 法线位置</span></span><br><span class="line">attribute vec3 aNormalPosition;</span><br><span class="line"><span class="comment">// 纹理坐标</span></span><br><span class="line">attribute vec3 aTextureCoord;</span><br><span class="line"></span><br><span class="line"><span class="comment">// uniform关键字指定全局变量，vertex和fragment shader都可以用</span></span><br><span class="line">uniform mat4 uModeViewMatrix;</span><br><span class="line">uniform mat4 uProjectionMatrix;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过varying关键字指定fragment shader中需要插值的量</span></span><br><span class="line"><span class="comment">// highp指定计算精度</span></span><br><span class="line">varying highp vec2 vTextureCoord;</span><br><span class="line">varying highp vec3 vFragPos;</span><br><span class="line">varying highp vec3 vNormal;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 设置要传给frag的属性</span></span><br><span class="line">    vFragPos = aVertexPosition;</span><br><span class="line">    vNormal = aNormalPosition;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换成齐次坐标再进行MVP</span></span><br><span class="line">    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, <span class="number">1.0</span>);</span><br><span class="line">    </span><br><span class="line">    vTextureCoord = aTextureCoord;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Fragment-shader"><a href="#Fragment-shader" class="headerlink" title="Fragment shader"></a>Fragment shader</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uniform关键字指定全局变量，vertex和fragment shader都可以用</span></span><br><span class="line">uniform sampler2D uSampler;</span><br><span class="line"><span class="comment">// binn</span></span><br><span class="line">uniform vec3 uKd;</span><br><span class="line">uniform vec3 uKs;</span><br><span class="line">uniform vec3 uLightPos;</span><br><span class="line">uniform vec3 uCameraPos;</span><br><span class="line">uniform <span class="keyword">float</span> uLightIntensity;</span><br><span class="line">uniform <span class="keyword">int</span> uTextureSample;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过varying关键字指定fragment shader中需要插值的量</span></span><br><span class="line">varying highp vec2 vTextureCoord;</span><br><span class="line">varying highp vec3 vFragPos;</span><br><span class="line">varying highp vec3 vNormal;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    vec3 color;</span><br><span class="line">    <span class="keyword">if</span>(uTextureSample == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// vec3(2.2)表示伽马矫正</span></span><br><span class="line">        color = <span class="built_in">pow</span>(texture2D(uSampler, vTextureCoord).rgb, vec3(<span class="number">2.2</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        color = uKd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 环境光</span></span><br><span class="line">    vec3 ambient = <span class="number">0.05</span> * color;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 光线方向由光源位置-点位置得到</span></span><br><span class="line">    vec3 lightDir = normalize(uLightPos - vFragPos);</span><br><span class="line">    vec3 normal = normalize(vNormal);</span><br><span class="line">    <span class="comment">// 兰伯特</span></span><br><span class="line">    <span class="keyword">float</span> diff = max(dot(lightDir, normal), <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// 光照强度系数</span></span><br><span class="line">    <span class="keyword">float</span> light_atten_coff = uLightIntensity / length(uLightPos - vFragPos);</span><br><span class="line">    <span class="comment">// 漫反射</span></span><br><span class="line">    vec3 diffuse = diff * light_atten_coff * color;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 视线方向</span></span><br><span class="line">    vec3 viewDir = normalize(uCameraPos - vFragPos);</span><br><span class="line">    <span class="keyword">float</span> spec = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// 反射方向，需要从点出发，光源方向也是从点出发表示，因此为-lightDir</span></span><br><span class="line">    vec3 reflectDir = reflect(-lightDir, normal);</span><br><span class="line">    <span class="comment">// 高光</span></span><br><span class="line">    spec = <span class="built_in">pow</span>(max(dot(viewDir, reflectDir), <span class="number">0.0</span>), <span class="number">35.0</span>);</span><br><span class="line">    <span class="comment">// 加上高光强度</span></span><br><span class="line">    vec3 specular = uKs * light_atten_coff * spec;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// blinn-phong</span></span><br><span class="line">    gl_FragColor = vec4(<span class="built_in">pow</span>((ambient + diffuse + specular), vec3(<span class="number">1.0</span>/<span class="number">2.2</span>)), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h2><p>在渲染中是最为重要的</p><ul><li>描述了光线的传播</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/rendering%20equation.jpg" alt="渲染方程"></p><p>意思解释：</p><ol><li>outgoing radiance：当前点发出的radiance</li><li>emission：点的自发光</li><li>BRDF * cosθ * dw：BRDF乘上cosθ然后乘以其他地方打到这个点上的radiance<ol><li>cosθ * dw： 是将radiance转换成irradiance</li></ol></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/CrunchyBiscuits/Image-Host/master/img/render%20equation2.jpg" alt="渲染方程"></p><p>V(p, w)：表示点是否可以接收到当前传过来的那束光</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GAMES202第二课&quot;&gt;&lt;a href=&quot;#GAMES202第二课&quot; class=&quot;headerlink&quot; title=&quot;GAMES202第二课&quot;&gt;&lt;/a&gt;GAMES202第二课&lt;/h1&gt;&lt;h2 id=&quot;基本渲染管线&quot;&gt;&lt;a href=&quot;#基本渲染管线&quot; cla
      
    
    </summary>
    
    
    
      <category term="GAMES202" scheme="https://crunchybiscuits.github.io/tags/GAMES202/"/>
    
  </entry>
  
</feed>
